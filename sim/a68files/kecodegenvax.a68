DECS kecodegenvax CONTEXT VOID USE putstrings, osinterface,
*U    unixinterface,
*4    vmsinterface,
      basics, kebasics, kemassemvax, kecodegenbiopifvax,
      kecodegenalienifvax, kecodegenservervax, kecodegenstackvax:

{ " Id: kecodegenvax.sta,v 2.1 91/02/22 18:35:06 edcad Exp$" }
configinfo A68CONFIG "$Id: kecodegenvax.a68,v 34.2 1995/03/29 13:04:50 ella Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1993

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

05:06:89  R4B361.  SPT.  Include UNIX style interrupt handling for ULTRIX.
06:06:89  R4B343.  SPT.  Disable error checking for cntrl C.  This was
             unfortunately necessary because errors occur when instating
             an AST handler if interactive and reading from a command file.
16:06:89  R4B373.  SPT.  Word label size too small for jump and jump no.
23:05:89  R4B383.  SPT.  Integrate host real exception handling.
04:12:89  'cg extend space' added.  PAR.
04:12:89  Parameter to 'generate callinst' generalised.  PAR.
11:06:93  VAX signal handling disabled - need to implement OSIF2 signals on
             UNIX to understand what to do on VAX ***********************  DCT
16:06:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number  31.007 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT

{                             VAX Code Generator                               }
{------------------------------------------------------------------------------}

{ Notes
  -----

 Background
 ----------

 The code generator has been implemented using object oriented development.

 Each object class is represented by a MODE declaration.

 Each operation is represented by an OP declaration, except for a constructor
 operation which is implemented for each class as a procedure which returns
 an example of the class.  The use of OP for operations is convenient
 because it allows overloading of operation names.

 Note that because ALGOL68 resolves overloading of operators (etc) by the
 structure of the type involved and as the structure of some distinct types
 are likely to be the same it would appear at first sight that some operators
 might be ambiguous.  In fact, the compiler doesn't allow the declaration
 of ambiguous operators so it is sometimes necessary to introduce extra
 characters into type field names to differenciate one from the other.

 No subclassing or inheritance is used.

 Layout
 ------

 Each class (=MODE) definition is given and underlined.  After each mode
 definition is given the constructor procedure followed by the operations
 (=OP) with full definitions.  For ideal encapsulation, only the operation
 names would appear together with the class but ALGOL doesn't make this easy.

 Exceptions
 ----------

 The machine assembler already exists as a set of procedures, and because this
 tends to be referenced by more than one object no attempt is made
 to make it an object with operations.

 The code generator itself must have an interface conforming to the relevant
 standard [see "Code Generation in the New Simulator" P029.50.17].
 This is a set of procedures.  Thus the code generator itself is not
 an object either.

}

{======================================================================}
MODE CODEGENERATOR
{---------------------------------------}

   = STRUCT (MEMORY global_memory,
              MEMORY dynamic_memory,
              MEMORY static_memory,
              STACKALLOCATOR stack_allocator,

              REF BACKPATCHLIST jump_backpatch_list,
              REF SPECLIST jump_spec_list,
              REF MACHINEOFFSETSTACK repeat_stack,

              REF LABELLIST named_data_list,
              REF LABELLIST named_code_list,
              REF BACKPATCHLIST named_code_backpatch_list,
              REF PARAMETERLIST call_parameter_list,
              MACHINEOFFSET calls_location,
              BOOL reachable,
              INT diagnose);

CODEGENERATOR code_generator;

BYTENUMBER privatespace = 4;
   { A number of bytes reserved for the use of the code generator
     in global memory.  Should appear invisible to the translator. }

{ In allocating, and especially extending, abstract machine memory, we may
  wish to allocate more than was actually requested (so as to avoid too
  many actual extensions -- which are expensive).  The difference may
  of course be put towards future allocations.  So as to avoid complicating
  the underlying MODE MEMORY, we choose to keep this information in this
  module as a global variable:
}
INT spare space := 0;

{ Caches for optimisations }
{ ======================== }

{ We cache the values of the important offsets in the global memory
  array.  Since they are accessed as integers, we hold them as REF INTs.
  They are set up at the end of translation, restoration and whenever
  the global memory is extended.
}
REF INT time ref,
        maxtime ref,
        interrupt ref;

REF INT global memory start;    { used by alien code toolkit }

{ We also cache the entry point to the calls array, keeping it as a
  procedure variable
}
PROC (REF CHAR, REF CHAR, REF CHAR) VOID code entry;

{ This is used to convert an indexed reference to the global memory
  to an Algol 68 REF INT.  Note that the use for integers will
  automatically include the correct 'up' direction.  It is assumed
  that it will be used on locations which are correctly aligned
  for integer accesses.
}
OP (REF CHAR) REF INT INTAT = BIOP 99;

PROC set caches = VOID:
   BEGIN
      time ref      := INTAT (mem OF global_memory OF code_generator)
                              [((named_data_list OF code_generator)
                                LOOKUP label ("Time")) + 1 + privatespace];
      global memory start := time ref; { time is at start of global memory }
      maxtime ref   := INTAT (mem OF global_memory OF code_generator)
                              [((named_data_list OF code_generator)
                                LOOKUP label ("Maxtime")) + 1 + privatespace];
      interrupt ref := INTAT (mem OF global_memory OF code_generator)
                              [((named_data_list OF code_generator)
                                LOOKUP label ("Interrupted")) + 1 + privatespace];

      {
	Pass to alien code toolkit the information it needs at evaluation
	time.
      }
      PROC (REF INT, REF INT) VOID initialise alien toolkit =
%4          ALIEN "aci_initialise";
*4          ALIEN "ACI_INITIALISE";
      initialise alien toolkit(global memory start, time ref);

      OP (REF CHAR) PROC (REF CHAR, REF CHAR, REF CHAR) VOID RCTOP = BIOP 99;

      code entry := RCTOP ma code ref (calls_location OF code_generator)
   END;

{ Interrupt handling }
{ ================== }
{ CONDITIONHANDLER for integer overflows and divide by zero while
  simulating. }

*4PROC codegen_catch_int_error = (REF INT  arg1, arg2) STATUS:
*4BEGIN
*4   STATUS  condition = condition OF signal OF get_condition(arg1, arg2);
*4   IF condition MATCHCOND ss__intovf  OREL
*4      condition MATCHCOND ss__intdiv
*4   THEN
*4      BITS level = BIN (interrupt ref);
*4      REF INT (interrupt ref) := ABS (level OR BIN (8));
*4      ss__continue
*4   ELIF
*4      condition MATCHCOND ss__fltdiv   OREL
*4      condition MATCHCOND ss__fltdiv_f OREL
*4      condition MATCHCOND ss__fltovf   OREL
*4      condition MATCHCOND ss__fltovf_f OREL
*4      condition MATCHCOND ss__fltund   OREL
*4      condition MATCHCOND ss__fltund_f OREL
*4      condition MATCHCOND ss__roprand
*4   THEN
*4      unwind_n (1)
*4   ELSE
*4      ss__resignal
*4   FI
*4END;
*4
*4PROC codegen_interrupt_handler = VOID:
*4BEGIN
*4   BITS level = BIN (interrupt ref);
*4   IF NOT(level >= BIN (1)) THEN
*4      {if no interrupts yet, set soft interrupt}
*4      REF INT (interrupt ref) := ABS(level OR BIN (1))
*4   ELSE
*4      {if soft interrupt already, set hard interrupt}
*4      REF INT (interrupt ref) := ABS(level OR BIN (2))
*4   FI
*4END;
*4
*4PROC codegen_catch_interrupt = (REF INT channel) VOID:
*4BEGIN
*4   { Cancel message is generated automatically by VMS }
*4   codegen_interrupt_handler;
*4   { Enable <CTRL / C> trap.  Errors are silently ignored.  We know that
*4     catch_ctrl_c will fail in at least one case where 'interactive' is
*4     TRUE viz when running from a DCL file.  There is no obvious, sensible
*4     error action to take }
*4   catch_ctrl_c (channel, codegen_catch_interrupt, (STR msg) VOID: SKIP)
*4END;

*UPROC codegen_catch_int_error = VOID:
*U{ CONDITIONHANDLER for integer overflows and divide by zero while
*U  simulating. }
*U   BEGIN
*U      PROC VOID (catch_signal (sigfpe, codegen_catch_int_error));
*U      BITS level = BIN interrupt ref;
*U      REF INT (interrupt ref) := ABS(level OR BIN (8))
*U   END;
*U
*UPROC codegen_interrupt_handler = VOID:
*UBEGIN
*U      BITS level = BIN interrupt ref;
*U      IF NOT(level >= BIN(1)) THEN
*U         {if no interrupts yet, set soft interrupt}
*U         REF INT (interrupt ref) := ABS(level OR BIN(1))
*U      ELSE
*U         {if soft interrupt already, set hard interrupt}
*U         REF INT (interrupt ref) := ABS(level OR BIN(2))
*U      FI
*UEND;
*U
*UPROC codegen_catch_interrupt = VOID:
*U{ CONDITIONHANDLER for soft and hard interrupts while simulating. }
*U   BEGIN
*U      PROC VOID (catch_signal (sigint, codegen_catch_interrupt));
*U      codegen_interrupt_handler
*U   END;
*U
*U PROC VOID old_int_handler;

{ The procedural interface }
{ ======================== }

PROC cg initialise = (PROC (RVC) VOID diag, INT level, FLTPROC fltproc) AMVERSION:

   BEGIN
      ma initialise(fltproc); { Initialise machine assembler. }

      code_generator :=
         (nullmemory,
          nullmemory,
          nullmemory,
          stackallocator,

          backpatchlist,
          speclist,
          machineoffsetstack,

          labellist,
          labellist,
          backpatchlist,
          parameterlist,
          nullmachineoffset,
          FALSE,
          level);

      machangeflt(simfault);

      kecodegenbiopif init;

      am_version

   END;

PROC cg dump = VOID:
{ A diagnostic command to put out the state of the code generator. }
   BEGIN
      put (screen, ("CODE GENERATOR", newline));
      global_memory OF code_generator DUMP "  ";
      dynamic_memory OF code_generator DUMP "  ";
      static_memory OF code_generator DUMP  "  ";
      stack_allocator OF code_generator DUMP "  ";
      put (screen, ("jump backpatch list", newline));
      jump_backpatch_list OF code_generator DUMP "  ";
      put (screen, ("jump spec list", newline));
      jump_spec_list OF code_generator DUMP "  ";
      repeat_stack OF code_generator DUMP "  ";
      put (screen, ("named data list", newline));
      named_data_list OF code_generator DUMP "  ";
      put (screen, ("named code list", newline));
      named_code_list OF code_generator DUMP "  ";
      put (screen, ("named code backpatch list", newline));
      named_code_backpatch_list OF code_generator DUMP "  ";
      put (screen, ("call parameter list", newline));
      call_parameter_list OF code_generator DUMP "  ";
      put (screen, ("calls location", newline));
      calls_location OF code_generator DUMP "  ";
      put (screen, ("reachable", newline));
      reachable OF code_generator DUMP "  "
      { Don't dump the diagnostic level! }
   END;

PROC cg sizes =
   STRUCT (BYTENUMBER codesize, datasize, dynamicstacksize, staticstacksize):
{ A procedure returning the sizes of memory objects in the code generator. }
   (
      ma code size,
      SIZEOF global_memory OF code_generator,
      SIZEOF dynamic_memory OF code_generator,
      SIZEOF static_memory OF code_generator
   );

PROC cgsavestate = (PROC (REF VECTOR [] CHAR, FLTPROC) VOID ferryoutstatic,
                      ferryoutdynamic, FLTPROC flt) VOID:

   BEGIN
      IF dump code generator <= BIN diagnose OF code_generator THEN
         cg dump
      FI;

      machangeflt (flt);
      masavestate (ferryoutstatic);

      global_memory OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      dynamic_memory OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      static_memory OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      stack_allocator OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);

      { don't save jump_backpatch_list }
      { don't save jump_spec_list }
      { don't save repeat_stack }

      named_data_list OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      named_code_list OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      { don't save named_code_backpatch_list }

      call_parameter_list OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);
      calls_location OF code_generator SAVE
         ferryoutandflt (ferryoutdynamic, flt);

      { don't save reachable }
      { don't save the diagnostic level }

      spare space SAVE ferryoutandflt (ferryoutdynamic, flt);

      machangeflt (simfault)

   END;

PROC cgrestorestate = (PROC (REF VECTOR [] CHAR, FLTPROC) VOID ferryinstatic,
                      ferryindynamic, FLTPROC flt) VOID:

   BEGIN

      machangeflt (flt);
      marestorestate (ferryinstatic);

      global_memory OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      dynamic_memory OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      static_memory OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      stack_allocator OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);

      { don't restore jump_backpatch_list }
      { don't restore jump_spec_list }
      { don't restore repeat_stack }

      named_data_list OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      named_code_list OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      { don't restore named_code_backpatch_list }

      call_parameter_list OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);
      calls_location OF code_generator RESTORE
         ferryinandflt (ferryindynamic, flt);

      { don't restore reachable }
      { don't restore the diagnostic level }

      spare space RESTORE ferryinandflt (ferryindynamic, flt);

      machangeflt (simfault);

      set caches;

*4    IF interactive THEN
*4       { Enable <CTRL / C> trap.  Errors are silently ignored.  We know that
*4         catch_ctrl_c will fail in at least one case where 'interactive' is
*4         TRUE viz when running from a DCL file.  There is no obvious, sensible
*4         error action to take }
*4       catch_ctrl_c(input_channel, codegen_catch_interrupt,
*4          (STR msg) VOID: SKIP)
*4    FI;
*U    old_int_handler :=
*U              catch_signal(sigint, codegen_catch_interrupt);

      IF dump code generator <= BIN diagnose OF code_generator THEN
         cg dump
      FI
   END;

PROC generate halt = VOID:

   IF reachable OF code_generator THEN

      { Assemble exit code to HLL.}
      assemble (movl, ((-privatespace) DISP global pointer, R sp));
         { Restore the stack pointer to its value just after the in-line
           code started execution. }
      assemble (ret, ());
      STORECONSTANTS stack_allocator OF code_generator;
      CLEAR stack_allocator OF code_generator;
      reachable OF code_generator := FALSE
   FI;

PROC generate add = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      ADD stack_allocator OF code_generator
   FI;

PROC generate sub = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICOP ([] BITS (subl2, subl3))
   FI;

PROC generate mul = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICOP ([]BITS (mull2, mull3))
   FI;

PROC generate div = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICOP ([]BITS (divl2, divl3))
   FI;

PROC generate mod = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      MOD stack_allocator OF code_generator
   FI;

PROC generate neg = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      assemble (mnegl, GENERICMONOP stack_allocator OF code_generator)
   FI;

PROC generate abs = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      ABS stack_allocator OF code_generator
   FI;

PROC generate iand = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      IAND stack_allocator OF code_generator
   FI;

PROC generate ior = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICOP ([]BITS (bisl2, bisl3))
   FI;

PROC generate shl = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      SHL stack_allocator OF code_generator
   FI;

PROC generate shr = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      SHR stack_allocator OF code_generator
   FI;

PROC generate com = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      assemble (mcoml, GENERICMONOP stack_allocator OF code_generator)
   FI;

PROC generate not = VOID:

   IF reachable OF code_generator THEN
      NOT stack_allocator OF code_generator
   FI;

PROC generate test = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      TEST stack_allocator OF code_generator
   FI;

PROC generate eq = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      EQ stack_allocator OF code_generator
   FI;

PROC generate neq = VOID:

   IF reachable OF code_generator THEN
      generate eq;
      generate not
   FI;

PROC generate gt = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICRELATION gtr
   FI;

PROC generate ge = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICRELATION geq
   FI;

PROC generate lt = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICRELATION lss
   FI;

PROC generate le = VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator GENERICRELATION leq
   FI;

PROC generate and = VOID:

   IF reachable OF code_generator THEN
      generate iand
   FI;

PROC generate or = VOID:

   IF reachable OF code_generator THEN
      generate ior
   FI;

PROC generate push string = (BITNUMBER b, WORD x) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator PUSHCONST (x LEN b)
   FI;

PROC generate pushint = (INT x) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator PUSHINT x
   FI;

PROC generate drop = (INT n) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator DROP n
   FI;

PROC generate local = (INT n) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator LOCAL n
   FI;

PROC generate global = (INT w, ADDRESS a) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;

      CASE a IN
      (OFFSET o):
         BEGIN
            generate pushint (o);
            generate global (w, indirect)
         END,

      (LABEL l):
         BEGIN
            generate pushint (named_data_list OF code_generator LOOKUP l);
            generate global (w, indirect)
         END,

      (VOID):
         stack_allocator OF code_generator GLOBAL w
      ESAC
   FI;

PROC generate store = (INT w, ADDRESS a) VOID:

   IF reachable OF code_generator THEN
      { Note that the two operands of the store, that is, the
        value and address are reversed cf the abstract machine
        for the offset and label cases.  This is for convenience only. }
      FORCECONDITION stack_allocator OF code_generator;
      CASE a IN
      (OFFSET o):
         BEGIN
            generate pushint (o);
            stack_allocator OF code_generator STORE ((tos1 LEN w) ATT tos)
         END,

      (LABEL l):
         BEGIN
            generate pushint (named_data_list OF code_generator LOOKUP l);
            stack_allocator OF code_generator STORE ((tos1 LEN w) ATT tos)
         END,

      (VOID):
         stack_allocator OF code_generator STORE ((tos LEN w) ATT tos1)

      ESAC
   FI;

PROC generate bstring = (INT w, l, ADDRESS a) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;

      CASE a IN
      (OFFSET o):
         BEGIN
            generate pushint(o);
            generate bstring(w, l, indirect)
         END,
      (LABEL lab):
         BEGIN
            generate pushint(named_data_list OF code_generator LOOKUP lab);
            generate bstring(w, l, indirect)
         END,
      (VOID):
         stack_allocator OF code_generator BSTRING (w FROMM l)
      ESAC

   FI;

PROC generate bstore = (INT bw, ADDRESS a) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      generate store ((bw + 7) OVER 8, a)
   FI;

PROC generate itos = (INT bw) VOID:

   IF reachable OF code_generator THEN
      stack_allocator OF code_generator ITOS bw
   FI;

PROC generate utos = (INT bw) VOID:

   IF reachable OF code_generator THEN
      stack_allocator OF code_generator UTOS bw
   FI;

PROC generate stoi = VOID:

   IF reachable OF code_generator THEN
     STOI stack_allocator OF code_generator
   FI;

PROC generate stou = VOID:

   IF reachable OF code_generator THEN
      STOU stack_allocator OF code_generator
   FI;

PROC generate jump = (LABEL l) VOID:

   IF reachable OF code_generator THEN

      FORCECONDITION stack_allocator OF code_generator;
      CONFORM stack_allocator OF code_generator;

      MACHINELABEL ml;
      ma bra long (ml);
      jump_backpatch_list OF code_generator WRITE (ml ATT l);
      IF NOT (jump_spec_list OF code_generator PRESENT l) THEN
         jump_spec_list OF code_generator WRITE
            labeledspec(l, DERIVESPEC stack_allocator OF code_generator)
      FI;
      STORECONSTANTS stack_allocator OF code_generator;
      CLEAR stack_allocator OF code_generator;
      reachable OF code_generator := FALSE

   FI;

PROC generate jump no = (INT d, LABEL l) VOID:

   IF reachable OF code_generator THEN

      MACHINELABEL over;

      stack_allocator OF code_generator TRANSMUTESMALL tos;
      CASE location_stack OF stack_allocator OF code_generator STATEOF tos IN
      (CONDITION cc):
         BEGIN
            ma bcc byte (condition OF cc , over);
            POP stack_allocator OF code_generator
         END
      OUT
         BEGIN
            assemble(tstl,
               (stack_allocator OF code_generator) CURRENTOPERAND
                  ((stack_allocator OF code_generator) LOCATECOPY tos));
            ma bcc byte (neq , over);
            POP stack_allocator OF code_generator
         END
      ESAC;

      STACKALLOCATOR savedstack = NEW stack_allocator OF code_generator;

      TO d DO POP stack_allocator OF code_generator OD;

      CONFORM stack_allocator OF code_generator;

      MACHINELABEL ml;
      ma bra long (ml);
      jump_backpatch_list OF code_generator WRITE (ml ATT l);
      IF NOT (jump_spec_list OF code_generator PRESENT l) THEN
         jump_spec_list OF code_generator WRITE
            labeledspec (l, DERIVESPEC stack_allocator OF code_generator)
      FI;

      fixmachinelabel(over);
      stack_allocator OF code_generator := savedstack

   FI;

PROC generate label = (INT stacksize, LABEL l) VOID:

   BEGIN

      IF reachable OF code_generator THEN

         FORCECONDITION stack_allocator OF code_generator;
         CONFORM stack_allocator OF code_generator;

         IF jump_spec_list OF code_generator PRESENT l THEN
            (jump_spec_list OF code_generator LOOKUPREMOVE l)
         FI
      ELIF jump_spec_list OF code_generator PRESENT l THEN
         stack_allocator OF code_generator CREATESPEC
            (jump_spec_list OF code_generator LOOKUPREMOVE l);
         reachable OF code_generator := TRUE
      FI;

      REF MACHINELABELSTACK patches := jump_backpatch_list OF code_generator
         LOOKUPREMOVE l;
      WHILE NOT CLEARED patches DO fixmachinelabel(POP patches) OD
   END;

PROC generate repeat = VOID:

   IF reachable OF code_generator THEN

      FORCECONDITION stack_allocator OF code_generator;

      CONFORM stack_allocator OF code_generator;
      repeat_stack OF code_generator PUSH location

   FI;

PROC generate loop = VOID:

   IF reachable OF code_generator THEN

      MACHINELABEL over;

      stack_allocator OF code_generator TRANSMUTESMALL tos;
      CASE location_stack OF stack_allocator OF code_generator STATEOF tos IN
      (CONDITION cc):
         BEGIN
            ma bcc byte (invcondition(condition OF cc), over);
            POP stack_allocator OF code_generator
         END
      OUT
         BEGIN
            assemble(tstl,
               stack_allocator OF code_generator CURRENTOPERAND
                  ((stack_allocator OF code_generator) LOCATECOPY tos));
            ma bcc byte (eql, over);
            POP stack_allocator OF code_generator
         END
      ESAC;

      STACKALLOCATOR savedstack = NEW stack_allocator OF code_generator;
      CONFORM stack_allocator OF code_generator;
      ma bra (POP repeat_stack OF code_generator);

      fixmachinelabel (over);
      stack_allocator OF code_generator := savedstack

   FI;

PROC generate callinst = (ADDRESS addr, LABEL l) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;

      MACHINELABEL skip;
      CASE addr IN
          (OFFSET o):
             assemble (addl3,
                (R globalpointer, LITL o, R callinstpointer)),
          (LABEL lab):
             BEGIN
                generate pushint(named_data_list OF code_generator LOOKUP lab);
                generate callinst (indirect, l)
             END,
          (VOID): {Indirect}
             BEGIN
                stack_allocator OF code_generator MAKEREADABLE tos;
                assemble (addl3,
                         (R globalpointer,
                          stack_allocator OF code_generator CURRENTOPERAND tos,
                          R callinstpointer));
                stack_allocator OF code_generator DROP 1
             END
      ESAC;
      { What we load into the callinstptr includes the global memory
        pointer on the assumption that it will be indirected via.
        This may prove incorrect, and we may have to subtract the
        global memory pointer from it before using its value. }

      stack_allocator OF code_generator PUSHNEWSTACKLOCATION 32;
      location_stack OF stack_allocator OF code_generator
         CHANGESTATEOF (tos GIVEN inregister (TRUE));
      { Expected action is just possibly to force load out of a location
        down the stack. }

      MACHINEOFFSET staticframeoffset =
         stack_allocator OF code_generator ADVANCE
            (HEAP PARAMS := ((instanceptr, 32), NIL));
      { I don't expect this to generate any code, because the stack
        frame already contains the instance pointer in correct state. }

      assemble(tstl, RD callinstpointer);
      ma bcc byte (eql, skip);

      IF staticframeoffset /= 0 THEN
         { Advance both the frame pointer and the dynamic memory pointer
           if the stack contained more than just the instance pointer. }

         stack_allocator OF code_generator
            CALCULATENEWDYNAMICADDR tos;
         assemble (movl, (R dynamicpointer,  DR sp));
         assemble (movl, (R tempreg, R dynamicpointer));

         assemble(addl2, ( LITL staticframeoffset, R staticframepointer))
      FI;

      MACHINEOFFSET destination =
         named_code_list OF code_generator LOOKUP l;
      IF destination /= nullmachineoffset THEN
         ma bsr (destination)
      ELSE
         MACHINELABEL ml;
         ma bsr long (ml);
         named_code_backpatch_list OF code_generator WRITE (ml ATT l)
      FI;

      IF staticframeoffset /= 0 THEN
         assemble(subl2, (LITL staticframeoffset, R staticframepointer));
         assemble (movl, (RI sp, R dynamicpointer))
      FI;


      fixmachinelabel (skip);
      stack_allocator OF code_generator REPLACE
         [] REF PARAMS ((HEAP PARAMS := ((instanceptr,32),NIL)),NIL)

   FI;

PROC generate call = (INT ipstackframesize, LABEL l) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;

      IF NOT generate call biop (stack_allocator OF code_generator, l)
      ANDTH NOT generate call alien (stack_allocator OF code_generator, l)
      THEN
         [] REF PARAMS parameters = call_parameter_list OF code_generator
                                       LOOKUP l;

         "Stack frame size should match number of parameters" ASSERT
            (LENGTH parameters [1]) = ipstackframesize;

         MACHINEOFFSET staticframeoffset = stack_allocator OF code_generator
            ADVANCE parameters [1];

         IF staticframeoffset /= 0 THEN { Something below on the stack. }
            { Advance the dynamic memory pointer. }

            IF ipstackframesize /= 0 THEN { Something in the parameter list. }
               CASE (location_stack OF stack_allocator OF code_generator
                  TYPEOF (ipstackframesize - 1)) IN
               (SMALLSTACKLOCATION):
                  BEGIN
                     stack_allocator OF code_generator
                        CALCULATENEWDYNAMICADDR (ipstackframesize - 1);
                     assemble (movl, (R dynamicpointer, DR sp));
                     assemble (movl, (R tempreg, R dynamicpointer))
                  END
               OUT
                  BEGIN
                     assemble (movl, (R dynamicpointer, DR sp));
                     assemble (moval,
                        (stack_allocator OF code_generator CURRENTOPERAND
                        (ipstackframesize - 1), R dynamicpointer))
                  END
               ESAC
            ELSE { Nothing in the parameter list. }
               stack_allocator OF code_generator CALCULATENEWDYNAMICADDR - 1;
               assemble (movl, (R dynamicpointer, DR sp));
               assemble (movl, (R tempreg, R dynamicpointer))
            FI;
            { And advance the static frame pointer. }
            assemble (addl2, (LITL staticframeoffset, R staticframepointer))
         FI;

         MACHINEOFFSET destination =
            named_code_list OF code_generator LOOKUP l;
         IF destination /= nullmachineoffset THEN
            ma bsr (destination)
         ELSE
            MACHINELABEL ml;
            ma bsr long (ml);
            named_code_backpatch_list OF code_generator WRITE (ml ATT l)
         FI;

         IF staticframeoffset /= 0 THEN
            assemble(subl2, (LITL staticframeoffset, R staticframepointer));
            assemble (movl, (RI sp, R dynamicpointer))
         FI;

         { Next, we must reform the model stack to look as it should
           after the call. }
         stack_allocator OF code_generator
            REPLACE parameters

     FI

  FI;

PROC generate enter = VOID:

   SKIP;

PROC generate fanout = (INT offset) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;
      stack_allocator OF code_generator FANOUT offset
   FI;

PROC generate ret = (INT nooutputparams) VOID:

   IF reachable OF code_generator THEN
      FORCECONDITION stack_allocator OF code_generator;

      { Return from call or callinst. }
      stack_allocator OF code_generator COMPRESS nooutputparams;
         { Remove all but the output parameters from the stack. }

      assemble(rsb, ());

      { At this point we know the thread of control will never arrive. }

      STORECONSTANTS stack_allocator OF code_generator;

      CLEAR stack_allocator OF code_generator;
         { Clear the output parameters from the model stack. }

      reachable OF code_generator := FALSE

   FI;

PROC generate named code = (LABEL l, REF PARAMS ip, REF PARAMS op) VOID:

   BEGIN
      call_parameter_list OF code_generator WRITE labeledparams(l,ip,op);
      named_code_list OF code_generator WRITE labeledoffset(l, location);

      REF MACHINELABELSTACK patches :=
         (named_code_backpatch_list OF code_generator) LOOKUPREMOVE l;
      WHILE NOT CLEARED patches DO
         fix machine label (POP patches)
      OD;

       "Stack should be empty on arrival at named code." ASSERT
          LENGTH stack_allocator OF code_generator = 0;
       "Named code should be unreachable." ASSERT
          reachable OF code_generator = FALSE;

      stack_allocator OF code_generator CREATEPARAMS ip;
      reachable OF code_generator := TRUE

   END;

PROC generate named data = (LABEL l, OFFSET o) VOID:

   BEGIN

      named_data_list OF code_generator WRITE labeledoffset(l,o)

   END;

PROC generate param types = (LABEL l, REF PARAMS ip, REF PARAMS op) VOID:

   call_parameter_list OF code_generator WRITE labeledparams(l, ip, op);

PROC generate = (FLTPROC flt) VOID:

   machangeflt(flt);

PROC generateenddecls = VOID:

   BEGIN
      { End of non-calls array code.  I assume the last thing
        would have been a ret instruction (or a halt), which would have
        cleared the stack allocator. }

       "Stack allocator should be clear at end decls." ASSERT
         (CLEARED stack_allocator OF code_generator);
       "All jumps should be resolved at end decls." ASSERT
         (CLEARED jump_backpatch_list OF code_generator);
       "All repeats should be ended at end decls." ASSERT
         (CLEARED repeat_stack OF code_generator);
       "All calls and callinsts should be resolved at end decls." ASSERT
         (CLEARED named_code_backpatch_list OF code_generator);

       machangeflt(simfault)
   END;

PROC generateca = (FLTPROC flt) VOID:

   BEGIN

      machangeflt(flt);

      { Start calls array; First check to see if this is the
        first calls array. }
      IF calls_location OF code_generator = nullmachineoffset THEN
         calls_location OF code_generator := location
      ELSE
         location := calls_location OF code_generator;
         { Delete the label and params of the last code item
           (the only one in the calls array). }
         REMOVELAST call_parameter_list OF code_generator;
         REMOVELAST named_code_list OF code_generator
      FI;
      { Assemble entry code.  Assuming a HLL procedure call. }

      { Procedure entry mask; Save all registers we can (R0 - R11)
        and enable integer and decimal (should it every be required)
        overflows. }
      ma put word (16rcfff);

      { Locate the parameters }
      assemble (movl, (4 DISP ap, R static frame pointer));
      assemble (movl, (8 DISP ap, R dynamic pointer));
      assemble (movl, (12 DISP ap, R global pointer));
         { Set up dedicated registers.  Parameters are expected
           below the return address on the stack. }
      assemble (movl, (R sp, (-privatespace) DISP global pointer))

      { Although code has been assembled, the reachable flag is not set.
        A generate named code will follow. }
   END;

PROC generate endca = VOID:

   BEGIN

      { The action of arriving at this point, if it should happen,
        is the same as at a halt instruction. }

      generate halt;

      ma executable;

      { We reserve an extra 4 bytes because zero memory requirement causes
        us some difficultly when using ...memory[1] to derive a reference
        to be passed to generated code. }
      dynamic_memory OF code_generator CREATE
         (4 + 3 * DYNAMICUSAGE stack_allocator OF code_generator);
      static_memory OF code_generator CREATE
         (4 + 3 * STATICUSAGE stack_allocator OF code_generator);

       "Stack allocator should be clear at end ca."
          ASSERT  (CLEARED stack_allocator OF code_generator);
       "All jumps should be resolved at end ca."
          ASSERT  (CLEARED jump_backpatch_list OF code_generator);
       "All repeats should be ended at end ca."
          ASSERT  (CLEARED repeat_stack OF code_generator);
       "All calls and callinsts should be resolved at end ca."
          ASSERT (CLEARED named_code_backpatch_list OF code_generator);
       "End ca should be unreachable."
          ASSERT NOT reachable OF code_generator;
          { The generate halt above should guarantee this anyway. }

      { I assume that only one item of named code and no items of named
        data will be introduced in the calls array.
        Apart from the removal of a single named code item I make no action
        to remove items from the relevant lists when a new calls array
        arrives. }

      machangeflt(simfault)

   END;

PROC cg setup space = (BYTENUMBER size, FLTPROC flt) WORD:

   { Return a pointer to an area of memory to be used as the global
     memory.  The code generator uses a single longword just before the
     the global pointer to store the stack pointer for the halt instruction.
     Hence the addition of "privatespace" before any index into the global
     memory. }

   BEGIN
      spare space := 0;
      machangeflt(flt);
      global_memory OF code_generator CREATE (size + privatespace);
      machangeflt(simfault);
      set caches;
*4    IF interactive THEN
*4       { Enable <CTRL / C> trap.  Errors are silently ignored.  We know that
*4         catch_ctrl_c will fail in at least one case where 'interactive' is
*4         TRUE viz when running from a DCL file.  There is no obvious, sensible
*4         error action to take }
*4       catch_ctrl_c(input_channel, codegen_catch_interrupt,
*4          (STR msg) VOID: SKIP)
*4    FI;
*U    old_int_handler :=
*U              catch_signal(sigint, codegen_catch_interrupt);
      (mem OF global_memory OF code_generator) [1 + privatespace :]
   END;

PROC cg extend space = (BYTENUMBER size, FLTPROC flt) VOID:

   { This extends the area of memory used as the global memory by at least
     "size".  The division by ten to find the minimum extension is rather
     arbitrary, and can be tuned if necessary.
   }
   IF size <= spare space THEN  spare space -:= size
   ELSE
      INT min = (SIZEOF global_memory OF code_generator) % 10;
      INT increment = IF min > size - spare space THEN  min
                      ELSE  size - spare space
                      FI;
      spare space +:= increment - size;
      machangeflt(flt);
      global_memory OF code_generator EXTEND (increment);
      machangeflt(simfault);
      set caches
   FI;

PROC cg poke = (WORD w, OFFSET o) VOID:

   BEGIN
       INT ix = o + privatespace;
       (mem OF global_memory OF code_generator) [1 + ix : ix + UPB w] := w
   END;

PROC cg peek = (INT l, OFFSET o) WORD:
{ NOTE -- This does NOT copy the value -- the result must therefore be
  treated as read only!  I consider this fairly important for efficiency
  of monitoring, so it is worth the need for care.
}
   BEGIN
       INT ix = o + privatespace;
       (mem OF global_memory OF code_generator) [1 + ix : ix + l]
   END;

{ It is useful to have versions of peek and poke which *DO* include the
  'up' direction for the special case of references to integers (ie
  machine words).  We take the opportunity to include the encoding, and
  to make these procedures rather efficient, as well.
}

PROC cg poke int = (INT i, OFFSET o) VOID:
    INTAT (mem OF global_memory OF code_generator) [1 + privatespace + o] := i;

PROC cg peek int = (OFFSET o) INT:
    INTAT (mem OF global_memory OF code_generator) [1 + privatespace + o];

PROC cg simulate = (INT maxtime) STRUCT (INT lasttime, interrupted):

   BEGIN

      REF INT (maxtime ref) := maxtime;

      { Set up our own condition handlers for integer overflows,
        and user interrupts.}

*4    set_condition_handler (codegen_catch_int_error);
*U    PROC VOID (set_condition_handler (codegen_catch_int_error));

      code entry ((mem OF static_memory OF code_generator) [1],
                  (mem OF dynamic_memory OF code_generator) [1],
                  (mem OF global_memory OF code_generator) [1 + privatespace]);

      { Cancel trapping of integer overflow or divide by zero. }

*4    { set_condition_handler (dont_catch_int_error); ********************* }
*U    PROC VOID (set_condition_handler (dont_catch_int_error));

      INT interrupt state = interrupt ref;
      REF INT (interrupt ref) := 0;

      (time ref, interrupt state)

   END;

PROC cg clear interrupts = VOID:

   REF INT (interrupt ref) := 0;

PROC cg closedown = (FLTPROC flt) VOID:

   BEGIN
*4    IF interactive THEN
*4       { dont_trap_break_in ((STR msg) VOID: SKIP) ****************** } SKIP
*4       { Here we would expect to replace the old handler
*4         Unfortunately it appears we are not able to save it
*4         and in any case it is not clear that one exists. }
*4    FI;
*U    PROC VOID (catch_signal(sigint, old_int_handler));
      { Destroy those objects which must be explicitly destroyed. }
      { Destroy those objects which must be explicitly destroyed. }
      DESTROY global_memory OF code_generator;
      DESTROY dynamic_memory OF code_generator;
      DESTROY static_memory OF code_generator;

      { Then free up all other resources by reinitialising. }
      cg initialise ((RVC dummy) VOID: SKIP, 0, flt);
      machangeflt(simfault)
   END

KEEP
cg dump, cg sizes, cg save state, cg restore state,
generate halt, generate add, generate sub, generate mul, generate div,
generate mod, generate neg, generate abs, generate iand, generate ior,
generate shl, generate shr, generate com, generate test, generate eq,
generate neq, generate gt, generate ge, generate lt, generate le, generate and,
generate or, generate not, generate push string, generate pushint,
generate drop,
generate local, generate global, generate store, generate bstring,
generate bstore,
generate itos, generate utos, generate stoi, generate stou,
generate jump, generate jump no, generate label,
generate repeat, generate loop, generate callinst, generate call,
generate enter, generate fanout, generate ret, generate named code,
generate named data, generate param types, generate, cg initialise,
generate end decls, generateca, generate endca, cg setup space,
cg extend space, cg poke, cg poke int, cg peek, cg peek int,
cg simulate, cg clear interrupts, cg closedown, OFFSET, LABEL, label,
codegen_interrupt_handler,
WORD, PARAMS, nilparams, PARAM, unknown, fixed, instanceptr, boolean, integer,
ADDRESS, indirect, AMVERSION,
ALIENINFO, nil alieninfo, alien finder,
initialise action, reinitialise action, evaluate action,
save action, restore action, terminate action
FINISH
