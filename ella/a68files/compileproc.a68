DECS  compileproc  CONTEXT VOID  USE  putstrings, osinterface, basics,
      impmacro, charset, compmodes, messageproc, sidanalyser:

{                   " Id: compileproc.sta,v 1.1 91/10/14 14:26:26 edcad Exp $" }
configinfo A68CONFIG "$Id: compileproc.a68,v 34.2 1995/03/29 13:03:21 ella Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1984

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

            Taken from :ellasystem.normcompile(107) based on dct-compile(103)
            incorporating macro checks (via ICHECK in IL)
22:08:84  DJS modification to FNs made permanent (1906)
05:02:85  REFORM, CASE disjointness, operator priorities, multiple joins
            and a few bug corrections.
            Procedures moved around because of compiler block limit.
10:06:85  Tidy up of the use of capital letters in error messages.
            BUG20. FNSETs were handled wrong in DELAY and REFORM.
            BUG23. corrected scoping test in PROC checkequals for identical
            external and internal types.
02:09:85  BUG26. new proc "namefaultp" for ambiguous error messages.
            IDs have been extended.
07:10:85  Extra unnecessary parameter removed from PROC indexio.
            BUG27. "/" added in cpindex in PROC outctype.
            BUG28. You need to use MAKE to make a function-set.
08:11:85  Reader changed to read - and + as noncombining symbols if they are
            followed by a digit.
            Restriction on negative ELLA integers removed.
22:11:85  1906 removed
26:11:85  CR 072.   Consequential error messages removed in <sind>, <srange>,
                      <sunn> and <dop>.  EVW
18:03:86  Fault not handled properly in joininputs and <rck>
16:04:86  Bug 179.  corrections to PROC merge types.
23:04:86  Bug 167.  "You cant use a visible space in a symbolic name"
23:04:86  Bug 180.  <conc> integer checks incorrectly output.
20:03:86  CR 250.   attcall and attprim added for attribute hooks. EVW
06:10:86  CR 180.   Sequences.  EVW
            CR 225.   trim and indexing error messages.  EVW
            CR 258.   trimming of structures which are not coerced to rows.  EVW
            CR 299.   remove LET (bool: a b) -> c.  EVW
14:11:86  CR 170.   Maximum negative integer:-  PROC outint changed (uses
                      putstrings). PROC shortenandtest replaces overflow checks.
                      Reader delivers UNION (INT, MAXINT) for ints which is
                      reduced to INT in PROC simplify. MAXINT = maxint plus one.
                      Reader tidied - exp and strings after "r" removed.  EVW
27:01:87  CR 205.   MAKE [n] and FNSET [n] removed multiple join actions. EVW
            CR 130.   FNSET indexing and IO.
            CR 157.   allow trims within multiple JOINs.
09:02:87  CR 239.   Nested BEGIN...ENDs - completeness of JOINs now
                      PROC check_joins.  add vthen and seqthen,
                      also output locsind at id declarations.  EVW
            CR 408.   allow skipping over THEN or ELSE arms in assembler
            CR 161.   conditional IO statements.
14:05:87  CR 295.   Action <fin> now jumps right out (rather than to end of
                      compile_fn),
            CR 475.   flt procedure added to analyser to test end of stack. DCT
21:05:87  CR 135.   SQRT, ABS, MOD added.  MGH
02:06:87  CR 160.   PROC containalts and <checknoalts> added, to prevent
                      constant alternatives in DELAYs and RAMs.  EVW
02:06:87  CR 183.   missing "dummy" in PROC loadctype and <case1>.  EVW
02:06:87  CR 409.   PROC inexttypes wrong if no external types used.  EVW
04:06:87  CR 226.   Bug in PROC mergetypes for rows with INT sizes.  EVW
04:06:87  CR 291.   BOOL outofdate added to IDINFO and FNINFO, setup by PROC
                      inexttypes, used by PROC samespecid and checkspecfns. EVW
16:06:87  CR 201.   Operator precedence added.  MGH
18:08:87  CR 133.   Allow non ELLA integer output in ARITH.  EVW
19:08:87  CR 167.   fault MOC as the start of a comment.  EVW
26:08:87  CR 129.   Bugs in trimorindex, sttorow, testequals, <salts2>.  EVW
09:09:87  CR 404, CR 400, CR432, Tidying error messages.  EVW
14:09:87  CR 284.   fault recursive functions - REC added to FNUNION.  EVW
21:09:87  Porting changes integrated.  JER
30:09:87  CR 201.   Fix to operator precedence.  MGH
06:10:87  CR 436.   Change of spec if FN changed to MAC or viceversa.  EVW
06:10:87  CR 437.   Allow RAM address to start from any number.  EVW
07:10:87  Fix to porting changes.  Must ensure big CASE clause has ELSE
            part after 77th clause.  JER
21:10:87  CR 201.   R3B030.  error fixed in <checkop>. MGH
23:10:87  R3B040.  Fix maximum negative integer - 1 bug.  JER
23:10:87  CR 553.   ?<type>.  MGH
29:10:87  R3B048.   Operator precedence in user functions.  MGH
03:11:87  R3B055.   Unexpected error if combining symbol and _ in comment. EVW
03:11:87  R3B056.   namefaultp added to <del>, <dck> and <rck>.  EVW
13:11:87  R3B072.   Allow non ELLA integer output in ARITH.  This is CR133
            which got unintegrated at generation 11.  JER
19:11:87  R3B088.   Int error messages and macro parameters.  EVW
07:01:88  R3B116.   Allow inner FN/MAC to have same name as enclosing FN. EVW
18:01:88  R3B104.   Scope bug involving declarations in nested BEGIN_END. EVW
18:01:88  R3B147.   Check OUTPUT statement does not include local types. EVW
25:01:88  IR3013/R3B148. pushvss added to <vnull>.  EVW
28:01:88  IR3006/R3B149. Bug from CR239 + CR250. output 0 before attcall.  EVW
11:02:88            Change check maechanism for DELAYs, RAMs and choosers. EVW
17:02:88  R3B160.   LET name confused with type name in OUTPUT.  EVW
23:02:88  R3B165.   OUTPUT bug.  EVW
26:02:88  R3B168.   Missing param type in <seqcase2>.  EVW
03:03:88            Replace array by REF VECTOR [] REF VECTOR.  EVW
09:09:88  Compiler reorganised to work with PROCSID.  BIOPs, ELLA characters,
            Implicit macros and CONSTs added.  More information to IL.   MGH
11:10:88  Textual form of INTs now passed to IL.  EVW
24:10:88  Use of PROC setidunn corrected for varmults.  EVW
02:11:88  Fix to declinscope for local types in OUTPUT.  EVW
10:11:88  RSRE53 UNCHECKEDINT removes extra checks in trimorindex, srange. EVW
10:11:88  Error corrected in PROC check equals for type checking STRINGs.  MGH
14:11:88  Error checks added in PROC stringrow and PROC isprimchar_ct.  MGH
15:11:88  Extra id added to PROC t1toid for clearer error message. MGH
01:12:88  TYPEVAR handling corrected in PROC loadctype.  EVW
01:12:88  Characters allowed in output of ARITH and RAM enable. MGH
09:12:88  Typing error in range test in PROC checkcharange.  EVW
27:01:89  Add PROC charsubrange to only allow subranges of chars in CASE and
            CONST decs, Ctype := flt in char procs when failure occurs. MGH
30:01:89  R4B070.   PROC checkinsert now uses 'test_index OF error' for
                      syntax error. MGH
27:01:89  R4B079.   Add PROC charsubrange to only allow subranges of chars
                      in CASE and CONST decs. Ctype := flt in char procs when
                      failure occurs. MGH
09:02:89  R4B109.   Error in reading INTTEXT, need to create heap space. MGH
10:02:89  R4B103.   PROC callm, calld error message output added.  MGH
13:02:89  R4B119.   Correction of comment reader to ignore character
                      primes. MGH
16:02:89  R4B133.   <dynindex2> altered to give INTCHECK if lwb or upb are
                      checks. MGH
03:03:89  R4B138.   PROC's hasinnerfntype, dechasfntype added to give error
                      messages when fntypes appear within structures in a
                      fnspec. MGH
06:03:89  R4B191.   FNCALLSTACK altered to stack macro parameter count. MGH
08:11:89  R4B522.   Simplify functionsetsize output after Kfn. MGH
22:11:89  PROC inkeptchar replaced by inkeptid.  EVW
06:02:90  Multiple LETs and CONST macro params added. MGH
06:02:90  Compiler split into compileaction and compileproc due to refmap. MGH
09:02:90  Constants and variables declared which are used for sample and
            timescaling. JIT
29:03:90  Macros can now have function parameters. JIT
27:06:90  Fntypes, multiple joins & makes, named outputs, void.  MGH
16:07:90  Macros can now have macro parameters. JIT
08:08:90  REF added to PROC outstring. EVW
16:10:90  c_type now outputs `type' rather than `int'.  MGH
16:10:90  Changes to JOINUP for replicators.  MGH
27:02:91  R6B21.  PROC containsalts delivers TRUE for CNULLT. EVW
21:03:91  Major change to the way error messages are handled. JIT
24:04:91  (R6B17) Module sidanalyser created to remove side effects.  DCT
30:04:91  PROC rowtype created. JIT
20:05:91  R6B36:  errorrecov not initialised - crash 2nd comp after err.  DCT
17:07:91  R6B59:  PROC checkequals:- TNULL added for simple named outputs. MGH
31:07:91  R6B63:  REFORM bug:- reformcheck local types initialisation. MGH
02:08:91  Extension to macro TYPE parameters. JIT
28:08:91  Updated to version 7 of assembler modes. EVW
04:09:91  R6B68:  PROC check equals takes an extra BOOL parameter. JIT
09:09:91  R6B70:  PROC ctypecheck changed for 2 CNAMED inputs. JIT
23:09:91  R6B72:  IR288. cnullt included in checkstring. EVW
16:10:91  R6B82:  BOOL is_alien added to stop fntype checks in ALIEN. MGH
22:10:91  Alter varmultno to be unique in FN. currentvarmultno added. EVW
31:10:91  R6B88:  PROC arithtype search down all of palts list for assoc. EVW
16:12:91  R6B92:  Initialization of `size' in PROC getreplicate. MGH
21:01:91  Changes made for syntax change of FN/MAC parameters of macros. JIT
19:03:92  Attribute declaration and use added. JIT
23:03:92  Constant string can now be a series of strings. JIT
24:03:92  FNSETs removed. JIT
06:04:92  Initial work for port names done. JIT
15:04:92  UNCHECKEDINT moved to COMPMODES. JIT
12:05:92  R6B104  tidyup of source/sink PROCs, IO of sink now ok. EVW
12:05:92  New scoping rules added. EVW
02:06:92  Void added as basic unit value.  MGH
10:06:92  R6B109  PROC getvarmult altered to handle macro integer sizes. MGH
19:06:92  R6B111  PROC repl_local_make altered ISNT to IS in result. MGH
24:06:92  Procedures added for portnames. MGH
25:06:92  vnameiosink removed from Proc setiotype for IO changes. MGH
23:07:92  R6B124  PROC getvarmult  has jchecks marked off.  MGH
24:07:92  R6B112  PROC merge types  outputs `flt' when syntax error found. MGH
24:07:92  R6B107  PROC trimorindex, type set to flt if int test fails.  MGH
01:10:92  Extended type params - PSTRINGs only need same number of chars now.
                                                                            JIT
02:10:92  PROC charsubrange changed to allow ('a..'c) for 'a|'b|'c. JIT
16:10:92  Error in CTRANS lin 2813, repeated conformity option.  DJS
02:12:92  Extra parameter added to PROCs integer equals and equiv_types. JIT
16:02:93  R6B144  PROC charsubrange no longer allows ('a..'c) for 'a|'c|'b.EVW
17:02:93  Add cindex, ctrim, cattr, cif, cconc and crepl. EVW
23:02:93  OSIF level 1 - arbitary line length input - spec of "input".  DCT
25:02:93  Attribute modes reorganised. EVW
06:07:93  R6B156. corrections to type checking of extended TYPE parameters.EVW
21:07:93  R6B163. outmparams - output 0 for MAC with no params. EVW
02:08:93  R6B165. attrvar now output in outattr. EVW
03:08:93  R6B156. corrections to substtype. EVW
10:08:93  Remove references to stropping. EVW
            R6B171. typo in nextexpl_par. EVW
12:08:93  R6B172. correction to contains_localtype. EVW
            R6B174. explicitparam removed. EVW
06:09:93  R6B176. charsubrange incorrectly passed non-overlapping subranges.EVW
27:09:93  R6B185. remove conseq errors by setting fndec to default value. EVW
30:09:93  R6B186. containssort can have unkown position for CCOND. EVW
04:10:93  R6B188. exta call of simplify_ctype after ctypetrim. EVW
18:10:93  R6B192. remove JOININST and JOINCASE. EVW
25:10:93  R6B200. correction of ALIEN macparams. EVW
14:06:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number  31.136 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT

{{  OUTPUT CONTROL OF SOURCE/SINK PRINT   }}

    BOOL source_sink_out = FALSE;

    RVC  textbuff:= LOC VECTOR [512] CHAR;  { maximum buffer size on VMS }
    textbuff[1]:= " ";
    INT  j;
    INT  tind,  textend;
    ID  compsymb;
    INT  compsize, comphash;
    ID  ident;
    INT  idsize, idhash;
    VECTOR [linesize] CHAR  string;
    INT  stringsize, strbase, noofchars;
    INT  noflts;
    VECTOR [maxid] CHAR  ident1, compsymb1;
    REF NAMESTACK nonames = NIL;
    REF NAMESTACK namestack;
    REF NAMESTACK paramnamestack;

    REF STRINGLIST nilstringlist = NIL;
    REF STRINGLIST strings;
    REF STRINGLIST classnames;
    REF REF STRINGLIST nextstring;
    ID atid;
    ATTR attr;
    REF ATTRSTR attrstr := NIL;
    REF REF ATTRSTR nextattr := attrstr;

    PROC (INT, VECSTR) VOID  abort1;
    BOOL  moreinput;
    BOOL  nofltmess;
    CHAR charval;
    BOOL  syntaxerror;
    INT  errorrecov;

    INT  rcnewline  = 50,
         rcident    = 51,
         rcequals   = 52,
         rcmatchcom = 67,
         calllookup = 99;
    BOOL incom;
    UNION(INT, REF INTTEXT, REF MAXINT)  ivread;
    HEAP MAXINT maxintplusone;
    INT  iv;
    INT  bold = 6,
         letter      = 3,
         digit       = 4,
         visiblespace = 9,
         prime       = 10;

    INT t1, sfnno;
    INT ctypeno, cfnno, cintno, cctypeno, cattrno;

      TYPE  fp1, fp2;  ID  fp3, fp4;  FNDEC  fp7, fp8;  CTNAME  fp9;
      INTEGER   fp0, fp5, fp6, fpcolon;   CTYPE  fpopen, fpclose;
      ID fpa, fpb;

      BOOL exitcomp;

      REF IDS kids; REF FNS kfns;

{{ ------------------------------------------------------------------------ }}

      HEAP FNDEC fndec_flt :=
        ( HEAP FNINFO := (0, 0, fn_flt, TRUE, FALSE, FALSE, FALSE),
          localdec, 0, FALSE, NIL, 0, NIL, NIL, attrnull, NIL, NIL,
          flt, flt, 0);
      REF FNDEC fndec := fndec_flt;
      REF DDECS decs;
      INT vss, maxvss; BOOL macroparam;
      REF IDS ids; REF FNS fns; BOOL inarith;

      TYPE type; INTEGER integer, integer1;
      INT k; IDINFO idinfo;
      FNCALL paramfncall;

      PORT portinfo;
      REF PORTSTACK portstack;

      BOOL specinput;
      REF DECNOCHECK decnocheck;


      INT which; ID lastop;
      REF INTEGERSTACK makeint;

      REF ST sts;

      REF FNSTACK fnstack; {holds stack of incomplette declarations }
      REF FNCALLSTACK fncallstack;  BOOL errorswitch;
      BOOL macro;
      INT fndecsort;  { outerdec / localdec / macpardec }
      INT macsort;
         { Indicates whether in region of implicit/explicit macro parameters }
      ID id1;
      ID lastcall;

      REF CALTS calts; CTYPE ctype; REF CST cstr;

      REF JOINSTACK joinstack;
      REF JOINVARSTACK joinvarstack;
      REF JOINST joinst, joinvarst;
      REF JOINMULTSTACK joinmultstack;
      JOINUP joinup;
      TYPE jointype;
      BOOL unjoinedfntype = FALSE, joinedfntype = TRUE;

      BOOL ioid, lhsjoin, nooutput, nonunitbody;

      REF STATESTACK currentstate;
      REF SCOPESTACK scopestack;
      REF LASTOPS lastops;
      REF LASTCALLS lastcalls;

      CHAR charval1;
      REF CHARALTS charalts;


      INT delaytype ;
 {{ constint: DELAY(type, int), idelayintcon: IDELAY(type, int) }}
 {{ constint2: DELAY(type,int,int) const2int2: DELAY(type.int,type,int) }}
 {{ const2int: DELAY(type,int,type) | Not yet implemented }}

      INT sampletype, timetype;     { Number of integers supplied by user }
      INT ints1 = 1, ints2 = 2;

      INT errormessage;
      INT scope;
      BOOL macroexpected;

      BOOL intervalok, tfaster;
      REF PALTS palts1;
      REF PALTSTACK paltstack;

      ATTRID attrid; INTID intid; TYPEID typeid; CTYPEID ctypeid;

      REF IDDECS iddecs;
      REF IDINFO prangedec;

      REF SOPSTACK sopstack;

      REF TYPESTACK typestack; REF INTEGERSTACK integerstack;
      REF IDINFOSTACK idinfostack; REF SUCSTACK sucstack;
      REF TYPE rt; TYPE t;

      REF CASESTACK casestack;

      CTNAME ctname; ID fna, fnb;

      REF IDS decids;

      REF VECTOR [] BOOL charcheck;


   REF COMPILEFNSTACK compilefnstack;
   REF COMPILEFNSTACK nilcompilefnstack = NIL;
   REF ST mltype;
   REF REF ST nextmltype;

   REF MULTLETS nilmultlets = NIL;
   REF MULTLETS multlets := nilmultlets;
   REF MULTLETS multiassign := nilmultlets;

{{ PROC compile }}



PROC (VECTOR [] INT) VOID  outints ;
PROC (ID) VOID  outid ;
PROC (REF VECTOR [] CHAR) VOID  outstring ;
PROC VOID  endcomp;
PROC (ID) VOID  modulename; INT  vnno;
PROC INT  nextkept ;
PROC INT  inkeptint ;
PROC ID   inkeptid ;
PROC (ID, ID, CTNAME) VOID  nextimport ;
PROC (CTNAME) BOOL  setcontext ;
PROC (REF RVC, REF INT) BOOL  input ;
PROC (INT, INT, VECSTR) VOID  fltmess ;
PROC (REF VECTOR [] CHAR, BOOL) INT  lookup ;
REF [] STRUCT (INT type, value)  charset ;

PROC proset =( PROC (VECTOR [] INT) VOID  outintsproc,
                  PROC (ID) VOID  outidproc,
                  PROC (REF VECTOR [] CHAR) VOID  outstringproc,
                  PROC VOID  endcompproc,
                  PROC (ID) VOID  modulenameproc,  INT  vnnoproc,
                  PROC INT  nextkeptproc,
                  PROC INT  inkeptintproc,
                  PROC ID   inkeptidproc,
                  PROC (ID, ID, CTNAME) VOID  nextimportproc,
                  PROC (CTNAME) BOOL  setcontextproc,
                  PROC (REF RVC, REF INT) BOOL  inputproc,
                  PROC (INT, INT, VECSTR) VOID  fltmessproc,
                  PROC (REF VECTOR [] CHAR, BOOL) INT  lookupproc,
                  REF [] STRUCT (INT type, value)  charsetproc
                ) VOID:
BEGIN
outints := (outintsproc);
outid := outidproc;
outstring := outstringproc;
endcomp:= endcompproc;
modulename := modulenameproc;  vnno:= vnnoproc;
nextkept := nextkeptproc;
inkeptint := inkeptintproc;
inkeptid := inkeptidproc;
nextimport := nextimportproc;
setcontext := setcontextproc;
input := inputproc;
fltmess := fltmessproc;
lookup := lookupproc;
charset := HEAP [UPB charsetproc] STRUCT(INT type, value);
FOR i TO UPB charsetproc
DO charset[i] := charsetproc[i] OD
END;


    PROC  syfault = (INT no, VECSTR params) VOID:
    BEGIN
       INT  i:= tind;
       IF nofltmess THEN  GOTO over  FI;
       noflts PLUSAB 12;
       IF noflts > 180  ANDTH  noflts < 193
       THEN  abort1(198, nullmsg CO"compilation abandoned - too many errors"CO)
       FI;
       WHILE i > 0 ANDTH textbuff[i] = " "  DO  i MINUSAB 1  OD;
       fltmess(i, no, params);
over:  SKIP
    END;



    PROC  fault = (INT no, VECSTR params) VOID:
    ( ( NOT syntaxerror | syfault(no, params) ) );

    PROC abort = (INT no, VECSTR params) VOID:
    BEGIN
       IF no > 0 OREL UPB params > 0 THEN  syfault(no, params)  FI;
       textend MINUSAB 1;
       noflts PLUSAB 12;
       TO  10  WHILE  moreinput  DO  moreinput:= input(textbuff, textend)  OD;
       endcomp
    END;

    PROC nofault = (INT no, VECSTR params) VOID: fltmess(0, no, params);

PROC starter = VOID:
BEGIN
    FORALL i IN textbuff DO i := " " OD;
    FORALL i IN string DO i := " " OD;
    FORALL i IN ident1 DO i := " " OD;
    FORALL i IN compsymb1 DO i := " " OD;
    compsymb := nullid;
    ident := nullid;
    textend:= 1;
    tind:= 0;
    idhash:= 1;
    stringsize:= 1;
    noflts:= - 1;
    ctypeno:= 0;
    cfnno:= 0;
    cintno:= 0;
    cctypeno:= 0;
    cattrno := 0;
    iv := 0;
    compsize :=0;
    comphash :=0;
    strbase :=0;
    noofchars :=0;
    t1 := 0;
    sfnno := 0;
    moreinput:= TRUE;
    nofltmess:= FALSE;
    syntaxerror:= FALSE;
    errorrecov := 0;
    incom:= FALSE;
    exitcomp := FALSE;
    charcheck := HEAP VECTOR [UPB charset] BOOL;
    kids:= NIL;
    kfns:= NIL;
    ids := nilids;
    fns := nilfns;
    namestack := nonames;
    paramnamestack := nonames;
    attr := attrnull;
    attrstr := nilattrstr;
    nextattr := attrstr;
    classnames := nilstringlist;
    abort1:= abort;
    sopstack:= NIL;
    compilefnstack := nilcompilefnstack;
    typestack := NIL;
    integerstack := NIL;
    idinfostack := NIL;
    sucstack := NIL;
    makeint := nilintegerstack;
    scope := 0
END;

    PROC primread = INT:
    BEGIN
       CHAR  c;
       INT  i;
       BOOL  radixgiven:= FALSE, textneeded:= FALSE;
       INT  ans,  radix:= 10;
       BOOL overflow := FALSE;   INT lastvalue;
       INT  plus = 901,  minus = 902;
       INT  stringonly  = 1,
            space       = 2,
{{  letter and digit moved because of string definition  }}
            stringquote = 5,
            simple      = 20,
            compstart   = 21,
            compound    = 22,
            compterm    = 23;

l:     CASE  c:= textbuff[tind PLUSAB 1];
             type OF charset[ABS c]     IN
       CO  ...stringonly...  CO
       (  syfault(199, nullmsg CO"character not recognised"CO);
          syntaxerror:= TRUE;
          ans:= recovertok + 100
       ) ,
       CO  ...space...  CO
          IF tind >= textend
          THEN  ans:= rcnewline
          ELSE  GOTO l
          FI ,
       CO  ...letter...  CO
       (  idsize:= 0;
          idhash:= 0;
l1:       IF idsize /= maxid
          THEN  ident1[idsize PLUSAB 1]:= c;
                idhash PLUSAB ABS c
          FI;
          c:= textbuff[tind PLUSAB 1];
          i:= type OF charset[ABS c];
          IF i = letter OREL i = digit OREL i = visiblespace THEN  GOTO l1  FI;
          tind MINUSAB 1;
          ans:= rcident;
          ident:= HEAP VECTOR [idsize] CHAR := ident1[ :idsize];
          idhash:= ABS (BIN idhash  AND  BIN 63) + 1
       ) ,
       CO  ...digit...  CO
       (
          BOOL maxintplusone pending := FALSE;
          stringsize:= 0;
l1:       iv:= 0;
          lastvalue := -1;
          IF "020400080a00000g"[radix] = "0"
          THEN  fault(200, nullmsg CO"illegal radix"CO)
          FI;
          DO
               i:= value OF charset[ABS c];
               IF i < radix  ANDTH  i >= 0
               THEN  string[stringsize PLUSAB 1] := c;
                     IF iv = 0 ANDTH lastvalue = 0 THEN textneeded := TRUE FI;
                     lastvalue := iv;
                     IF iv > largeint
                     THEN
                        IF iv > maxint OVER radix
                        THEN                   { possible overflow }
                           IF (-iv = minint OVER radix) ANDTH (i = 0)
                           THEN                { got a -1 }
                              maxintplusone pending := TRUE
                           ELSE
                              fault(201, nullmsg CO"integer too large"CO);
                              maxintplusone pending := FALSE
                           FI;
                           iv := maxint
                        ELSE
                           iv TIMESAB radix;
                           IF iv > maxint - i
                           THEN                { possible overflow }
                              IF iv - 1 = maxint - i
                              THEN             { got a -1 }
                                 maxintplusone pending := TRUE
                              ELSE
                                 fault(201, nullmsg CO"integer too large"CO);
                                 maxintplusone pending := FALSE
                              FI;
                              iv := maxint
                           ELSE
                              iv +:= i
                           FI
                        FI
                     ELSE  iv:= iv * radix  +  i
                     FI
               ELSE  GOTO out
               FI;
               c:= textbuff[tind PLUSAB 1]
            OD;
out:      IF i = 27  CO ...r...  CO  ANDTH  NOT radixgiven
          THEN  IF iv > 16  OREL  iv < 2
                THEN  iv:= 16;
                      fault(200, nullmsg CO"illegal radix"CO)
                FI;
                string[stringsize PLUSAB 1] := c;
                radixgiven:= textneeded:= TRUE;
                radix:= iv;
                WHILE
                   c:= textbuff[tind PLUSAB 1];
                   value OF charset[ABS c] = 37
                   DO  string[stringsize PLUSAB 1] := c;
                       textneeded := TRUE;
                       IF tind = textend THEN  lastvalue := -1; GOTO out  FI
                   OD;
                GOTO l1
          ELSE  tind MINUSAB 1;
                ans:= ( radixgiven | rintdentok | intdentok )  + 100
          FI;
          IF radixgiven ANDTH  lastvalue = -1
          THEN  syfault(202, nullmsg CO"illegal symbol after r"CO);
                syntaxerror:= TRUE;
                ans:= recovertok + 100
          FI;
          ivread := IF maxintplusone pending
                    THEN text OF maxintplusone :=
                         IF textneeded
                            THEN ID stringtext
                                       := HEAP VECTOR [stringsize] CHAR
                                               := string[1:stringsize];
                                 stringtext
                            ELSE nullid
                         FI;
                         maxintplusone
                    ELIF textneeded
                    THEN ID stringtext := HEAP VECTOR [stringsize] CHAR
                                       := string[1:stringsize];
                         HEAP INTTEXT := (iv, stringtext)
                    ELSE iv
                    FI
       ) ,
       CO  ...stringquote...  CO
       (  stringsize:= 0;
          DO  IF tind = textend
              THEN  syfault(203, nullmsg CO"string goes over newline"CO);
                    syntaxerror:= TRUE;
                    ans:= recovertok + 100;
                    GOTO  out1
              ELSE  c:= textbuff[tind PLUSAB 1];
                    IF type OF charset[ABS c] = stringquote
                    THEN  c:= textbuff[tind PLUSAB 1];
                          ( type OF charset[ABS c] /= stringquote | GOTO  out )
                    FI;
                    string[stringsize PLUSAB 1]:= c
              FI
          OD;
out:      ans:= stringtok + 100;
out1:     tind MINUSAB 1
       ) ,
       CO  ...bold...  CO
       (  compsize:= comphash:= 0;
          WHILE
             i:= type OF charset[ABS c];
             i = bold OREL i = digit OREL i = visiblespace
                  DO
                  IF compsize /= maxid
                  THEN  i:= ABS c;
{                        ( i = bold | -1 - value OF charset[ABS c] | ABS c );}
                        comphash PLUSAB i;
                        compsymb1[compsize PLUSAB 1]:= REPR i
                  FI;
                  c:= textbuff[tind PLUSAB 1]
                OD;
          comphash:= ABS (BIN comphash  AND  BIN 63) + 1;
          ans:= lookup(compsymb1[1:compsize], TRUE);
          compsymb:= HEAP VECTOR [compsize] CHAR := compsymb1[ :compsize];
          tind MINUSAB 1
       ) ,
       CO  ...openstrop...  CO
          SKIP ,
       CO  ...matchstrop... CO
          SKIP ,
       CO  ..visiblespace.. CO
       (  syfault(CO"You can t start a word with a visible space"CO
                  131, nullmsg);
          syntaxerror := TRUE;
          ans := recovertok + 100
       ),
       CO  ...prime...  CO
       (   charval := textbuff[tind PLUSAB 1];
           IF charval = " " THEN tind MINUSAB 1 FI;
           IF (value OF charset[ABS charval]) = 100
             THEN syfault(150, nullmsg
                          CO"you must have a printable char here"CO)
                ELIF (ABS charval) = 9
                  THEN syfault(151, nullmsg CO"Tab cannot be used here"CO)
           FI;
           ans := chartok + 100
       )
       OUT
       CO  ...simple or compound...  CO
       (  compsize:= comphash:= 0;
          i:= type OF charset[ABS c];
l1:       IF compsize /= maxid
          THEN  compsymb1[compsize PLUSAB 1]:= c;
                comphash PLUSAB ABS c
          ELSE  overflow := TRUE
          FI;
          IF i /= compterm  ANDTH  i /= simple
          THEN  lastvalue := value OF charset[ABS c];
                c:= textbuff[tind PLUSAB 1];
                i:= type OF charset[ABS c];
                IF (lastvalue = plus OREL lastvalue = minus) ANDTH i = digit
                THEN  IF compsize > 1
                      THEN (NOT overflow | compsize MINUSAB 1);
                           tind MINUSAB 2
                      ELSE tind MINUSAB 1
                      FI
                ELIF i = compound  OREL  i = compterm
                THEN  GOTO l1
                ELIF i = visible space
                THEN  IF NOT incom
                      THEN syfault(8, nullmsg
                         CO"You cant use a visiblespace in a symbolic name" CO);
                           syntaxerror := TRUE;
                           ans := recovertok + 100
                      ELSE ans := illegaltok
                      FI
                ELSE  tind MINUSAB 1
                FI
          FI;
          comphash:= ABS (BIN comphash  AND  BIN 63) + 1;
          compsymb:= HEAP VECTOR [compsize] CHAR := compsymb1[ :compsize];
          IF compsize /= 1  OREL
               (ans:= value OF charset[ABS compsymb1[1]]) = calllookup
          THEN  ans:= lookup(compsymb1[1:compsize], FALSE)
          FI
       )
       ESAC;

       ans
    END;

    PROC readcom = (INT commenttype) BOOL:   CO  ...ok...  CO
    BEGIN
       INT  i, j;
       BOOL  ans:= TRUE;
       IF commenttype > rcmatchcom
       THEN syfault(205, nullmsg CO"You can't start a comment with MOC"CO);
            syntaxerror:= TRUE;
            ans:= FALSE;
            GOTO out
       FI;
l:     WHILE
          IF tind = textend
          THEN  IF commenttype < rcmatchcom
                THEN  syfault(206, nullmsg
                   CO"this sort of comment can't go over more than one line"CO);
                      syntaxerror:= TRUE;
                      tind MINUSAB 1;
                      ans:= FALSE;
                      GOTO out
                FI;
                IF NOT input(textbuff, textend MINUSAB 1)
                THEN  moreinput:= FALSE;
                    abort(207, nullmsg
                           CO"reached end of file while still inside comment"CO)
                FI;
                tind:= 0;
                textbuff[textend PLUSAB 1]:= " "
          FI;
          i:= type OF charset[ABS textbuff[tind PLUSAB 1]];
          i < bold OREL i = visiblespace  OREL i = prime
          DO  SKIP  OD;
       i:= -1;
       tind MINUSAB 1;
       j:= primread;
       IF j < rcmatchcom  OREL  j >= 100
       THEN  IF commenttype /= j
             THEN  (i >= 0 | tind:= i );
                   GOTO l
             FI
       ELIF j /= commenttype + 1
       THEN  IF ODD j
             THEN  ( readcom(j) | GOTO l | syntaxerror:= TRUE;  ans:= FALSE )
             ELSE  syfault(208, nullmsg
                           CO"wrong sort of terminator for comment"CO);
                   syntaxerror:= TRUE;
                   ans:= FALSE
             FI
       FI;
out:   ans
    END;



    PROC  read = VOID:
    BEGIN
       INT  r;
       IF noflts > 0 THEN  noflts MINUSAB 1  FI;
l:     r:= IF moreinput THEN primread ELSE rcnewline FI;
       t1:= CASE  r - rcnewline + 1  IN
            CO  ...newline... CO
               IF tind := 0;
                  input(textbuff, textend MINUSAB 1)
               THEN  textbuff[textend PLUSAB 1]:= " ";
                     GOTO l
               ELSE  moreinput:= FALSE;
                     eoftok
               FI ,
            CO  ...id...  CO
               idtok ,
            CO  ...equals...  CO
               ( sfnno:= 503; equalstok )
            OUT
               IF r >= 700
               THEN  sfnno:= r - 300;
                     IF r=901 OREL r=902
                       THEN pormtok
                       ELIF r=801 OREL r=802
                         THEN tordtok
                         ELSE op2tok
                     FI
               ELIF r >= 400
               THEN  sfnno:= r;
                     op1tok
               ELIF r >= 100
               THEN  r - 100
               ELSE  CO  ...comment...  CO
                     incom:= TRUE;
                     IF readcom(r)
                     THEN  incom:= FALSE;
                           GOTO l
                     ELSE  incom:= FALSE;
                           recovertok
                     FI
               FI
            ESAC
    END;


    PROC inkept = (PROC (ID)IDINFO findid, BOOL export,
                  PROC (IDINFO)REF IDS newextid,
                  PROC (REF FNDEC)REF FNS newextfn)VOID:
           inkept_ext(findid, export, newextid, newextfn, inkeptint, inkeptid,
                   charset, fault);


   PROC findkid = (ID id)IDINFO:
   (  REF IDS i:= kids;
      IDINFO ans:= (0, 0, FALSE, FALSE, TRUE, FALSE, id, notdec);
      WHILE i ISNT nilids
      DO  IF id OF idinfo OF i = id THEN ans:= idinfo OF i; GOTO found FI;
         i:= rest OF i
      OD;
found:ans
   );

   PROC newkid = (IDINFO i)REF IDS:
         ( kids:= HEAP IDS:= (HEAP IDINFO := i, TRUE, attrnull, kids) );
   PROC newkfn = (REF FNDEC f)REF FNS:
         ( kfns:= HEAP FNS:= (f, TRUE, kfns) );

      PROC syfaultp = (INT no, VECTOR [] ERRPARAM params)VOID:
         syfaultp_ext(no, params, syntaxerror, fault);

      PROC faultp = (INT no, VECTOR [] ERRPARAM params)VOID:
      ( IF NOT syntaxerror THEN syfaultp(no, params) FI );

      PROC namefaultp = (INT no, VECTOR [] ERRPARAM params)VOID:
      ( IF NOT syntaxerror  THEN
          syfaultp(no, params);
          IF namestack ISNT nonames
          THEN WHILE namestack ISNT nonames
               DO fp3 := id OF namestack;
                  syfaultp(CO"The two versions of * are different"CO 132, fp3);
                  namestack := rest OF namestack
               OD
          FI
        FI
      );

      PROC t1toid = ID:
      ( IF t1 = eoftok
        THEN HEAP VECTOR [11] CHAR := "end of file"
        ELIF t1 = chartok
        THEN HEAP VECTOR [9] CHAR := "Character"
        ELSE (t1 | ident, HEAP VECTOR [7] CHAR := "Integer",
                          HEAP VECTOR [6] CHAR := "String" | compsymb)
        FI
      );


      PROC syntaxerrmess = (INTERNALS error)VOID:
      (  INT n;
         FOR i TO UPB toks DO
         IF checkinsert(tokno OF toks[i], error) THEN n:= i; GOTO f FI
                                 OD;
         fp3:= t1toid; syfaultp(CO"* wont fit here"CO 1, fp3)
      EXIT
      f:fp3:= t1toid; fp4:= id OF toks[n];
         syfaultp(CO"* wont fit here..  * would"CO 2, (fp3, fp4))
      );

      PROC fltmessage = (IDINFO info) VOID:
      (  fp3 := id OF info;
         CASE (u OF info) IN
         (INTID iid) (CASE (i OF iid) IN
                      (REF INTVAR iv)
                          (faultp(CO"* is a macro parameter."CO 119, fp3) )
                      OUT (faultp(CO"* is a named integer."CO 120, fp3) )
                      ESAC),
         (TYPEID tid) (CASE (t OF tid) IN
                       (REF TYPEVAR tv)
                           (faultp(CO"* is a macro paramter."CO 119, fp3) )
                       OUT (faultp(CO"* is a type name."CO 121, fp3) )
                       ESAC),
         (CTYPEID cid)(faultp(CO"* is a constant name"CO 155, fp3) ),
         (PRIMID pid) (faultp(CO"* is a basic value."CO 130, fp3) ),
         (REF DECIDS did) (IF (origin OF did) = lettok
                       THEN faultp(CO"* is a name defined by LET."CO 122, fp3)
                         ELIF (origin OF did) = maketok
                        THEN faultp(CO"* is a name defined by MAKE."CO 124, fp3)
                          ELSE faultp(CO"* is a formal parameter."CO 123, fp3)
                          FI),
         (ATTRID ad)  (CASE (a OF ad) IN
                      (REF ATTRVAR av)
                           faultp(CO"* is a macro paramter."CO 119, fp3)
                      OUT faultp(CO"* is an attribute name."CO 135, fp3)
                      ESAC ),
         (VARID vid)  (faultp(CO"* is a name defined by VAR."CO 136, fp3) )
         OUT SKIP
         ESAC
      );



      PROC setextint = (INTEGER i)VOID:
      ( CASE i IN
        (REF INTDOP idop) ( setextint(l OF idop); setextint(r OF idop) ),
        (REF INTMOP imop) ( setextint(r OF imop) ),
        (REF INTCHECK ic) ( setextint(integer OF ic);
                            setextint(standard OF ic)
                          ),
        (REF INTVARMULT iv) ( setextint(lwb OF iv); setextint(upb OF iv) ),
        (REF INTCOND icn) ( setextint(cond OF icn);
                            setextint(t OF icn); setextint(f OF icn)
                          ),
        (REF INTDEF idef) ( IF scope OF idinfo OF idef = -1
                               THEN scope OF idinfo OF idef := 0;
                                    intno OF idef := cintno PLUSAB 1
                            FI ;
                            setextint(i OF idef)
                          ),
        (REF IBRACKET ib) setextint(ibracket OF ib)
           OUT SKIP
       ESAC
     );



      PROC setextattr = (ATTR at)VOID:
         CASE at IN
         (REF ATTRDEF ad)
             IF scope OF idinfo OF ad = -1
             THEN scope OF idinfo OF ad := 0;
                  attrno OF ad := cattrno PLUSAB 1;
                  setextattr(attr OF ad)
             FI,
          (REF ATTRSTR as)
             ( REF ATTRSTR ats := as;
               WHILE ats ISNT nilattrstr
                DO setextattr(elem OF ats);  ats := rest OF ats OD
             ),
          (REF ABRACKET ab)  setextattr(abracket OF ab)
          OUT SKIP
          ESAC;

      PROC setexttype = (TYPE t)VOID:
      (  REF PALTS alts; REF ST sts;
         CASE t IN
         (REF PRIMSET p)
            IF scope OF idinfo OF p =-1 THEN
               scope OF idinfo OF p:= 0; typeno OF p:= ctypeno PLUSAB 1;
               CASE u OF p IN
               (PRANGE pr)
                  ((scope OF idinfo OF pr =-1 | scope OF idinfo OF pr:= 0 );
                    setextint(lwb OF pr); setextint(upb OF pr) ),
               (REF PALTS rp)
               (  alts:= rp;
                  WHILE alts ISNT nilpalts
                  DO  IF scope OF idinfo OF alts = -1
                     THEN  scope OF idinfo OF alts:= 0
                     FI;
                     (u OF alts ISNT niltype | setexttype(u OF alts));
                     alts:= rest OF alts
                  OD
               ),
               (PSTRING ps)
                  (scope OF idinfo OF ps =-1 | scope OF idinfo OF ps:= 0 )
             { OUT no other fields }
               ESAC
            FI,
         (REF NAMED n)
            IF scope OF idinfo OF n =-1 THEN
               scope OF idinfo OF n:= 0;
               typeno OF n:= ctypeno PLUSAB 1; setexttype(t OF n)
            FI,
         (REF ST st)
         (  sts:= st;
            WHILE sts ISNT nilst
            DO setexttype(t OF sts); sts:= rest OF sts OD

         ),
         (REF FNTYPE f)
         (  setexttype(from OF f); setexttype(to OF f) ),
         (REF ROW r)
            ( setextint(size OF r); setexttype(t OF r)),
         (REF TBRACKET tb) setexttype(tbracket OF tb),
         (REF TSTRING ts) (setextint(size OF ts); setexttype(tstring OF ts))
         OUT SKIP
         ESAC
      );

      PROC setextctype = (CTYPE ct) VOID:
      (  CASE ct IN
         (REF CNAMED cn)
            IF scope OF idinfo OF cn = -1 THEN
               scope OF idinfo OF cn:= 0;
               ctypeno OF cn:= cctypeno PLUSAB 1;  setextctype(ct OF cn)
            FI,
         (REF CPRANGE cpr)
            ( setexttype(t OF cpr);
              setextint(lwb OF cpr);  setextint(upb OF cpr)
            ),
         (REF CPINDEX cpi)
            ( setexttype(t OF cpi);  setextint(index OF cpi) ),
         (REF PRIMID pd)
            ( setexttype(type OF pd) ),
         (REF CUNN cu)
            ( setexttype(type OF p OF cu);  setextctype(ct OF cu) ),
         (REF CROW cr)
            ( setextctype(ct OF cr);  setextint(size OF cr) ),
         (REF CST cs)
            ( REF CST cst := cs;
              WHILE cst ISNT nilcst
              DO setextctype(cst OF cst);  cst := rest OF cst OD
            ),
         (REF CALTS ca)
            ( REF CALTS calts := ca;
              WHILE calts ISNT nilcalts
              DO setextctype(calt OF calts);  calts := rest OF calts OD
            ),
         (REF CINDEX ci)
            ( setextctype(ct OF ci);  setextint(index OF ci) ),
         (REF CTRIM cti)
            ( setextctype(ct OF cti);
              setextint(lwb OF cti);  setextint(upb OF cti)
            ),
         (REF CCOND cd)
            ( setextint(test OF cd);
              setextctype(then OF cd); setextctype(else OF cd)
            ),
         (REF CREPL cp)
            ( REF INTVARMULT repl = get_intvarmult(ids OF cp);
              setextint(lwb OF repl);  setextint(upb OF repl);
              setextctype(ct OF cp)
            ),
         (REF CCONC cnc)
            ( setextctype(left OF cnc);  setextctype(right OF cnc) ),
         (REF CATTR ca)       ( setextctype(ct OF ca); setextattr(attr OF ca) ),
         (REF CNULLT ct)      setexttype(ct OF ct),
         (REF CBRACKET cb)    setextctype(cbracket OF cb),
         (REF CQUERY cq)      setexttype(querytype OF cq),
         (REF CPSTRING cg)    ( setextint(size OF cg);  setextctype(ct OF cg) ),
         (REF CPCHAR cc)      setexttype(t OF cc),
         (REF CPCHRANGE crg)  setexttype(t OF crg),
         (REF CTYPEVAR cv)    setexttype(t OF cv),
         (CVOID) SKIP
         OUT SKIP
         ESAC
      );

      PROC setextddecs = (REF DDECS d) VOID:
      ( REF DDECS dd := d;
        WHILE dd ISNT nildecs
        DO setexttype(t OF dd); dd := rest OF dd OD
      );

      PROC outextints = (REF IDS ids)VOID:
      (  REF IDS i:= ids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0 THEN
               CASE u OF idinfo OF i IN
               (INTID ii) ( outid(id OF idinfo OF i);
                            CASE GETINTEGER(i OF ii) IN
                              (REF INTDEF idef)outints((dummy, intno OF idef,
                                                       vnno OF idinfo OF i))
                              OUT fault(0, "outextints")
                            ESAC
                          )
               OUT SKIP
               ESAC
            FI;
            i:= rest OF i
         OD;
         outid(nullid)
      );

      PROC outextattrs = (REF IDS ids)VOID:
      (  REF IDS i:= ids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0 THEN
               CASE u OF idinfo OF i IN
               (ATTRID aid)
                    ( outid(id OF idinfo OF i);
                      CASE a OF aid IN
                      (REF ATTRDEF  ad)
                           outints((dummy, attrno OF ad, vnno OF idinfo OF i))
                      OUT fault(0, "outextattr")
                      ESAC
                    )
               OUT SKIP
               ESAC
            FI;
            i:= rest OF i
         OD;
         outid(nullid)
      );

      PROC outextctypes = (REF IDS ids)VOID:
      (  REF IDS i:= ids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0 THEN
               CASE u OF idinfo OF i IN
               (CTYPEID ci)
                  ( outid(id OF idinfo OF i);
                    CASE ct OF ci IN
                    (REF CNAMED cn)
                        outints((dummy, ctypeno OF cn, vnno OF idinfo OF i))
                    OUT fault(0, "outextctypes")
                    ESAC
                  )
               OUT SKIP
               ESAC
            FI;
            i:= rest OF i
         OD;
         outid(nullid)
      );

      PROC unscopeids = (REF IDS ids)VOID:
      (  REF IDS i:= ids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0 THEN
               scope OF idinfo OF i:=-1;
               CASE u OF idinfo OF i IN
                 (CTYPEID c) CASE ct OF c IN
                                (REF CNAMED cn)  ctypeno OF cn:=-1
                                 OUT SKIP
                             ESAC,
                 (TYPEID t)  CASE GETTYPE(t OF t) IN
                                (REF PRIMSET p) typeno OF p:=-1,
                                (REF NAMED n)   typeno OF n:=-1
                                 OUT  SKIP
                               ESAC,
                  (INTID i)  CASE GETINTEGER(i OF i) IN
                                (REF INTDEF idef) intno OF idef := -1
                                 OUT SKIP
                             ESAC,
                  (ATTRID a) CASE a OF a IN
                                (REF ATTRDEF adef) attrno OF adef := -1
                                 OUT SKIP
                             ESAC
               OUT SKIP
               ESAC
            FI;
            i:= rest OF i
         OD;
         cctypeno:= 0; ctypeno:= 0; cintno := 0; cattrno := 0
      );

      PROC setidunn = (REF IDINFO i, IDUNION u) VOID:
      (  CASE u OF i IN
         (REC r) u OF i:= u
         OUT SKIP
         ESAC
      );

      PROC insert_idinfo = (REF IDINFO i, REF REF SCOPESTACK scopestack,
                                          REF REF IDS idlist) VOID:
      { used to insert INT/TYPE parameters of FN macro parameters in to }
      { correct place in ids list - so they remain in scope             }
      { e.g MAC M {FN F = ([INTn]TYPE ty) -> ()} ....                   }
      (  REF REF IDS iptr := idlist;
         WHILE (rest OF iptr ISNT nilids) ANDTH
               ((scopestack IS nilscope) OREL
                (REF IDS (ids OF scopestack) ISNT (rest OF iptr)))
         DO  iptr := rest OF iptr OD;
         REF REF IDS (rest OF iptr)
               := HEAP IDS := (i, TRUE, attrnull, rest OF iptr);
         ids OF scopestack := rest OF iptr
      );

      PROC loadint = (INTEGER a, BOOL index) BOOL: CO integer contained check CO
      (  BOOL chkd:= FALSE;
         CASE a IN
         (INT i)
            outints((iconst, i)) ,
         (REF INTTEXT it)
         (  outints((iconsttext, int OF it));  outid(text OF it) ),
         (REF MAXINT m) fault(0, "maxint in loadint"),
         (REF INTCHECK ic)
         (  outints((icheck, test OF ic));  loadint(integer OF ic, index);
            loadint(standard OF ic, index);
            chkd:= TRUE
         ),
         (IPARAM ip)
            outints((iparam, p OF ip)) ,
         (REF INTDOP op)
         (  outints((idop, opno OF op));
            (loadint(l OF op, index) | chkd:= TRUE);
            (loadint(r OF op, index) | chkd:= TRUE)
         ),
         (REF INTMOP mop)
         (  outints((imop, opno OF mop));
            (loadint(r OF mop, index) | chkd:= TRUE) ),
         (REF INTVAR e)  IF index
                         THEN outints((iname, index OF im OF e))
                         ELSE outints((idef, xno OF im OF e))
                         FI,
         (REF INTVARMULT ivm) outints((ivarmult, varmultno OF ivm)),
         (REF INTCOND ic)
         (  outints(icond);  (loadint(cond OF ic, index) | chkd:= TRUE);
            (loadint(t OF ic, index) | chkd:= TRUE);
            (loadint(f OF ic, index) | chkd:= TRUE)
         ),
         (REF INTDEF indef) outints((idef, intno OF indef)),
         (REF IBRACKET ib) (outints(ibracket); loadint(ibracket OF ib, index)),
         (INULL in) outints(inull)
         OUT SKIP
         ESAC;
         chkd
      );

      PROC loadtype = (TYPE  t, BOOL expand, all, index) VOID:

      (PROC outprimset = (TYPE t, BOOL all) VOID:
       CASE t IN
       (REF PRIMSET p)
         (CASE u OF p IN
          (PRANGE pr)
          ( outints(prange);
            IF all THEN outid(id OF idinfo OF pr) ELSE outid(nullid) FI;
            BOOL b1 = loadint(lwb OF pr, index),
                 b2 = loadint(upb OF pr, index);
            IF b1 OREL b2
            THEN u OF p := PRANGE(idinfo OF pr, UNCHECKEDINT(lwb OF pr),
                                  UNCHECKEDINT(upb OF pr))
            FI
          ),
          (REF PALTS pa)
          ( outints(pidalts);
            REF PALTS palts1 := pa;
            WHILE palts1 ISNT nilpalts
            DO (u OF palts1 IS niltype | outints(tnull) |
                                    loadtype(u OF palts1, FALSE, FALSE, index));
               IF all THEN outid(id OF idinfo OF palts1) ELSE outid(nullid) FI;
               palts1:= rest OF palts1
            OD;
            outints(end)
          ),
          (PSTRING ps)
          ( outints(pstring);
            IF all THEN outid(id OF idinfo OF ps) ELSE outid(nullid) FI;
            INT altsno := 0;
            FORALL i IN (charcheck OF ps)
            DO IF i THEN altsno PLUSAB 1 FI OD;
            outints((dummy, altsno));
            REF CHARALTS chalts := charalts OF ps;
            WHILE chalts ISNT nilcharalts
            DO CASE alts OF chalts IN
                  (CHAR ch) (outints(pchar);
                             outid(HEAP VECTOR [1] CHAR := ch)),
                  (CHARRANGE cr) (outints(pcharrange);
                                  outid(HEAP VECTOR [1] CHAR := lwchar OF cr);
                                  outid(HEAP VECTOR [1] CHAR := upchar OF cr) )
               ESAC;
               chalts := rest OF chalts
            OD;
            outints(end)
          )
          OUT fault(0, "<outprimset>1")
          ESAC
         )
       OUT fault(0, "<outprimset>2")
       ESAC;

         REF ST st;
         CASE t IN
         (REF PRIMSET p) IF expand
                         THEN outprimset(p, all)
                         ELSE outints((tnamed, typeno OF p))
                         FI,
         (REF NAMED n) IF expand
                       THEN loadtype(t OF n, FALSE, FALSE, index)
                       ELSE outints((tnamed, typeno OF n))
                       FI,
         (REF ST s)
         (  st:= s; outints(tst);
            WHILE st ISNT nilst
            DO loadtype(t OF st, FALSE, FALSE, index); st:= rest OF st OD;
            outints(end)
         ),
         (REF TYPEVAR t1) IF index
                          THEN outints((tparam, index OF tm OF t1))
                          ELSE outints((tnamed, xno OF tm OF t1))
                          FI,
         (REF ROW r)
         (  outints(trow);
            IF loadint(size OF r, index)
            THEN size OF r:= UNCHECKEDINT size OF r
            FI;
            loadtype(t OF r, FALSE, FALSE, index)
         ),
         (REF FNTYPE f)
         (  outints(tfn);
            loadtype(from OF f, FALSE, FALSE, index);
            loadtype(to OF f, FALSE, FALSE, index) ),
         (REF TBRACKET tb) (outints(tbracket);
                            loadtype(tbracket OF tb, FALSE, FALSE, index)),
         (REF TSTRING ts)
            (outints(tstring);
             IF loadint(size OF ts, index)
             THEN size OF ts:= UNCHECKEDINT size OF ts
             FI;
             loadtype(tstring OF ts, FALSE, FALSE, index)
            ),
         (TNULL tn) outints(tnull),
         (TVOID tv) outints(tvoid),
         (FLT f) SKIP
         OUT  fault(0, "loadtype")
         ESAC
      );

      PROC outexttypes = (REF IDS ids)VOID:
      (  REF IDS i:= ids;
         REF IDS etids := nilids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0
             THEN CASE u OF idinfo OF i IN
                  (TYPEID t) etids := HEAP IDS
                                   := (idinfo OF i, TRUE, attrnull, etids)
                  OUT SKIP
                  ESAC
             FI;
             i := rest OF i
         OD;
         i := etids;
         WHILE i ISNT nilids
         DO  IF scope OF idinfo OF i = 0 THEN
               CASE u OF idinfo OF i IN
               (TYPEID t)
                 (TYPE exttype = GETTYPE(t OF t);
                  CASE exttype IN
                  (REF PRIMSET p)
                  (  outid(id OF idinfo OF p);
                     outints((dummy, typeno OF p, vnno OF idinfo OF i));
                     loadtype(exttype, TRUE, TRUE, FALSE);
                     outints(zero)
                  ),
                  (REF NAMED n)
                  (  outid(id OF idinfo OF n);
                     outints((dummy, typeno OF n, vnno OF idinfo OF i));
                     loadtype(exttype, TRUE, TRUE, FALSE);
                     outints(zero)
                  ),
                  (FLT f)
                     SKIP
                  OUT
                     fault(0, "outexttypes")
                  ESAC)
               OUT SKIP
               ESAC
            FI;
            i:= rest OF i
         OD;
         outid(nullid)
      );


      PROC outstringlist = (REF STRINGLIST strings) VOID:
      (  REF STRINGLIST data := strings;
         REF STRINGLIST backwards := nilstringlist;
         INT count := 0;
         WHILE data ISNT nilstringlist
         DO count PLUSAB 1;
            backwards := HEAP STRINGLIST := (id OF data, backwards);
            data := rest OF data
         OD;
         outints((dummy, count));
         data := backwards;
         WHILE data ISNT nilstringlist
         DO outid(id OF data);
            data := rest OF data
         OD
      );

      PROC outattrs = (ATTR attr) VOID:
      (  CASE attr IN
         (ATTRNULL)     outints(attnull),
         (REF ATTRDEF an)   outints((attid, attrno OF an)),
         (REF ATTRVAR av)   outints((attid, xno OF am OF av)),
         (REF ATTRDATA ad)  (outints(attdata);
                             outid(classname OF ad);
                             outstringlist(data OF ad)
                            ),
         (REF ATTRSTR as)   (outints(attstr);
                             REF ATTRSTR ats := as;
                             WHILE ats ISNT nilattrstr
                              DO outattrs(elem OF ats); ats := rest OF ats OD;
                             outints(zero)
                            ),
         (REF ABRACKET ab)  (outints(attbracket);
                             outattrs(abracket OF ab)
                            )
         OUT SKIP
         ESAC
      );

      PROC outdecattr = (REF DDECS decs) VOID:
      ( REF DDECS d := decs;
        WHILE d ISNT nildecs
        DO REF IDS ids := ids OF d;
           WHILE ids ISNT nilids
           DO CASE attr OF ids IN
              (ATTRNULL) SKIP
              OUSE u OF idinfo OF ids  IN
              (REF DECIDS d) ( outints((dummy, decno OF d));
                               outattrs(attr OF ids)
                             )
              OUT SKIP
              ESAC;
              ids := rest OF ids
           OD;
           d := rest OF d
       OD;
       outints(zero)
     );

      PROC outddecs = (REF DDECS decs, BOOL inbody, index) VOID:
      ( REF DDECS d := decs;
        WHILE d ISNT nildecs
        DO loadtype(t OF d, FALSE, FALSE, index);
           REF IDS ids := ids OF d;
           WHILE ids ISNT nilids
           DO CASE u OF idinfo OF ids IN
              (REF DECIDS d) ( outints((dummy, decno OF d)) ),
              (VARID v)      ( outints((dummy, decno OF v)) )
              OUT SKIP
              ESAC;
              outid(id OF idinfo OF ids);
              IF inbody THEN outattrs(attr OF ids) FI;
              ids := rest OF ids
           OD;
           d := rest OF d;
           outints(zero)
       OD;
       outints(end)
     );

     PROC (REF MPARAMS, BOOL) VOID outmacspec;

     PROC outfndec = (REF FNDEC fd, BOOL inbody) VOID:
     (  REF FNINFO fi = fninfo OF fd;
        BOOL external = (sort OF fd = outerdec) ANDTH (fnno OF fd > 1);
        IF inbody OREL (fnno OF fd > 1)
        THEN outints((fnstart, fnno OF fd))
        FI;
        IF (sort OF fd =macpardec) ANDTH NOT inbody
        THEN outid(nullid)
        ELSE outid(id OF fd)
        FI;
        outints((dummy, sort OF fd, ABS macro OF fd));
        IF external
        THEN outints((dummy, 0))
        ELSE outmacspec(mp OF fd, inbody)
        FI;
        IF inbody
        THEN outattrs(attr OF fd)
        ELSE outints(attnull)
        FI;
        IF inbody ANDTH (sort OF fd = outerdec)
        THEN outints(brief);
             outdecattr(inputs OF fd);
             outdecattr(outputs OF fd);
             outints((dummy, vnno OF fninfo OF fd))
        ELSE outints(normalfn);
             outddecs(inputs OF fd, inbody, external);
             outddecs(outputs OF fd, inbody, external)
{{?? remove names for macpardec}}
        FI;
        IF external OREL ((sort OF fd = macpardec) ANDTH NOT inbody)
        THEN outints((fnend, 0))
        ELIF sort OF fd = macpardec
        THEN outints((fnend, fnno OF fd, num_names OF fd, 0))
        FI
     );


      PROC outextfns = (REF FNS fns)VOID:
      (  REF FNS f:= fns;
         WHILE f ISNT nilfns
         DO  REF FNINFO fi = fninfo OF fndec OF f;
             IF scope OF fi = 0
             THEN outfndec(fndec OF f, FALSE);
                  outints((dummy, vnno OF fi, ABS import OF fi));
                  scope OF fi := -1; fnno OF fndec OF f := -1
             FI;
             f:= rest OF f
         OD;
         outints(zero)
      );

      PROC num_names_extfns = (REF FNS fns)VOID:
      (  REF FNS f:= fns;
         WHILE f ISNT nilfns
         DO  REF FNDEC fd = fndec OF f;
             IF scope OF fninfo OF fd = 0
             THEN  { this id will give max nameno in spec }
                   CASE u OF idinfo OF ids OF outputs OF fd IN
                   (REF DECIDS d)
                      outints((fnend, - fnno OF fd, decno OF d, 0))
                   OUT SKIP
                   ESAC
             FI;
             f:= rest OF f
         OD
      );


      PROC (CTYPE) TYPE ctypetotype;

      PROC loadctype = (CTYPE ct)VOID:
      (  REF CST cst1; REF CALTS calts;

         PROC ptypeno = (TYPE t)INT:
         (  CASE t IN
            (REF PRIMSET p) typeno OF p,
            (REF NAMED n)   typeno OF n,
            (REF TYPEVAR tv) ptypeno(t OF tv)
            OUT fault(0, "ptypeno"); 0
            ESAC
         );
         PROC pcnulltypeno = (TYPE t)INT:
         (  CASE t IN
            (REF PRIMSET p) typeno OF p,
            (REF NAMED n) typeno OF n,
            (REF TYPEVAR tv) CASE t OF tv IN
                             (TNULL) 0 { only present if fault }
                             OUT pcnulltypeno(t OF tv)
                             ESAC
            OUT fault(0, "ptypeno"); 0
            ESAC
         );
         PROC pctypeno = (CTYPE ct)INT:
         ( CASE ct IN
             (REF CNAMED cnd)  pctypeno(ct OF cnd),
             (REF CPRANGE cpr) ptypeno(t OF cpr),
             (REF CPINDEX cpi) ptypeno(t OF cpi),
             (REF PRIMID p) ptypeno(type OF p),
             (REF CUNN cu) ptypeno(type OF p OF cu),
             (REF CROW cr) pctypeno(ct OF cr),
             (REF CNULLT cn) pcnulltypeno(ct OF cn),
             (REF CPCHAR ch) ptypeno(t OF ch),
             (REF CTYPEVAR cv) ptypeno(t OF cv)
            OUT fault(0, "pctypeno"); 0
           ESAC
         );
         CASE ct IN
         (REF CNAMED cn)
         (  outints((cnamed, ctypeno OF cn)) ),
         (REF CPRANGE cpr)
         (  outints((cprimr, ptypeno(t OF cpr)));
            ( loadint(lwb OF cpr, FALSE) |
                                  lwb OF cpr:= UNCHECKEDINT lwb OF cpr );
            ( loadint(upb OF cpr, FALSE) |
                                  upb OF cpr:= UNCHECKEDINT upb OF cpr )
         ),
         (REF CPINDEX cpi)
         (  outints((cprimi, ptypeno(t OF cpi)));
            ( loadint(index OF cpi, FALSE)
              | index OF cpi:= UNCHECKEDINT index OF cpi )
         ),
         (REF PRIMID p)
            outints((cprim, ptypeno(type OF p), index OF p)),
         (REF CUNN cu)
         (  outints((cprimu, ptypeno(type OF p OF cu)));
            outints((dummy, index OF p OF cu)); loadctype(ct OF cu)
         ),
         (REF CROW cr)
         (  outints(crow);
            ( loadint(size OF cr, FALSE) |
                                  size OF cr:= UNCHECKEDINT size OF cr);
            loadctype(ct OF cr)
         ),
         (REF CST cs)
         (  cst1:= cs; outints(cst);
            WHILE cst1ISNT nilcst
            DO  loadctype(cst OF cst1); cst1:= rest OF cst1 OD;
            outints(end)
         ),
         (REF CALTS ca)
         (  calts:= ca; outints(calt);
            WHILE calts ISNT nilcalts
            DO loadctype(calt OF calts); calts:= rest OF calts OD;
            outints(end)
         ),
         (REF CNULLT cn)
            (outints(c_type); loadtype(ct OF cn, FALSE, FALSE, FALSE)),
         (REF CQUERY cq)
            (outints(cquery); loadtype(querytype OF cq, FALSE, FALSE, FALSE)),
         (REF CBRACKET cb)
            (outints(cbracket); loadctype(cbracket OF cb)),
         (UNSET u) SKIP,
         (REF CPCHAR ch)
         (  outints((cprimch, ptypeno(t OF ch)));
            outid(HEAP VECTOR [1] CHAR := char OF ch)),
         (REF CPSTRING cs)
         (   IF (strings OF cs) ISNT nilstringlist
               THEN outints((cprimst, pctypeno(ct OF cs)));
                    outstringlist(strings OF cs)
               ELSE outints(cstring);
                    IF loadint(size OF cs, FALSE)
                       THEN size OF cs:= UNCHECKEDINT size OF cs
                    FI;
                    loadctype(ct OF cs)
             FI
         ),
         (REF CPCHRANGE cr)
         (   outints((cprimchr, ptypeno(t OF cr)));
             outid(HEAP VECTOR [1] CHAR := lwb OF cr);
             outid(HEAP VECTOR [1] CHAR := upb OF cr)
         ),
         (REF CTYPEVAR cv) outints((cparam, xno OF cm OF cv)),
         (REF CINDEX ci)
         (  outints(cindex); loadctype(ct OF ci);
            ( loadint(index OF ci, FALSE) |
                 index OF ci:= UNCHECKEDINT index OF ci )
         ),
         (REF CTRIM ct)
         (  outints(ctrim); loadctype(ct OF ct);
            ( loadint(lwb OF ct, FALSE) | lwb OF ct:= UNCHECKEDINT lwb OF ct );
            ( loadint(upb OF ct, FALSE) | upb OF ct:= UNCHECKEDINT upb OF ct )
         ),
         (REF CREPL cp)
         (  REF INTVARMULT rp = get_intvarmult(ids OF cp);
            outints((cvarmult, varmultno OF rp));
            outid(id OF idinfo OF ids OF cp);
            outattrs(attr OF ids OF cp);
            ( loadint(lwb OF rp, FALSE) | lwb OF rp:= UNCHECKEDINT lwb OF rp );
            ( loadint(upb OF rp, FALSE) | upb OF rp:= UNCHECKEDINT upb OF rp );
            loadctype(ct OF cp)
         ),
         (REF CCOND cd)
         (  outints(cif);
            ( loadint(test OF cd, FALSE) | test OF cd:=UNCHECKEDINT test OF cd);
            loadctype(then OF cd);  loadctype(else OF cd)
         ),
         (REF CCONC cn)
         (  outints((cconc, ABS string OF cn, sort OF cn));
            loadctype(left OF cn);  loadctype(right OF cn)
         ),
         (REF CATTR ca)
         (  outints(cattr);  loadctype(ct OF ca); outattrs(attr OF ca) ),
         (CVOID) outints(cvoid),
         (FLT f)   SKIP
         OUT fault(0, "loadctype")
         ESAC
      );


     PROC outmacinfo = (REF MACINFO mi, INT macsort, BOOL all) VOID:
     (  outints((dummy, sort OF mi));
        outints(macsort);
        IF all THEN outid(id OF mi) ELSE outid(nullid) FI;
        outints((dummy, xno OF mi));
        IF macsort /= attrname
        THEN  IF all THEN outattrs(attr OF mi) ELSE outints(attnull) FI
        FI
     );

     outmacspec := (REF MPARAMS mps, BOOL all) VOID:
     (  REF MPARAMS m := mps;
        INT num := 0;
        WHILE m ISNT nilmparams DO num PLUSAB 1; m := rest OF m OD;
        outints((dummy, num));
        m := mps;
        WHILE m ISNT nilmparams
        DO CASE value OF m IN
           (REF ATTRVAR av) ( outmacinfo(am OF av, attrname, all);
                              outints(attnull)
                            ),
           (REF INTVAR iv)  ( outmacinfo(im OF iv, intname, all);
                              loadint(intnull, FALSE)
                             ),
           (REF TYPEVAR tv)  ( outmacinfo(tm OF tv, typename, all);
                               loadtype(t OF tv, TRUE, all, FALSE)
                             ),
           (REF CTYPEVAR cv) ( outmacinfo(cm OF cv, constname, all);
                               CNULLT cn; ct OF cn := t OF cv;
                               loadctype(cn)
                             ),
            (REF FNDEC fd)   ( outints((dummy, expl_par));
                               outfndec(fd, all)
                             )  {{??check attributes}}
        ESAC;
        m := rest OF m
      OD
     );


      PROC (FNCALL, BOOL) VOID outmparams;

      PROC outfncall = (FNCALL fc, BOOL mac_macparam) VOID:
      ( REF FNDEC fd = f OF fc;
        IF fd ISNT nilfndec
        THEN outints((inst, fnno OF fd));
             outmparams(fc, mac_macparam);
             outattrs(attr OF fc)
        FI
      );

      outmparams := (FNCALL c, BOOL mac_macparam)VOID:
      (  REF FNDEC fd = f OF c;
         REF MPARAMS m:= mp OF fd;
         REF PARAMVALS pvals := pvals OF c;
         IF NOT macro OF fd OREL mac_macparam
         THEN outints((dummy, -1))
         ELSE
            INT num := 0;
            WHILE pvals ISNT nilparamvals
               DO num PLUSAB 1; pvals := rest OF pvals OD;
            outints((dummy, num));
            pvals := pvals OF c;
            WHILE pvals ISNT nilparamvals
            DO  outints((dummy, sort OF m));
                CASE val OF pvals IN
                (ATTRID ad)  outattrs(a OF ad),
                (INTID id)   IF loadint(i OF id, FALSE)
                             THEN  val OF pvals
                                       := MAKEINTID UNCHECKEDINT i OF id
                             FI,
                (TYPEID td)  loadtype(t OF td, FALSE, FALSE, FALSE),
                (CTYPEID cd) loadctype(ct OF cd),
                (FNCALL fc)  CASE value OF m IN
                             (REF FNDEC fd) outfncall(fc, macro OF fd)
                             OUT outfncall(fc, FALSE) { ALIEN parameter }
                             ESAC
                OUT SKIP {FLT}
                ESAC;
                pvals := rest OF pvals;
                m:= rest OF m
            OD
         FI;
         outints(zero)
      );

      PROC simplify = (INTEGER i, BOOL simp)INTEGER:
         simplify_ext(i, simp, fault);     {{ IN impmacro.sta }}

      OP  GIVEINT  = (INTEGER  in) INT:
          (   CASE in IN
                 (INT i)  i ,
                 (REF INTTEXT it) int OF it,
                 (REF INTCHECK ic)  GIVEINT integer OF ic,
                 (INULL i) 0
                 OUSE simplify(in, TRUE) IN
                       (INT i)  i ,
                       (REF INTCHECK ic)  GIVEINT integer OF ic
                  OUT     -1
              ESAC
          );


      PROC simplify_int = (INTEGER  in) INTEGER:
          (   CASE in IN
                 (INT i)  i ,
                 (REF INTTEXT it) int OF it,
                 (REF INTCHECK ic)  simplify_int(integer OF ic),
                 (INULL i) 0
                 OUSE simplify(in, TRUE) IN
                      (INT i)  i 
                 OUT  in
              ESAC
          );


      PROC isintcheck = (INTEGER in) BOOL:
        CASE in IN (REF INTCHECK ic) TRUE OUT FALSE ESAC;

      OP  ISINT = (INTEGER in) BOOL:   { assumes "in" has been simplified }
          ( CASE in IN
                 (INT i)  TRUE ,
                 (REF INTCHECK ic)  ISINT integer OF ic
                 OUT     FALSE
              ESAC
          );


      PROC (CTYPE, CTYPE ) BOOL ctype equals ; CO .... no unknowns .... CO

      PROC csttorow = (REF CST cst) CTYPE:
      (  CTYPE ct = cst OF cst; REF CST rest := rest OF cst; INT k:= 1;
         BOOL equal := TRUE;
         WHILE equal ANDTH (rest ISNT nilcst)
         DO  IF NOT ctype equals(ct, cst OF rest) THEN equal := FALSE FI;
             rest := rest OF rest; k PLUSAB 1
         OD;
         IF equal
         THEN HEAP CROW := (ct, k)
         ELSE cst
         FI
      );

    PROC trimcst = (REF CST st, INT f, size) REF CST:
      IF (st IS nilcst) OREL size<= 0 OREL f<= 0 THEN nilcst
      ELIF f>1
      THEN trimcst(rest OF st, f-1, size)
      ELSE HEAP CST:= (cst OF st, trimcst(rest OF st, f, size-1))
      FI;

    PROC stringrow = (REF STRINGLIST sl) BOOL:
      (  CHAR c = (id OF sl)[1];
         REF STRINGLIST s := sl;
         BOOL equal := TRUE;
         WHILE equal ANDTH (s ISNT nilstringlist)
         DO  FORALL i IN id OF s WHILE equal
               DO IF i /= c THEN equal := FALSE FI OD;
             s := rest OF s
         OD;
         equal
      );

    PROC trimstrings = (REF STRINGLIST sl, INT lwb, upb) REF STRINGLIST:
    ( INT num := IF sl ISNT nilstringlist THEN UPB (id OF sl) ELSE -1 FI;
      IF (sl IS nilstringlist) OREL upb < 1 THEN nilstringlist
      ELIF lwb > num
      THEN trimstrings(rest OF sl, lwb - num, upb - num)
      ELSE IF upb < num THEN num := upb FI;
           HEAP STRINGLIST := ((id OF sl)[lwb:num],
                               trimstrings(rest OF sl, 1, upb - num))
      FI
   );

   PROC ctypetrim = (CTYPE ct, INTEGER trim, offset, CTYPE original) CTYPE:
   BEGIN
      { Type check already happened so know trim/index is ok or unknown }
      CTYPE ans;
      BOOL istrim = GIVEINT trim /= 0;
      CASE ct IN
      (REF CROW r)
      (  IF istrim THEN HEAP CROW:= (ct OF r, trim) ELSE ct OF r FI ),
      (REF CPSTRING cs)
      (  IF strings OF cs IS nilstringlist  { i.e STRING [4] c'a }
         THEN IF istrim
              THEN HEAP CPSTRING := (trim, ct OF cs, nilstringlist)
              ELSE ct OF cs
              FI
         ELSE  { i.e c"abcd" }
              IF CASE simplify_int(offset) IN
                 (INT o1)
                    CASE simplify_int(trim) IN
                    (INT t1)
                     ( REF STRINGLIST sl = trimstrings(strings OF cs, o1,
                                         ( istrim | o1 + t1 - 1 | o1 ));
                       ans := IF istrim
                              THEN HEAP CPSTRING := (trim, ct OF cs, sl)
                              ELSE HEAP CPCHAR := (ctypetotype(ct OF cs),
                                                   (id OF sl)[1])
                              FI;
                       FALSE
                     )
                    OUT TRUE
                    ESAC
                OUT TRUE
                ESAC
              THEN  IF stringrow(strings OF cs)
                    THEN HEAP CPCHAR cc := (ctypetotype(ct OF cs),
                                            (id OF strings OF cs)[1]);
                         IF istrim
                         THEN HEAP CPSTRING := (trim, cc, nilstringlist)
                         ELSE cc
                         FI
                    ELSE original
                    FI
              ELSE ans
              FI
         FI
      ),
      (REF CST s)
      (  IF CASE simplify_int(offset) IN
            (INT i1)
               CASE simplify_int(trim) IN
               (INT s1)
                 (  REF CST cst = trimcst(s, i1, ( istrim | s1 | 1 ));
                    ans := IF istrim THEN cst ELSE cst OF cst FI;
                    FALSE
                 )
               OUT TRUE
               ESAC
            OUT  TRUE
            ESAC
         THEN  CASE  csttorow(s) IN
               (REF CROW r) IF istrim
                            THEN HEAP CROW:= (ct OF r, trim) ELSE ct OF r
                            FI
              OUT original
              ESAC
         ELSE ans
         FI
       )
      OUT original
      ESAC
   END;

PROC length = (REF STRINGLIST strings) INT:
( INT total := 0;
  REF STRINGLIST sl := strings;
  WHILE sl ISNT nilstringlist
  DO total PLUSAB UPB (id OF sl);
     sl := rest OF sl
  OD;
  total
);

PROC joinstrings = (INT s, REF STRINGLIST strings) REF VECTOR [] CHAR:
( REF STRINGLIST sl := strings;
  INT size = IF s > 0 THEN s ELSE length(sl) FI;
  REF VECTOR [] CHAR string := HEAP VECTOR [size] CHAR;
  INT lwb := 1;
  INT upb;
  WHILE sl ISNT nilstringlist
  DO INT sz = UPB (id OF sl);
     IF sz > 0
     THEN upb := lwb + sz - 1;
          string[lwb:upb] := id OF sl;
          lwb := upb + 1
     FI;
     sl := rest OF sl
  OD;
  string
);

      PROC row_conc = (INT sort, CTYPE left, right) CTYPE:
      (  BOOL unknown := FALSE;
         REF CST new := nilcst;
         REF REF CST next := new;
         BOOL flatten := ( sort = flattenleft OREL sort = flattenboth );
         CTYPE ct := left;
         TO 2 WHILE NOT unknown
         DO IF flatten
            THEN CASE ct IN
                 (REF CROW cr)
                    CASE simplify_int(size OF cr) IN
                    (INT n)
                       TO n
                       DO REF REF CST (next) := HEAP CST := (ct OF cr, NIL);
                          next := rest OF next
                       OD
                    OUT unknown := TRUE
                    ESAC,
                 (REF CST cs)
                    ( REF CST cst := cs;
                      WHILE cst ISNT nilcst
                      DO REF REF CST (next) := HEAP CST := (cst OF cst, NIL);
                         cst := rest OF cst;
                         next := rest OF next
                      OD
                    )
                 OUT sys fault("row_conc")
                 ESAC
            ELSE REF REF CST (next) := HEAP CST := (ct, nilcst);
                 next := rest OF next
            FI;
            flatten := (sort = flattenright OREL sort = flattenboth );
            ct := right
        OD;
        IF unknown
        THEN HEAP CCONC := (FALSE, sort, left, right)
        ELSE new
        FI
     );

      PROC string_conc = (INT sort, CTYPE left, right) CTYPE:
      (  CTYPE prim;
         INT lsize =
            CASE  left IN
            (REF CPSTRING lg)
              ( prim := ct OF lg;
                GIVEINT(size OF lg)
              )
            OUT 1
            ESAC;
         INT rsize =
            CASE  right IN
            (REF CPSTRING rg)
              ( prim := ct OF rg;
                GIVEINT(size OF rg)
              )
            OUT 1
            ESAC;
         IF lsize = -1 OREL rsize = -1
         THEN HEAP CCONC := (TRUE, sort, left, right)
         ELSE CASE prim IN
              (UNION (REF CNULLT, REF CQUERY))
                  HEAP CPSTRING := (lsize + rsize, prim, nilstringlist)
              OUT CTYPE ct := right;
                  INT size := rsize;
                  REF STRINGLIST strings;
                  TO 2
                  DO CASE ct IN
                     (REF CPSTRING cs)
                        IF (strings OF cs) IS nilstringlist
                        THEN CASE ct OF cs IN
                             (REF CPCHAR cp)
                               ( HEAP VECTOR [size] CHAR id;
                                 FORALL i IN id DO i := char OF cp OD;
                                 strings := HEAP STRINGLIST := (id, strings)
                                )
                               OUT sys fault("string_conc - 2")
                               ESAC
                         ELIF strings IS nilstringlist
                         THEN strings := strings OF cs
                         ELSE strings := HEAP STRINGLIST :=
                                 ( joinstrings(size, strings OF cs), strings)
                         FI,
                      (REF CPCHAR cc)
                         ( HEAP VECTOR [1]CHAR ii; ii[1] := char OF cc;
                           strings := HEAP STRINGLIST := (ii, strings)
                         )
                      OUT sys fault("string_conc - 3")
                      ESAC;
                      ct := left;
                      size := lsize
                  OD;
                  HEAP CPSTRING := (lsize + rsize, prim, strings)
             ESAC
         FI
      );


      PROC simplify_ctype = (CTYPE ct) CTYPE:
      (  {  removes CCONC, CNAMED, CBRACKET, CINDEX, CTRIM, CCOND and CATTR }
         {  alters ?[4]bool -> [4]?bool, rowbool -> [4]bool                 }
         CTYPE c1;

         PROC move_query = (TYPE t) CTYPE:
             CASE t IN
             (REF ROW r)  HEAP CROW := (MAKECQUERY(t OF r), size OF r),
             (REF ST s)   (REF ST st := s;
                           REF CST new := nilcst;
                           REF REF CST next := new;
                           WHILE st ISNT nilst
                           DO REF REF CST (next) := HEAP CST
                                                 := (MAKECQUERY(t OF st), NIL);
                              next := rest OF next;
                              st := rest OF st
                           OD;
                           new
                          )
             OUT MAKECQUERY t
             ESAC;


         CASE ct IN
         (REF CNAMED cn)    simplify_ctype(ct OF cn),
         (REF CBRACKET cb)  simplify_ctype(cbracket OF cb),
         (REF CATTR ca)     simplify_ctype(ct OF ca),
         (REF CQUERY cq)    move_query(primtype(querytype OF cq, FALSE)),
         (REF CNULLT cn)
            ( HEAP CNULLT cnt; ct OF cnt := primtype(ct OF cn, FALSE);
              cnt
            ),
         (REF CINDEX ci)
            ( c1 := ctypetrim(simplify_ctype(ct OF ci), 0, index OF ci, ci);
              simplify_ctype(c1)
            ),
         (REF CTRIM ct)
            ( INTEGER size:= simplify( HEAP INTDOP:=
              (diplus, HEAP INTDOP:= (diminus, upb OF ct, lwb OF ct), 1), TRUE);
              c1 := ctypetrim(simplify_ctype(ct OF ct), size, lwb OF ct, ct);
              simplify_ctype(c1)
            ),
         (REF CCOND cc)
            ( INTEGER cond = simplify_int(test OF cc);
              CASE cond IN
              (INT i1) IF i1 /= 0
                       THEN simplify_ctype(then OF cc)
                       ELSE simplify_ctype(else OF cc)
                       FI
              OUT cc
              ESAC
             ),
         (REF CCONC cn)
             ( CTYPE left = simplify_ctype(left OF cn),
                     right = simplify_ctype(right OF cn);
               IF string OF cn
               THEN string_conc(sort OF cn, left, right)
               ELSE row_conc(sort OF cn, left, right)
               FI
             )
         OUT ct
         ESAC
      );



   PROC replknown = (REF INTVARMULT iv) BOOL:
   ( INTEGER lwb = simplify_int(lwb OF iv),
             upb = simplify_int(upb OF iv);
     ISINT lwb ANDTH ISINT upb
   );

  PROC nextrepl = (REF INTVARMULT iv) BOOL:
  (  BOOL more := TRUE;
     CASE index OF iv IN
     (INT index) IF index < GIVEINT upb OF iv
                 THEN index OF iv := index + 1
                 ELSE index OF iv := flt;
                      more := FALSE
                 FI
     OUT index OF iv := GIVEINT lwb OF iv
     ESAC;
     more
   );

      MODE  TEST = STRUCT (INT  t);
      OP  TST = (INT  i) TEST: (TEST  t;  t OF t:= i;  t);

      TEST true, false, unknown;
      t OF true :=1; t OF false :=2; t OF unknown :=3;

      OP  TESTBOOL = (BOOL  bool) TEST:  (( bool | true | false ));
      OP  =  = (TEST  a, b) BOOL:   ( t OF a = t OF b );

      OP  AND = (TEST  a, b) TEST:
      ( IF (a = false) OREL (b = false) THEN  false  ELIF
             (a = true) ANDTH (b = true) THEN  true  ELSE  unknown  FI
      );

      OP OR = (TEST a, b) TEST:
      ( IF   (a = true) OREL (b = true) THEN true
        ELIF (a = false) ANDTH (b = false) THEN false ELSE unknown FI
      );

      MODE  INTTEST = STRUCT (TEST  test,  INTEGER  integer);


      PROC  test expressions = (INTEGER  a, b, INT diff) TEST:
      BEGIN    CO  ...if either contain FLT, true is delivered  (unless
                 unknown or false are found elsewhere in the structure).
                 *** "unknown" must dominate "false" for integer expressions
                 and so operator AND is re-defined locally ***   CO
         OP AND = (TEST  a, b) TEST:
         ( IF (a = unknown) OREL (b = unknown) THEN  unknown
              ELIF (a = true) ANDTH (b = true) THEN  true  ELSE  false
           FI
         );
         CASE b IN
            (REF INTCHECK  icb)  test expressions(a, integer OF icb, diff) ,
            (FLT  flt)  true,
            (REF IBRACKET ibb) test expressions(a, ibracket OF ibb, diff)
            OUT
               CASE a IN
                  (INT  ia)
                     CASE b IN
                        (INT  ib)  TESTBOOL (ia = ib),
                        (REF INTTEXT it)  TESTBOOL (ia = int OF it)
                        OUT        unknown
                     ESAC ,
                  (REF INTTEXT ita)
                     test expressions(int OF ita, b, diff) ,
                  (FLT  flt)  true ,
                  (REF INTCHECK  ica)
                     test expressions(integer OF ica, b, diff) ,
                  (REF INTVAR  iva)
                     CASE b IN
                        (REF INTVAR  ivb)
                            ( REF MACINFO ma = im OF iva, mb = im OF ivb;
                              IF fnno OF ma - fnno OF mb = diff
                                  ANDTH  (index OF ma = index OF mb)
                              THEN  true
                              ELSE unknown
                              FI
                            )
                        OUT  unknown
                     ESAC ,
                  (REF INTDOP  ida)
                     CASE b IN
                        (REF INTDOP  idb)
                           IF opno OF ida = opno OF idb THEN  true
                                    ELSE  unknown  FI  AND
                              test expressions(l OF ida, l OF idb, diff)  AND
                              test expressions(r OF ida, r OF idb, diff)
                        OUT  unknown
                     ESAC ,
                  (REF INTMOP  ima)
                     CASE b IN
                        (REF INTMOP  imb)
                           IF opno OF ima = opno OF imb THEN  true
                                    ELSE  unknown  FI  AND
                              test expressions(r OF ima, r OF imb, diff)
                        OUT  unknown
                     ESAC ,
                  (REF INTCOND  ica)
                     CASE b IN
                        (REF INTCOND  icb)
                           test expressions(cond OF ica, cond OF icb, diff)  AND
                           test expressions(t OF ica, t OF icb, diff)        AND
                           test expressions(f OF ica, f OF icb, diff)
                        OUT  unknown
                     ESAC ,
                  (REF INTVARMULT  iva)
                     CASE b IN
                        (REF INTVARMULT  ivb)
                           IF varmultno OF iva = varmultno OF ivb
                              THEN  true  ELSE  unknown  FI
                        OUT  unknown
                     ESAC ,
                  (IPARAM  ipa)
                     CASE b IN
                        (IPARAM  ipb)
                            IF p OF ipa = p OF ipb THEN  true  ELSE
                                unknown  FI
                        OUT  unknown
                     ESAC,
                  (REF INTDEF ida)
                       CASE b IN
                          (REF INTDEF idb)
                                     test expressions(i OF ida, i OF idb, diff)
                           OUT unknown
                       ESAC,
                  (REF IBRACKET iba) test expressions(ibracket OF iba, b, diff)
                  OUT  SKIP
               ESAC
         ESAC
      END;


      MODE  CHECK  = STRUCT (INT  c);
      OP  CHK  = (INT  i) CHECK: (CHECK c; c OF c:= i; c);

      CHECK  check type ,   check type output ,
             checkle    ,   checkge ,   checkeq ,
             checkne    ;
      c OF check type := 1; c OF check type output := -1;
      c OF checkle := 2; c OF checkge := 3; c OF checkeq := 4; c OF checkne :=5;

      CO  ABS check MOD 8  gives test;  < 0 indicates that check
           should be output imediately to the intermediate language.
      CO

      PROC test ints = (CHECK check, INTEGER int, stand,
                        INT no, VECTOR [] ERRPARAM params, INT diff) INTTEST:
      (  REF INTCHECK  intcheck;

         PROC result = (INTEGER int, stand, CHECK check) INTEGER:
         ( REF INTCHECK ic = HEAP INTCHECK:= (int, stand, ABS c OF check);
           IF c OF check >= 0 THEN  ic  ELSE  loadint(ic, FALSE);  int  FI
         );

         PROC  getintcheck = (INTEGER in) INTCHECK:
         ( CASE in IN
              (REF INTCHECK ic) ic
               OUT intcheck
           ESAC );

         INTEGER int1 := simplify(int, TRUE), stand1 := simplify(stand, TRUE);
         INTTEST ans:= (true, int);

         IF IF (ABS c OF check MOD 8) = 1  CO ...test equality... CO
              THEN  (test OF ans:= test expressions(int1, stand1, diff))
                                                                     = unknown
              ELSE  TRUE
              FI
         THEN
            CASE int1 IN
               (INT i)
                  CASE stand1 IN
               (INT j)  test OF ans:= TESTBOOL
                                     CASE  ABS c OF check MOD 8
                                     IN    (i = j), (i <= j), (i >= j),
                                           (i = j), (i /= j)
                                     OUT  fault(0, "test ints");  FALSE
                                     ESAC ,
               (FLT f)      SKIP ,
               (REF INTCHECK ic)
               (  ans:= test ints(check, int, integer OF getintcheck(stand),
                                                            no, params, diff);
                  intcheck:= HEAP INTCHECK:= getintcheck(stand);
                  integer OF intcheck:= integer OF ans;
                  integer OF ans:= intcheck
               )
               OUT  ans:= ( unknown, result(int, stand, check) )
                  ESAC ,
               (FLT f)    SKIP ,
               (REF INTCHECK ic)
               (  ans:= test ints(check, integer OF getintcheck(int),
                                                      stand, no, params, diff);
                  intcheck:= HEAP INTCHECK:= getintcheck(int);
                  integer OF intcheck:= integer OF ans;
                  integer OF ans:= intcheck
               )
               OUT  ans:= ( unknown, result(int, stand, check) )
            ESAC
         FI;
         IF (test OF ans = false) ANDTH (no > 0)
         THEN  faultp(no, params)
         FI;
         ans
      );

      PROC  test integers = (CHECK check, REF INTEGER  int, INTEGER
                               stand, INT no, VECTOR [] ERRPARAM params) BOOL:
      ( INTTEST  result = test ints(check, int, stand, no, params, 0);
        int:= HEAP INTEGER:= integer OF result;
        NOT (test OF result = false)
      ) ;

      PROC  integer equals = (INTEGER a, b, INT diff) BOOL:
                                                     CO  ...no unknowns...  CO
      ( (test OF test ints(check type, a, b, 0, nullid, diff)) = true );

      PROC (TYPE, TYPE, INT) BOOL equiv_types;

      PROC check equals = (TYPE a1, b1, BOOL  outcheck, ignore, exact,
                                                                INT diff) TEST:
      (  CO  ..."outcheck" controls whether an integer equality test should be
            output immediately to the il by "test ints".  "ignore" is used to
            cause unequal ints to be treated as unknown to enable an INTCOND
            to be generated by "merge types"  (IF THEN ELSE FI)...
            If "exact" is TRUE an alias for a type is not considered equal. CO

         REF ST  st1;  INT  k;
         TEST result; REF NAMESTACK nstack;

         PROC addname = (ID id) VOID:
         ( nstack := namestack;
           IF namestack ISNT nonames
           THEN WHILE (rest OF nstack ISNT nonames) ANDTH id /= id OF nstack
                  DO nstack := rest OF nstack OD;
                IF (rest OF nstack IS nonames) ANDTH id /= id OF nstack
                THEN rest OF nstack := HEAP NAMESTACK := (id, nonames)
                FI
           ELSE namestack := HEAP NAMESTACK := (id, nonames)
           FI
         );

         PROC  check ints = (INTEGER  a, b, INT df) TEST:
         ( TEST  ans = test OF test ints(( outcheck | check type output |
                                           check type ), a, b, 0, nullid, df);
           IF ignore THEN  IF ans = true THEN true ELSE unknown FI
                       ELSE  ans
           FI
         );

         PROC equalspalts = (REF PALTS  a, b) TEST:
         (IF a IS nilpalts THEN TESTBOOL (b IS nilpalts)
          ELIF b IS nilpalts THEN  false
          ELSE
             TESTBOOL (id OF idinfo OF a = id OF idinfo OF b)  AND
             equalspalts(rest OF a, rest OF b) AND
             IF u OF a IS niltype THEN TESTBOOL (u OF b IS niltype)
             ELIF u OF b ISNT niltype
             THEN  check equals(u OF a, u OF b, out check, ignore, exact, diff)
             ELSE  false
             FI
          FI
         );

         PROC equalcharalts = (REF CHARALTS a, b) TEST:
         (  IF a IS nilcharalts THEN TESTBOOL (b IS nilcharalts)
              ELIF b IS nilcharalts THEN false
              ELSE CASE alts OF a IN
                        (CHAR ac) CASE alts OF b IN
                                     (CHAR bc) TESTBOOL (ac = bc)
                                       OUT false
                                  ESAC,
                        (CHARRANGE ar) CASE alts OF b IN
                                         (CHARRANGE br)
                                           TESTBOOL(lwchar OF ar = lwchar OF br)
                                             AND
                                           TESTBOOL(upchar OF ar = upchar OF br)
                                           OUT false
                                       ESAC
                    ESAC
                    AND equalcharalts(rest OF a, rest OF b)
             FI
         );

         TYPE a := GETTYPE a1, b := GETTYPE b1;
         CASE a IN
         (REF TYPEVAR tva)
              CASE b IN
              (REF TYPEVAR) SKIP
              OUT a := t OF tva
              ESAC
         OUT CASE b IN
             (REF TYPEVAR tvb) b := t OF tvb
             OUT SKIP
             ESAC
         ESAC;

         CASE a IN
         (REF PRIMSET ap)
            CASE b IN
            (REF PRIMSET bp)
            (result :=TESTBOOL( id OF idinfo OF ap = id OF idinfo OF bp  ANDTH
                     ((scope OF idinfo OF ap <1 ANDTH scope OF idinfo OF bp <1)
                       OREL (typeno OF ap = typeno OF bp)
                     ))
               AND
               CASE u OF ap IN
               (PRANGE ar)
                  CASE u OF bp IN
                  (PRANGE br)
                     TESTBOOL (id OF idinfo OF ar = id OF idinfo OF br)  AND
                        check ints(lwb OF ar, lwb OF br, diff)  AND
                        check ints(upb OF ar, upb OF br, diff)
                  OUT  false
                  ESAC,
               (REF PALTS aa)
                  CASE u OF bp IN
                  (REF PALTS ba) equalspalts(aa, ba)
                  OUT  false
                  ESAC,
                (PSTRING as)
                   CASE u OF bp IN
                    (PSTRING bs)
                      TESTBOOL( id OF idinfo OF as = id OF idinfo OF bs)
                           AND equalcharalts(charalts OF as, charalts OF bs)
                    OUT false
                   ESAC
               OUT SKIP
               ESAC;
               IF result =false ANDTH (id OF idinfo OF ap = id OF idinfo OF bp)
               THEN addname (id OF idinfo OF ap)
               FI;
               result),
            (REF NAMED bn)
                 IF exact
                 THEN false
                 ELSE check equals(ap, t OF bn, outcheck, ignore, exact, diff)
                 FI,
            (FLT f)  true
            OUT  false
            ESAC,
         (REF NAMED an)
           (IF exact
            THEN CASE b IN
                 (REF NAMED bn)
                   TESTBOOL(id OF idinfo OF an = id OF idinfo OF bn) AND
                   check equals(t OF an, t OF bn, outcheck, ignore, exact, diff)
                 OUT false
                 ESAC
            ELSE result := check equals(t OF an, b, outcheck,ignore,exact,diff);
                 CASE b IN
                 (REF NAMED bn)
                    IF result = false ANDTH
                                      (id OF idinfo OF an = id OF idinfo OF bn)
                    THEN addname (id OF idinfo OF an)
                    FI
                 OUT SKIP
                 ESAC;
                 result
            FI),
         (REF ST as)
            CASE b IN
            (REF ST bs)
               check equals(t OF as, t OF bs, outcheck, ignore, exact, diff) AND
                  IF rest OF as IS nilst
                  THEN  TESTBOOL (rest OF bs IS nilst)
                  ELIF rest OF bs ISNT nilst
                  THEN  check equals(rest OF as, rest OF bs, outcheck, ignore,
                                     exact, diff)
                  ELSE  false
                  FI,
            (REF ROW br)
            (  st1:= as;
               FOR i WHILE st1 ISNT nilst
               DO  IF check equals(t OF br, t OF st1, outcheck, ignore, exact,
                                     -diff) = false
                      THEN GOTO fail FI;
                  st1:= rest OF st1; k:= i
               OD;
               check ints(size OF br, k, -diff)
               EXIT
        fail:   false
            )
            OUT
               check equals(b, a, outcheck, ignore, exact, -diff)
            ESAC,
         (REF ROW ar)
            CASE b IN
            (REF ST bs)  check equals(b, a, outcheck, ignore, exact, -diff) ,
            (REF ROW br)
               check equals(t OF ar, t OF br, outcheck, ignore, exact, diff) AND
               check ints(size OF ar, size OF br, diff)
            OUT
               check equals(b, a, outcheck, ignore, exact, -diff)
            ESAC ,
         (REF FNTYPE f1)
            CASE b IN
            (REF FNTYPE f2)
              check equals(from OF f1,from OF f2,outcheck,ignore,exact,diff) AND
                 check equals(to OF f1, to OF f2, outcheck,ignore,exact,diff),
            (REF NAMED n)
                IF exact
                THEN false
                ELSE check equals(a, t OF n, outcheck, ignore, exact, diff)
                FI,
            (FLT f)  true
            OUT  false
            ESAC ,
         (REF TYPEVAR tv)
            CASE b IN
            (REF TYPEVAR tv1)
               ( REF MACINFO tvm = tm OF tv,
                             tv1m = tm OF tv1;
               TESTBOOL (index OF tm OF tv = index OF tm OF tv1  ANDTH
                         fnno OF tm OF tv  - fnno OF tm OF tv1 = diff
                         ANDTH
                         equiv_types(t OF tv, t OF tv1, diff))
               ),
            (REF NAMED n)
                IF exact
                THEN false
                ELSE check equals(a, t OF n, outcheck, ignore, exact, diff)
                FI,
            (FLT f)  true
            OUT  false
            ESAC,
         (REF TSTRING ats)
            CASE b IN
            (REF TSTRING bts)
               check equals(tstring OF ats, tstring OF bts, outcheck, ignore,
                            exact, diff)
               AND check ints(size OF ats, size OF bts, diff),
            (REF NAMED n)
                IF exact
                THEN false
                ELSE check equals(a, t OF n, outcheck, ignore, exact, diff)
                FI,
            (FLT f)  true
            OUT  false
            ESAC,
         (TVOID atv)
            CASE b IN
            (REF NAMED n)
                IF exact
                THEN false
                ELSE check equals(a, t OF n, outcheck, ignore, exact, diff)
                FI,
            (TVOID btv) true
             OUT false
            ESAC,
         (TNULL) false
         OUT
             true
         ESAC
      );

{{ ********************************* multiassign checks *******************

PROC check value = (REF VALUE va, vb) TEST:
( PROC testint = (INTEGER in, REF INT out) TEST:
  (INTEGER ints := in;
   c:  CASE in IN
        (INT i) (out := i; true),
        (REF INTTEXT it) (out := int OF it; true),
        (REF INTCHECK ic)  ( ints := integer OF ic; GOTO c),
        (INULL i) (out :=0; true)
        OUT unknown
      ESAC
  );
  INT one, two, lwb1, upb1, lwb2, upb2;
  TEST testhold;
  CASE va IN
    (REF VINDEX via) CASE vb IN
                        (REF VINDEX vib)
                              ( testhold := testint(index OF via, one) AND
                                            testint(index OF vib, two);
                                 IF testhold = true
                                    THEN TESTBOOL (one=two)
                                    ELSE unknown
                                 FI
                              ),
                        (REF VTRIM vtb)
                              ( testhold := testint(lwb OF vtb, lwb1) AND
                                            testint(upb OF vtb, upb1) AND
                                             testint(index OF via,one);
                                IF testhold = true
                                  THEN IF  ((lwb1 <= one) ANDTH (upb1 >= one))
                                          THEN true
                                          ELSE false
                                       FI
                                  ELSE unknown
                               FI),
                        (REF VDYNAMIC vdb)
                               (testhold := testint(start OF vdb, lwb1) AND
                                            testint(finish OF vdb, upb1) AND
                                            testint(index OF via,one);
                               IF testhold = true
                                  THEN IF  ((lwb1 <= one) ANDTH (upb1 >= one))
                                          THEN true
                                          ELSE false
                                       FI
                                  ELSE unknown
                                FI),
                        (FLT flt) false
                       OUT unknown
                     ESAC,
   (REF VDYNAMIC vda) CASE vb IN
                           (REF VDYNAMIC vdb)
                               (testhold := testint(start OF vda, lwb1) AND
                                            testint(start OF vdb, lwb2) AND
                                            testint(finish OF vda, upb1) AND
                                            testint(finish OF vdb, upb2) ;
                               IF testhold = true
                                  THEN IF  ((lwb1 <= lwb2) ANDTH (upb1 >= lwb2))
                                            OREL
                                           ((lwb1 >= lwb2) ANDTH (lwb1 <= upb2))
                                          THEN true
                                          ELSE false
                                       FI
                                 ELSE unknown
                                FI),
                           (REF VTRIM vtb)
                               (testhold := testint(start OF vda, lwb1) AND
                                            testint(lwb OF vtb, lwb2) AND
                                            testint(finish OF vda, upb1) AND
                                            testint(upb OF vtb, upb2) ;
                                IF testhold = true
                                  THEN IF  ((lwb1 <= lwb2) ANDTH (upb1 >= lwb2))
                                            OREL
                                           ((lwb1 >= lwb2) ANDTH (lwb1 <= upb2))
                                          THEN true
                                          ELSE false
                                       FI
                                  ELSE unknown
                                FI),
                           (FLT flt) false
                            OUT check value(vb, va)
                         ESAC,
     (REF VTRIM vta) CASE vb IN
                        (REF VTRIM vtb)
                               (testhold := testint(lwb OF vta, lwb1) AND
                                            testint(lwb OF vtb, lwb2) AND
                                            testint(upb OF vta, upb1) AND
                                            testint(upb OF vtb, upb2) ;
                                IF testhold = true
                                  THEN IF  ((lwb1 <= lwb2) ANDTH (upb1 >= lwb2))
                                             OREL
                                           ((lwb1 >= lwb2) ANDTH (lwb1 <= upb2))
                                          THEN true
                                          ELSE false
                                       FI
                                  ELSE unknown
                                FI),
                        (FLT flt) false
                         OUT check value(vb, va)
                      ESAC,
     (FLT flt) false,
     (UNSET ua) CASE vb IN
                  (UNSET ub) true,
                  (FLT flt) true
                  OUT unknown
                ESAC
   ESAC
);

PROC check assign = (IDVALUE value, REF VALUESTACK stack) VOID:
( REF VALUESTACK v_stack := stack;
  TEST test := true;
  WHILE v_stack ISNT nilvaluestack
  DO IF (id OF value) = (id OF idvalue OF v_stack)
       THEN IF (CASE (value OF value) IN (UNSET u)TRUE OUT FALSE ESAC) OREL
               (CASE (value OF idvalue OF v_stack) IN (UNSET u)TRUE OUT FALSE
                                                                           ESAC)
               THEN fp3 := id OF value; faultp(1, fp3) ;
                    GOTO out
               ELSE test := check value(value OF value,
                                              value OF idvalue OF v_stack);
                    IF test = false
                       THEN SKIP
                       ELIF test = unknown
                         THEN fault(0, "check")
                         ELSE fp3 := id OF value; faultp(1, fp3) ;
                              GOTO out
                    FI
             FI
      FI;
      v_stack := rest OF v_stack
   OD;
out: SKIP
);
    ***********************************************************************}}



PROC ctypecheck = (CTYPE aa, bb, BOOL disjoint) TEST:
(  {{ Assumes CBRACKET, CNAMED, CATTR  have been removed, CINDEX, CTRIM }}
   {{ CREPL, CCOND and CCONC simplified  and types of CTYPE are equal   }}
   {{ "true" answer indicates inputs are disjoint(BOOL disjoint=TRUE)   }}
   {{ or NOT equal(BOOL disjoint= FALSE)                                }}

   PROC checkcalts = (CTYPE a, b) TEST:
   (  CASE a IN
      (REF CALTS ca)
           (CASE b IN
            (REF CALTS bca)
               IF disjoint
               THEN (ctypecheck (calt OF ca, b, disjoint)
                     AND IF (rest OF ca) IS nilcalts
                         THEN true
                         ELSE ctypecheck (rest OF ca, b, disjoint)
                         FI)
                ELSE (ctypecheck(calt OF ca, calt OF bca, disjoint)
                      AND IF (rest OF ca) IS nilcalts
                          THEN TESTBOOL (rest OF bca ISNT nilcalts)
                          ELIF (rest OF bca) ISNT nilcalts
                          THEN ctypecheck(rest OF ca, rest OF bca, disjoint)
                          ELSE true
                          FI)
                FI
            OUT IF disjoint THEN checkcalts( b, a) ELSE true FI
            ESAC)
      OUT IF disjoint
          THEN CASE b IN
               (REF CALTS bca) (ctypecheck (a, calt OF bca, disjoint)
                                AND IF (rest OF bca) IS nilcalts
                                    THEN true
                                    ELSE ctypecheck (a, rest OF bca, disjoint)
                                    FI)
              OUT true
              ESAC
          ELSE true
          FI
      ESAC
   );

   PROC checkcharange = (CHAR l1, u1, l2, u2)TEST:
   ( CHARSET cl1 := charset[ABS l1], cu1 := charset[ABS u1],
             cl2 := charset[ABS l2], cu2 := charset[ABS u2];
     TESTBOOL (type OF cl1 /= type OF cl2)
        OR
     IF disjoint
     THEN  ( TESTBOOL (value OF cl1 > value OF cu2)
               OR TESTBOOL (value OF cu1 < value OF cl2) )
     ELSE  ( TESTBOOL (value OF cl1 /= value OF cl2)
               OR TESTBOOL (value OF cu1 /= value OF cu2) )
     FI
    );

   PROC checkstring = (CPSTRING ca, cb)TEST:
   ( REF VECTOR [] CHAR stringa, stringb;
     CHAR chara, charb;
     BOOL cnullt := FALSE;
     BOOL ans := FALSE;
     IF strings OF ca ISNT nilstringlist
        THEN stringa := joinstrings(GIVEINT size OF ca, strings OF ca)
        ELSE CASE ct OF ca IN
               (REF CPCHAR cpc) chara := char OF cpc,
               (REF CNULLT cna) cnullt := TRUE
                OUT SKIP
             ESAC
     FI;
     IF strings OF cb ISNT nilstringlist
        THEN stringb := joinstrings(GIVEINT size OF cb, strings OF cb)
        ELSE CASE ct OF cb IN
               (REF CPCHAR cpc) charb := char OF cpc,
               (REF CNULLT cna) cnullt := TRUE
                OUT SKIP
             ESAC
     FI;
     IF cnullt
     THEN  IF disjoint THEN false ELSE true FI
     ELSE  IF strings OF ca ISNT nilstringlist
           THEN IF strings OF cb ISNT nilstringlist
                  THEN FORALL i IN stringa, j IN stringb
                       DO ans := ans OREL (i /= j) OD
                  ELSE FORALL i IN stringa DO ans := ans OREL (i /= charb) OD
                FI
           ELSE IF strings OF cb ISNT nilstringlist
                  THEN FORALL i IN stringb DO ans := ans OREL (i /= chara) OD
                  ELSE ans := (chara /= charb)
                FI
           FI;
           TESTBOOL ans
     FI
    );

   CTYPE a = simplify_ctype(aa),
         b = simplify_ctype(bb);

   TEST res := unknown;

   CASE a IN (FLT )        ( res := true; GOTO ans ),
             (REF CALTS )  ( res := checkcalts(a, b); GOTO ans ),
             (REF CNULLT )
                ( res := IF disjoint
                         THEN CASE b IN (FLT) (true) OUT false ESAC
                         ELSE CASE b IN (REF CNULLT) false OUT true ESAC
                         FI;
                  GOTO ans
                )
   OUSE b IN (REF CALTS )  ( res := checkcalts(a, b); GOTO ans ),
             (REF CNULLT ) ( res := ( disjoint | false | true ); GOTO ans )
   OUT SKIP
   ESAC;

   res :=
    CASE a IN
     (REF CPRANGE cpr)
        (CASE b IN
         (REF CPRANGE bcpr)
              (   CASE simplify_int(lwb OF cpr) IN
                  (INT ai) IF disjoint
                           THEN CASE simplify_int(upb OF bcpr) IN
                                (INT bi) (TESTBOOL (ai > bi)) OUT unknown
                                ESAC
                           ELSE CASE simplify_int(lwb OF bcpr) IN
                                (INT bi) (TESTBOOL (ai /= bi)) OUT unknown
                                ESAC
                           FI
                  OUT unknown
                  ESAC
               OR CASE simplify_int(upb OF cpr) IN
                  (INT ai) IF disjoint
                           THEN CASE simplify_int(lwb OF bcpr) IN
                                (INT bi) (TESTBOOL (ai < bi))  OUT unknown
                                ESAC
                           ELSE CASE simplify_int(upb OF bcpr) IN
                                (INT bi) (TESTBOOL (ai /= bi)) OUT unknown
                                ESAC
                           FI
                  OUT unknown
                  ESAC
              ),
         (REF CPINDEX bcpi)
              IF disjoint
              THEN CASE simplify_int(index OF bcpi) IN
                   (INT bi) (   CASE simplify_int(lwb OF cpr) IN
                                (INT ai) (TESTBOOL (ai > bi))  OUT unknown
                                ESAC
                             OR CASE simplify_int(upb OF cpr) IN
                                (INT ai) (TESTBOOL (ai < bi))  OUT unknown
                                ESAC)
                   OUT unknown
                   ESAC
              ELSE true
              FI
         OUT true
         ESAC),
   (REF CPINDEX cpi)
        (CASE b IN
         (REF CPINDEX bcpi) (CASE simplify_int(index OF cpi) IN
                             (INT aii) (CASE simplify_int(index OF bcpi) IN
                                       (INT bii) TESTBOOL (aii /= bii)
                                       OUT unknown
                                       ESAC)
                             OUT unknown
                             ESAC),
         (REF CPRANGE bcpr) (ctypecheck( b, a, disjoint) )
         OUT true
         ESAC),
   (REF PRIMID p)
        (CASE b IN
         (REF PRIMID bp)  (TESTBOOL (index OF p /= index OF bp))
         OUT true
         ESAC),
   (REF CUNN cu)
        (CASE b IN
         (REF CUNN bcu)   (IF index OF (p OF cu) = index OF (p OF bcu)
                           THEN ctypecheck (ct OF cu, ct OF bcu, disjoint)
                           ELSE true
                           FI)
         OUT true
         ESAC),
   (REF CROW cr)
        (CASE b IN
         (REF CROW bcr) (ctypecheck (ct OF cr, ct OF bcr, disjoint))
         OUT ctypecheck (b, a, disjoint)
         ESAC),
   (REF CST cs)
        (CASE b IN
         (REF CROW bcr) (ctypecheck (cst OF cs, ct OF bcr, disjoint)
                         OR IF (rest OF cs) IS nilcst
                            THEN false
                            ELSE ctypecheck (rest OF cs, bcr, disjoint)
                            FI),
         (REF CST bcs)  (ctypecheck (cst OF cs, cst OF bcs, disjoint)
                         OR IF (rest OF cs IS nilcst)OREL(rest OF bcs IS nilcst)
                            THEN false
                            ELSE ctypecheck (rest OF cs, rest OF bcs, disjoint)
                            FI)
         OUT true
         ESAC),
   (REF CREPL crp)
      ( REF INTVARMULT repl = get_intvarmult(ids OF crp);
        IF replknown(repl)
        THEN TEST result := false;
             CASE b IN
             (REF CROW bpr)
                WHILE nextrepl(repl)
                DO result := result OR
                                 ctypecheck(ct OF crp, ct OF bpr, disjoint)
                OD,
             (REF CST bps)
                ( REF CST cs := bps;
                  WHILE nextrepl(repl)
                  DO  result := result OR
                                   ctypecheck(ct OF crp, cst OF cs, disjoint);
                      cs := rest OF cs
                  OD
                ),
             (REF CREPL bcrp)
                ( REF INTVARMULT brepl = get_intvarmult(ids OF bcrp);
                  IF replknown(brepl)
                  THEN WHILE nextrepl(repl) AND nextrepl(brepl)
                       DO result := result OR
                                  ctypecheck(ct OF crp, ct OF bcrp, disjoint)
                       OD
                  ELSE result := unknown
                  FI
                )
             OUT result := true
             ESAC;
             result
        ELSE unknown
        FI
      ),
   (REF CPCHAR cca)
       CASE b IN
          (REF CPCHAR ccb) TESTBOOL( char OF cca /= char OF ccb),
          (REF CPCHRANGE crb) checkcharange(char OF cca, char OF cca,
                                             lwb OF crb, upb OF crb)
          OUT true
       ESAC,
   (REF CPCHRANGE cra)
       CASE b IN
          (REF CPCHRANGE crb) checkcharange(lwb OF cra, upb OF cra,
                                             lwb OF crb, upb OF crb),
          (REF CPCHAR ccb) checkcharange(lwb OF cra, upb OF cra,
                                         char OF ccb, char OF ccb)
           OUT unknown
       ESAC,
   (REF CPSTRING csa)
       CASE b IN
          (REF CPSTRING csb) TESTBOOL(GIVEINT(size OF csa)=GIVEINT(size OF csb))
                               AND checkstring(csa, csb)
          OUT unknown
       ESAC,
   (REF CTYPEVAR cva)
        CASE b IN
         (REF CTYPEVAR cvb) IF id OF cm OF cva = id OF cm OF cvb
                            THEN false
                            ELSE unknown
                            FI
            OUT unknown
        ESAC,
   (CVOID)
        CASE b IN
           (CVOID) (IF disjoint THEN false ELSE true FI)
           OUT unknown
        ESAC,
     { if these are present then simplification is unknown }
   ( UNION (REF CCONC, REF CINDEX, REF CTRIM, REF CCOND )) unknown
   OUT true
   ESAC;

ans: res
);


      PROC type test = (TYPE a, b) TEST:
           check equals(a, b, FALSE, FALSE, FALSE, 0);

      PROC  equals = (TYPE a, b) BOOL:  CO  ...does allow unknown...  CO
      ( NOT ( check equals(a, b,FALSE,FALSE,FALSE,0) = false ) );

      PROC  spec equals = (TYPE a, b, INT d, BOOL exact) BOOL:
                                                      CO  ...no unknowns...  CO
      ( check equals(a, b, FALSE, FALSE, exact, d) = true );

      PROC  check type eq = (TYPE  a, b, BOOL  output check) BOOL:
      ( NOT (check equals(a, b, output check, FALSE, FALSE, 0)
                                                                    = false) );
      ctype equals := (CTYPE a, b) BOOL: CO .... no unknowns .... CO
          spec equals(ctypetotype(a), ctypetotype(b), 0, FALSE)
            ANDTH
         (ctypecheck(a, b, FALSE) = false);


      PROC intequals = (INTEGER a, b) BOOL:
      BEGIN
        CASE simplify_int(a) IN
            (INT i)
               CASE simplify(b, TRUE) IN
                  (INT j)  i = j
                  OUT      fault(0, "inteq1");    FALSE
               ESAC
             OUT           fault(0, "inteq2");    FALSE
         ESAC
      END;

      PROC check disjoint = (CTYPE a, b) TEST:  ctypecheck(a, b, TRUE);

      PROC attr equals = (ATTR av1, av2) BOOL:
      ( PROC stringsequal = (REF STRINGLIST as1, as2) BOOL:
          IF as1 IS nilstringlist
          THEN as2 IS nilstringlist
          ELIF as2 IS nilstringlist
          THEN FALSE
          ELSE id OF as1 = id OF as2 ANDTH
               stringsequal(rest OF as1, rest OF as2)
          FI;

        CASE av1 IN
        (ATTRNULL)
           CASE av2 IN (UNION (FLT, ATTRNULL) f)  TRUE OUT FALSE ESAC,
        (REF ATTRDEF an1)
           CASE av2 IN
           (REF ATTRDEF an2)
               id OF idinfo OF an1 = id OF idinfo OF an2 ANDTH
               attr equals(attr OF an1, attr OF an2),
           (REF ABRACKET anb)
               attr equals(an1, abracket OF anb),
           (FLT) TRUE
           OUT FALSE
           ESAC,
        (REF ATTRDATA ad1)
           CASE av2 IN
           (REF ATTRDATA ad2)
                classname OF ad1 = classname OF ad2 ANDTH
                stringsequal(data OF ad1, data OF ad2),
           (REF ABRACKET adb)
               attr equals(ad1, abracket OF adb),
           (FLT) TRUE
           OUT FALSE
           ESAC,
        (REF ATTRVAR atv1)
           CASE av2 IN
           (REF ATTRVAR atv2) (xno OF am OF atv1 = xno OF am OF atv2),
           (REF ABRACKET adb) attr equals(atv1, abracket OF adb),
           (FLT) TRUE
           OUT FALSE
           ESAC,
        (REF ATTRSTR as1)
           CASE av2 IN
           (REF ATTRSTR as2)
              attr equals(elem OF as1, elem OF as2) ANDTH
                  IF rest OF as1 IS nilattrstr
                  THEN (rest OF as2 IS nilattrstr)
                  ELIF rest OF as2 ISNT nilattrstr
                  THEN  attr equals(rest OF as1, rest OF as2)
                  ELSE  FALSE
                  FI,
           (REF ABRACKET asb)
              attr equals(as1, abracket OF asb),
           (FLT) TRUE
           OUT FALSE
           ESAC,
        (REF ABRACKET ab1)
            attr equals(abracket OF ab1, av2),
        (FLT) TRUE
        OUT FALSE
        ESAC
      );

      PROC samespecid =
           (REF IDINFO p, REF IDS ids) CO scope of p = 0 CO BOOL CO same CO:
      (  BOOL error := FALSE;
         REF IDS i:= (u OF p |  (FLT f) nilids | ids);
         WHILE (i ISNT nilids) ANDTH
               (scope OF idinfo OF i /= -1 OREL id OF idinfo OF i /= id OF p)
         DO i:= rest OF i OD;
         IF i ISNT nilids THEN
            CASE u OF idinfo OF i IN
            (INTID ii)
               CASE u OF p IN
               (INTID ip) IF NOT(outofdate OF idinfo OF i) ANDTH
                             intequals(i OF ii, i OF ip)
                          THEN GOTO ok
                          FI,
               (FLT f) SKIP
               OUT error := TRUE
               ESAC,
            (ATTRID adi)
               CASE u OF p IN
               (ATTRID adp)
                     IF NOT(outofdate OF idinfo OF i) ANDTH
                           attr equals(a OF adi, a OF adp)
                     THEN GOTO ok
                     FI,
               (FLT f) SKIP
               OUT error := TRUE
               ESAC,
            (TYPEID ti)
               CASE u OF p IN
               (TYPEID tp) IF NOT(outofdate OF idinfo OF i) ANDTH
                              spec equals(t OF ti, t OF tp, 0, FALSE)
                           THEN GOTO ok
                           FI,
               (FLT f) SKIP
               OUT error := TRUE
               ESAC,
            (PRIMID pi)
               CASE u OF p IN
               (PRIMID pp) IF spec equals(type OF pi, type OF pp, 0, FALSE)
                              ANDTH index OF pi = index OF pp
                           THEN GOTO ok
                           ELIF CASE type OF pi IN (REF PRIMSET ppi)
                                     CASE type OF pp IN (REF PRIMSET ppp)
                                      id OF idinfo OF ppi /= id OF idinfo OF ppp

                                     OUT FALSE
                                     ESAC
                                OUT FALSE
                                ESAC
                           THEN error := TRUE
                           FI,
               (FLT f) SKIP
               OUT error := TRUE
               ESAC,
            (CTYPEID cti)
               CASE u OF p IN
               (CTYPEID ctp) IF NOT(outofdate OF idinfo OF i) ANDTH
                                ctype equals(ct OF cti, ct OF ctp)
                             THEN GOTO ok
                             FI,
               (FLT f) SKIP
               OUT error := TRUE
               ESAC,
            (FLT f) GOTO ok
            OUT SKIP
            ESAC;
            IF error
            THEN fp3 := id OF p;
                 faultp(CO"You are using * for something else in the library"CO
                         19, fp3 );
                 u OF p := flt
            FI
         FI;
         FALSE
         EXIT
   ok:   text OF (idinfo OF i) := TRUE; TRUE
      );

      PROC specsflt = (INT fltno) VOID:
      CASE fltno IN
       {1} fault(213, nullmsg CO"A function cannot be equivalent to a macro"CO),
       {2} SKIP, {There was a fnset error message here.}
       {3} fault(215, nullmsg CO"The inputs do not match"CO),
       {4} fault(216, nullmsg CO"The outputs do not match"CO),
       {5} fault(217, nullmsg
                            CO"The numbers of macro parameters do not match"CO),
       {6} fault(218, nullmsg
                   CO"There is a mis-match in the sorts of macro parameters"CO),
       {7} fault(219, nullmsg
                 CO"There is an implicit/explicit macro parameter mis-match"CO),
       {8} fault(220, nullmsg
            CO"The details of the macro parameter declarations do not match"CO),
       {9} fault(221, nullmsg
                    CO"The macro parameters of macro parameters do not match"CO)
      OUT fault(0, "specsflt")
      ESAC;

      PROC samespecfns = (REF FNDEC fd1, fd2, BOOL exact) INT:
      (  PROC equalsmparams = (REF MPARAMS m1, m2, INT df) INT:
         (  IF m1 IS nilmparams
            THEN IF m2 IS nilmparams THEN 0 ELSE 5 FI
            ELIF m2 IS nilmparams
            THEN 5
            ELIF sort OF m1 /= sort OF m2
            THEN 7
            ELSE INT res :=
                 CASE value OF m1 IN
                 (REF ATTRVAR)
                    CASE value OF m2 IN (REF ATTRVAR) 0 OUT 6 ESAC,
                 (REF INTVAR i1)
                    CASE value OF m2 IN (REF INTVAR i2) 0 OUT 6 ESAC,
                 (REF TYPEVAR t1)
                    CASE value OF m2 IN
                    (REF TYPEVAR t2)
                        IF NOT spec equals(t1, t2, df, exact) THEN 8 ELSE 0 FI
                    OUT 6
                    ESAC,
                 (REF CTYPEVAR c1)
                    CASE value OF m2 IN
                    (REF CTYPEVAR c2)
                        (  TYPE ct1 = ctypetotype(c1),
                                ct2 = ctypetotype(c2);
                           IF NOT spec equals(ct1, ct2, df, exact)
                           THEN 8  ELSE 0
                           FI
                        )
                    OUT 6
                    ESAC,
                 (REF FNDEC fd1)
                    CASE value OF m2 IN
                    (REF FNDEC fd2)
                       IF (macro OF fd1) /= macro OF fd2
                       THEN 6
                       ELIF NOT spec equals(param OF fd1, param OF fd2,
                                           df, exact)
                             OREL NOT spec equals(ans OF fd1, ans OF fd2,
                                                  df, exact)
                       THEN 8
                       ELIF macro OF fd1
                       THEN IF equalsmparams(mp OF fd1, mp OF fd2, df) > 0
                            THEN 9
                            ELSE 0
                            FI
                       ELSE 0
                       FI
                    OUT 6
                    ESAC
               OUT 0
               ESAC;
               IF res = 0
               THEN res := equalsmparams(rest OF m1, rest OF m2, df)
               ELSE res
               FI
          FI
         );

         INT result := 0;
         INT s1 := scope OF fninfo OF fd1;  IF s1 < 1 THEN s1 := 1 FI;
         INT s2 := scope OF fninfo OF fd2;  IF s2 < 1 THEN s2 := 1 FI;
         INT diff = s1 - s2;
         IF NOT (macro OF fd1 = macro OF fd2)
         THEN 1
         ELIF (result:= equalsmparams(mp OF fd1, mp OF fd2, diff))/= 0
         THEN result
         ELIF NOT spec equals(param OF fd1, param OF fd2, diff, exact)
         THEN 3
         ELIF NOT spec equals(ans OF fd1, ans OF fd2, diff, exact)
         THEN 4
         ELSE 0
         FI
      );

    PROC flatten_ids = (REF DDECS d) REF IDS:
      ( REF IDS flat := nilids;
        REF DDECS dd := d;
        WHILE dd ISNT nildecs
        DO REF IDS i := ids OF dd;
           WHILE i ISNT nilids
           DO flat := HEAP IDS := (idinfo OF i, FALSE, attrnull, flat);
              i := rest OF i
           OD;
           dd := rest OF dd
        OD;
        flat
      );

      PROC equalspecids = (REF DDECS spec1, spec2) BOOL:
      ( REF IDS f1 := flatten_ids(spec1),
                f2 := flatten_ids(spec2);
        BOOL equal := TRUE;
        WHILE (f1 ISNT nilids) ANDTH equal
        DO  IF (f2 IS nilids) OREL ((id OF idinfo OF f1) /= id OF idinfo OF f2)
            THEN equal := FALSE
            ELSE f1 := rest OF f1;
                 f2 := rest OF f2
            FI
        OD;
        equal ANDTH (f2 IS nilids)
      );

      PROC checkspecfns = (REF FNDEC fd2, REF FNS fns) COscope of p = 0 CO VOID:
      (  REF FNS f:=
           IF status OF fninfo OF fd2 = fn_flt THEN nilfns ELSE fns FI;
         WHILE (f ISNT nilfns) ANDTH
               (scope OF fninfo OF fndec OF f /= -1
                OREL id OF fndec OF f /= id OF fd2)
         DO f:= rest OF f OD;
         namestack := nonames;
         IF f ISNT nilfns THEN
            REF FNDEC fd1 = fndec OF f;
            INT message = samespecfns(fd1, fd2, TRUE);
            IF NOT(outofdate OF fninfo OF fd1) ANDTH message = 0
            THEN IF equalspecids(inputs OF fd1, inputs OF fd2) ANDTH
                    equalspecids(outputs OF fd1, outputs OF fd2)
                 THEN text OF (fninfo OF fd1) := TRUE;
                      vnno OF fninfo OF fd2 := vnno OF fninfo OF fd1;
                      import OF fninfo OF fd1 := import OF fninfo OF fd2
                 FI
            ELSE IF export OF fninfo OF fd1
                 THEN  fp3:= id OF fd2; fp7:= fd1; fp8:= fd2;
                       namefaultp(96, (fp3, fp7, fp8));
                       CO"* is exported and this would change it from * to *"CO
                       specsflt(message);
                       status OF fninfo OF fd2 := fn_flt;
                       status OF fninfo OF fd1 := fn_flt
                  FI
            FI
         FI
      );


      PROC isprimrange = (TYPE t)BOOL:
         CASE t IN
         (FLT f) TRUE,
         (REF PRIMSET ps)
            CASE u OF ps IN (PRANGE pr) TRUE OUT FALSE ESAC
         OUT FALSE
         ESAC;

      PROC primrange = (TYPE t) PRANGE:
      (  PRANGE ans := (NIL, flt, flt);
         CASE t IN
         (REF PRIMSET ps)
            CASE u OF ps IN (PRANGE pr) ans:= pr OUT SKIP ESAC
         OUT SKIP
         ESAC;
         ans
      );

      PROC isprimchar_t = (TYPE t)BOOL:
      (  BOOL ans:= FALSE;
         CASE t IN
         (REF NAMED rn) ans:= isprimchar_t(t OF rn),
         (REF TBRACKET b) ans := isprimchar_t(tbracket OF b),
         (FLT f) ans:= TRUE,
         (REF TYPEVAR tv) ans := isprimchar_t(t OF tv),
         (REF PRIMSET ps)
            CASE u OF ps IN
            (PSTRING pst) ans:= TRUE
            OUT SKIP
            ESAC
         OUT SKIP
         ESAC;
         ans
      );

      PROC arithtype = (TYPE t) BOOL:
      (  BOOL ans := FALSE;
         CASE t IN
         (REF NAMED rn) ans := arithtype (t OF rn),
         (REF TBRACKET b) ans := arithtype(tbracket OF b),
         (FLT f) ans := TRUE,
         (REF PRIMSET ps)
            CASE u OF ps IN
            (PRANGE pr)    ans := TRUE,
            (REF PALTS pa) ( REF PALTS pl := pa;
                             BOOL assoc := FALSE;
                             WHILE (pl ISNT nilpalts) ANDTH NOT assoc
                             DO IF u OF pl ISNT niltype THEN assoc := TRUE FI;
                                pl := rest OF pl
                             OD;
                             ans := NOT assoc
                           ),
            (PSTRING ps)   ans := TRUE
            OUT SKIP
            ESAC,
         (REF TYPEVAR tv) CASE t OF tv IN
                          (TNULL) SKIP
                          OUT ans := arithtype(t OF tv)
                          ESAC
         OUT SKIP
         ESAC;
         ans
      );

      PROC containsfntype = (TYPE t) BOOL:
      BEGIN
         CASE t IN
          (REF NAMED n)    containsfntype(t OF n),
          (REF TYPEVAR t)  containsfntype(t OF t),
          (REF TBRACKET b) containsfntype(tbracket OF b),
          (REF ST st)
              (st ISNT nilst) ANDTH
              (containsfntype(t OF st) OREL containsfntype(rest OF st)),
          (REF ROW r) containsfntype(t OF r),
          (REF FNTYPE f) TRUE
            OUT FALSE
         ESAC
      END;


      PROC containssort = (CTYPE ct, INT sort) BOOL:
      BEGIN
         CASE ct IN
         (REF CQUERY)       sort = cquery,
         (REF CNULLT ct)    sort = calt,
         (REF CPRANGE cpr)  sort = calt,
         (REF CALTS ca)     IF sort = calt
                            THEN TRUE
                            ELSE (ca ISNT nilcalts)  ANDTH
                                 (containssort(calt OF ca, sort) OREL
                                  containssort(rest OF ca, sort))
                            FI,
         (REF CNAMED cn)    containssort(ct OF cn, sort),
         (REF CUNN cu)      containssort(ct OF cu, sort),
         (REF CROW cr)      containssort(ct OF cr, sort),
         (REF CBRACKET cb)  containssort(cbracket OF cb, sort),
         (REF CPSTRING cs)  containssort(ct OF cs, sort),
         (REF CINDEX ci)    containssort(ct OF ci, sort),
         (REF CTRIM ct)     containssort(ct OF ct, sort),
         (REF CATTR ca)     containssort(ct OF ca, sort),
         (REF CREPL cp)     containssort(ct OF cp, sort),
         (REF CST cs )      (cs ISNT nilcst)  ANDTH
                               (containssort(cst OF cs, sort) OREL
                                containssort(rest OF cs, sort)),
         (REF CCOND cd)    ( INTEGER cond = simplify_int(test OF cd);
                             BOOL then = containssort(then OF cd, sort),
                                  else = containssort(else OF cd, sort);
                             CASE cond IN
                             (INT i1) IF i1 /= 0 THEN then ELSE else FI
                             OUT  then AND else
                             ESAC
                           ),
         (REF CCONC cc)
            containssort(left OF cc, sort) OREL containssort(right OF cc, sort)
         OUT  FALSE
         ESAC
      END;

      PROC ihasvmno = (INTEGER i) BOOL:
      BEGIN
        CASE i IN
         (REF INTDOP id) ihasvmno(l OF id) OREL ihasvmno(r OF id),
         (REF INTMOP im) ihasvmno(r OF im),
         (REF INTCOND ic) ihasvmno(cond OF ic) OREL ihasvmno(t OF ic)
                                                  OREL ihasvmno(f OF ic),
         (REF INTVARMULT iv) TRUE,
         (REF INTCHECK ic)  ihasvmno(integer OF ic),
         (REF INTDEF id) ihasvmno(i OF id),
         (REF IBRACKET ib) ihasvmno(ibracket OF ib)
         OUT FALSE
         ESAC
      END;

      PROC thasvmno = (TYPE t, INT v)BOOL:
      BEGIN
           PROC ivmno = (INTEGER i, INTv) BOOL:
           BEGIN
              CASE i IN
              (REF INTDOP id) ivmno(l OF id, v) OREL ivmno(r OF id, v),
              (REF INTMOP im) ivmno(r OF im, v),
              (REF INTCOND ic) ivmno(cond OF ic, v) OREL ivmno(t OF ic, v)
                                                      OREL ivmno(f OF ic, v),
              (REF INTVARMULT iv) varmultno OF iv = v,
              (REF INTCHECK ic)  ivmno(integer OF ic, v),
              (REF INTDEF id) ivmno(i OF id, v),
              (REF IBRACKET ib) ivmno(ibracket OF ib, v)
              OUT FALSE
              ESAC
            END;
        CASE t IN
         (REF ST s) (s ISNT nilst) ANDTH
                    (thasvmno(t OF s, v) OREL thasvmno(rest OF s, v)),
         (REF ROW r) thasvmno(t OF r, v) OREL ivmno(size OF r, v),
         (REF TBRACKET tb) thasvmno(tbracket OF tb, v),
         (REF TSTRING ts) thasvmno(tstring OF ts,v) OREL ivmno(size OF ts, v)
         OUT FALSE CO no way of creating others in varmult CO
         ESAC
      END;


      PROC id_outside_if = (ID id, REF SCOPESTACK sstack, REF IDS idlist) BOOL:
      BEGIN
         REF SCOPESTACK s := sstack;
         WHILE (s ISNT nilscope) ANDTH
               ((scope OF s /= vif) ANDTH (scope OF s /= seqif))
           DO s := rest OF s OD;
         IF s IS nilscope
         THEN FALSE
         ELSE BOOL notfound := TRUE ;
              REF IDS i := idlist;
              WHILE notfound ANDTH
                     (i ISNT nilids) ANDTH (REF IDS (ids OF s) ISNT i)
              DO IF id OF idinfo OF i = id THEN notfound := FALSE FI;
                 i := rest OF i
              OD;
              notfound
         FI
      END;

      PROC repl_local_make = (ID id, REF SCOPESTACK scopestack, REF IDS idlist)
                                                                          BOOL:
      BEGIN
         REF SCOPESTACK s := scopestack;
         WHILE (s ISNT nilscope) ANDTH (scope OF s /= vvarmult)
                   ANDTH (scope OF s /= seqvarmult)
           DO s := rest OF s OD;
         REF IDS i := idlist;
         WHILE (i ISNT nilids) ANDTH (id /= id OF idinfo OF i) ANDTH
               ((s IS nilscope) OREL (REF IDS(ids OF s) ISNT i))
         DO  i := rest OF i OD;
         NOT( (s IS nilscope) OREL (i IS nilids)
                              OREL (REF IDS(ids OF s) IS i))
      END;




      PROC primtypeno = (TYPE t)INT:
      BEGIN
        CASE t IN
         (REF PRIMSET p) typeno OF p,
         (REF NAMED n)   primtypeno(t OF n),
         (REF TBRACKET tb) primtypeno(tbracket OF tb),
         (REF TYPEVAR tv) primtypeno(t OF tv)
         OUT fault(CO"primsetno"CO 5, nullmsg); 1
         ESAC
      END;

      PROC unn = (TYPE t, INT index)REF TYPE:
      (  REF PALTS p;
         CASE primtype(t, TRUE) IN
         (REF PRIMSET ps)
            CASE u OF ps IN
            (REF PALTS pa)
               ( p:= pa; TO index-1 DO p:= rest OF p OD; u OF p )
            OUT NIL
            ESAC
         OUT NIL
         ESAC
      );


      PROC addclassname = (ID id) VOID:
      (  BOOL found := FALSE;
         REF STRINGLIST cnames := classnames;
         WHILE NOT found ANDTH (cnames ISNT nilstringlist)
         DO IF id = id OF cnames THEN found := TRUE FI;
            cnames := rest OF cnames
         OD;
         IF NOT found
         THEN classnames := HEAP STRINGLIST := (id, classnames)
         FI
      );



      PROC appenddecs = (REF DDECS d1, d2)REF DDECS:
      (  IF d1 IS nildecs THEN d2 ELSE
            HEAP DDECS:= (t OF d1, ids OF d1, appenddecs(rest OF d1, d2))
         FI
      );

      PROC isvoid = (TYPE t) BOOL:
      BEGIN
        CASE t IN
         (REF NAMED n)    isvoid(t OF n),
         (REF TBRACKET b) isvoid(tbracket OF b),
         (REF ST st)
            IF (st ISNT nilst)
               THEN (isvoid(t OF st) ANDTH isvoid(rest OF st))
               ELSE TRUE
            FI,
         (REF ROW r) isvoid(t OF r),
         (REF TYPEVAR tv) isvoid(t OF tv),
         (REF FNTYPE f) isvoid(from OF f) ANDTH isvoid(to OF f),
         (TVOID) TRUE
         OUT FALSE
        ESAC
      END;

      PROC setprimtype = (TYPE t, INT sort) TYPE:
           IF sort = vnamesource   THEN t
         ELIF sort = vnamesink     THEN typenull
         ELIF sort = vnameiosource THEN t
         ELSE sys fault("setiotype - 2"); SKIP
           FI;

      PROC setiotype = (TYPE t, INT sort) TYPE:
      ( PROC stiotype = (REF ST str)REF ST:
        ( IF str IS nilst THEN NIL
             ELSE HEAP ST := (setiotype(t OF str,sort), stiotype(rest OF str))
          FI
        );
        CASE t IN
          (REF NAMED n)    setiotype(t OF n, sort),
          (REF ST st)      stiotype(st),
          (REF ROW r)      HEAP ROW := (setiotype(t OF r,sort), size OF r),
          (REF TSTRING ts) HEAP TSTRING:=(size OF ts,
                                          setiotype(tstring OF ts, sort)),
          (REF TBRACKET tb) setiotype(tbracket OF tb, sort),
          (REF TYPEVAR tv)  CASE t OF tv IN
                            (TNULL) setprimtype(t, sort)
                            OUT setiotype(t OF tv, sort)
                            ESAC,
          (REF PRIMSET p)   setprimtype(t, sort),
          (REF FNTYPE ft)     IF sort = vnamesource   THEN to OF ft
                            ELIF sort = vnamesink     THEN from OF ft
                            ELIF sort = vnameiosource THEN ft
                            ELSE sys fault("setiotype - 1"); SKIP
                              FI
          OUT t
        ESAC
      );


      PROC substint1 = (FNCALL p, INT i_fnno, INTEGER i)INTEGER:
      BEGIN
         CASE i IN
         (REF INTDOP iop)
            HEAP INTDOP:= (opno OF iop, substint1(p, i_fnno, l OF iop),
                                        substint1(p, i_fnno, r OF iop)),
         (REF INTMOP mop)
            HEAP INTMOP:= (opno OF mop, substint1(p, i_fnno, r OF mop)),
         (REF INTCOND c)
            HEAP INTCOND:= (substint1(p, i_fnno, cond OF c),
                            substint1(p, i_fnno, t OF c),
                            substint1(p, i_fnno, f OF c)),
         (REF INTVAR ivar)
            IF (status OF fninfo OF f OF p /= fn_flt) ANDTH
               ( fnno OF im OF ivar <= i_fnno) ANDTH
               ( fnno OF f OF p = fnno OF im OF ivar
                 OREL ( scope OF fninfo OF f OF p = 0  ANDTH
                        fnno OF im OF ivar = 1)
               )
               THEN  REF PARAMVALS pv := pvals OF p;
                     TO index OF im OF ivar - 1 WHILE pv ISNT nilparamvals
                        DO pv := rest OF pv OD;
                     IF pv ISNT nilparamvals
                     THEN CASE val OF pv IN
                          (INTID id) i OF id
                          OUT flt
                          ESAC
                     ELSE flt
                     FI
               ELSE i
            FI ,
         (REF INTCHECK ic) HEAP INTCHECK:= (substint1(p, i_fnno, integer OF ic),
                                             standard OF ic, test OF ic),
         (REF IBRACKET ib) MAKEIBRACKET (substint1(p, i_fnno, ibracket OF ib))
         OUT
            i
         ESAC
      END;

      PROC substvarmult = (REF INTEGER i, INT vindex) INTEGER:
      (  CASE i IN
         (REF INTDOP idop) HEAP INTDOP :=
              (opno OF idop, substvarmult(l OF idop, vindex),
                                  substvarmult(r OF idop, vindex)),
         (REF INTMOP imop) HEAP INTMOP :=
              (opno OF imop, substvarmult(r OF imop, vindex)),
         (REF INTCOND c)   HEAP INTCOND :=
              (substvarmult(cond OF c, vindex),substvarmult(t OF c, vindex),
                       substvarmult(f OF c, vindex)),
         (REF INTVARMULT iv) IF (varmultno OF iv) = vindex
                                THEN index OF iv
                                ELSE iv
                             FI,
         (REF IBRACKET ib) MAKEIBRACKET (substvarmult(ibracket OF ib, vindex))
         OUT i
         ESAC
      );

      PROC substint = (FNCALL p, INT i_fnno, INTEGER i) INTEGER:
      (  simplify(substint1(p, i_fnno, simplify(i, TRUE)), TRUE)  );

      PROC substtype = (FNCALL p, INT t_fnno, TYPE t) TYPE:
      BEGIN
         PROC substpalts = (REF PALTS a) REF PALTS:
            IF a IS nilpalts
            THEN NIL
            ELSE REF TYPE ty =
                   IF u OF a IS niltype
                   THEN NIL
                   ELSE HEAP TYPE := substtype(p, t_fnno, u OF a)
                   FI;
                 HEAP PALTS:= (idinfo OF a, ty, substpalts(rest OF a))
            FI;

        PROC substst = (REF ST s) REF ST:
           IF s IS nilst THEN NIL ELSE
              HEAP ST:= (substtype(p, t_fnno, t OF s), substst(rest OF s))
           FI;

        CASE t IN
         (REF PRIMSET ps)
            HEAP PRIMSET:= (idinfo OF ps, typeno OF ps,
               CASE u OF ps IN
               (PRANGE pr)
                  HEAP PRANGE:= (idinfo OF pr, substint(p, t_fnno, lwb OF pr),
                                 substint(p, t_fnno, upb OF pr)),
               (REF PALTS pa)
                  substpalts(pa),
               (PSTRING ps)
                  HEAP PSTRING:= (idinfo OF ps, charcheck OF ps, charalts OF ps)
               OUT SKIP
               ESAC
                         ),
         (REF NAMED rn)
            HEAP NAMED:= (idinfo OF rn, typeno OF rn,
                          substtype(p, t_fnno, t OF rn)),
         (REF ST st)
            substst(st),
         (REF TYPEVAR tv)
           ( REF MACINFO tmv = tm OF tv;
            IF (status OF fninfo OF f OF p /= fn_flt) ANDTH
               ( fnno OF tm OF tv <= t_fnno) ANDTH
               ( (fnno OF tm OF tv = fnno OF f OF p)
                  OREL (scope OF fninfo OF f OF p = 0 ANDTH
                        fnno OF tm OF tv = 1 )
               )
              THEN  REF PARAMVALS pv := pvals OF p;
                    TO index OF tm OF tv - 1 WHILE (pv ISNT nilparamvals)
                        DO pv := rest OF pv OD;
                    IF (pv ISNT nilparamvals)
                    THEN CASE val OF pv IN
                         (TYPEID tid) t OF tid
                         OUT flt
                         ESAC
                    ELSE flt
                    FI
               ELSE t
            FI ),
         (REF FNTYPE f)
            HEAP FNTYPE:= (substtype(p, t_fnno, from OF f),
                           substtype(p, t_fnno, to OF f)),
         (REF ROW rr)
            HEAP ROW:= (substtype(p, t_fnno, t OF rr),
                        substint(p, t_fnno, size OF rr)),
         (REF TBRACKET tb)
            MAKETBRACKET (substtype(p, t_fnno, tbracket OF tb)),
         (REF TSTRING ts)
            HEAP TSTRING := (substint(p, t_fnno, size OF ts),
                             substtype(p, t_fnno, tstring OF ts))
         OUT
            t
         ESAC
      END;


      PROC sttorow = (REF ST st)TYPE:
      (  TYPE t = t OF st; REF ST s:= rest OF st; INT k:= 1;
         (t | (FLT f) GOTO flt | SKIP);
         WHILE s ISNT nilst
         DO  IF NOT spec equals(t, t OF s, 0, FALSE) THEN GOTO out FI;
            ( t OF s | (FLT f) GOTO flt | SKIP);
            s:= rest OF s; k PLUSAB 1
         OD;
         HEAP ROW:= (t, k) EXIT
   flt:  flt EXIT
out:     st
      );

      PROC trimst = (REF ST st, INT f, size) REF ST:
      BEGIN
         IF (st IS nilst) OREL size<= 0 OREL f<= 0 THEN nilst
         ELIF f>1 THEN trimst(rest OF st, f-1, size)
         ELSE
            HEAP ST:= (t OF st, trimst(rest OF st, f, size-1))
         FI
      END;

      PROC indexio = (TYPE t, INTEGER i2)TYPE:
      BEGIN
        INT int2 := GIVEINT(i2);
        IF CASE i2 IN (FLT f) TRUE  OUT FALSE ESAC
        THEN flt
        ELIF int2 = 0 THEN t
        ELSE CASE t IN
             (REF ROW rr) t OF rr,
             (REF TSTRING ts) tstring OF ts,
             (REF ST rs)  (IF int2 < 0
                           THEN CASE sttorow(rs) IN
                                (REF ROW rrs) (t OF rrs),
                                (REF TSTRING tss) (tstring OF tss)
                                OUT fault (CO"indexing gives an unknown type"CO
                                           57, nullmsg);  flt
                                ESAC
                           ELSE t OF trimst(rs, int2, 1)
                           FI),
               (FLT) flt
            OUT fault(CO"indexio"CO 4, nullmsg); flt
            ESAC
         FI
      END;

   PROC trimorindex = (TYPE t, INTEGER trim, index, REF INTEGER lwb, upb)TYPE:
   BEGIN
      TYPE type := t;
      BOOL istrim = GIVEINT trim /= 0;
      BOOL isconst = NOT istrim ANDTH (GIVEINT lwb = GIVEINT upb);
      REF ST st;  INTEGER size := flt;  INT isize := 0;
b:    CASE type := primtype(type, FALSE) IN
      (REF NAMED n) ( type:= t OF n; GOTO b ),
      (REF TYPEVAR tv) ( type := t OF tv; GOTO b ),
      (FLT f)       (SKIP),
      (REF ROW r)   (size := size OF r),
      (REF TSTRING ts) (size := size OF ts),
      (REF ST s)    (st := s;
                     WHILE st ISNT nilst
                       DO isize PLUSAB 1;  st := rest OF st OD;
                     size := isize
                    )
      OUT (fp1:= type;  type := flt;
           IF istrim
           THEN faultp(CO"* cannot be trimmed"CO 64, fp1)
           ELSE faultp(CO"* cannot be indexed"CO 58, fp1)
           FI
          )
      ESAC;
      ( type | (FLT f) GOTO ok | SKIP );
      fp5:= lwb;   fp6:= upb;  fp0:= size;
      IF  NOT test integers(checkge, lwb, 1,
                        IF isconst
                          THEN CO"[*] ?  this index is too small"CO 35
                          ELSE CO"[*..*] ?  the lower limit is too small"CO 59
                        FI,
                        IF isconst THEN fp5 ELSE (fp5, fp6)FI)
          OREL
          NOT test integers(checkle, upb, size,
                        IF isconst
                          THEN CO"[*] ?  this index can t exceed *"CO 41
                          ELSE CO"[*..*] ?  the upper limit can t exceed *"CO 60
                        FI,
                        IF isconst THEN (fp5, fp0) ELSE (fp5, fp6, fp0) FI)
        THEN type := flt; GOTO ok
      FI;
      IF istrim ANDTH  NOT test integers(checkge, upb, UNCHECKEDINT lwb,
           CO"[*..*] ?  you must trim at least one item"CO 61, (fp5, fp6))
      THEN  type:= flt;  GOTO ok
      FI;
      CASE type IN
      (REF ROW r)
      (  type:= IF istrim THEN HEAP ROW:= (t OF r, trim) ELSE t OF r FI ),
      (REF TSTRING ts)
      (  type:= IF istrim THEN HEAP TSTRING := (trim, tstring OF ts)
                          ELSE tstring OF ts FI ),
      (REF ST s)
      (  CASE simplify_int(index) IN
         (INT i1)
            IF i1 < 1 OREL i1 > isize
            THEN GOTO ok
            ELSE CASE simplify_int(trim) IN
                (INT s1)
                (  st := trimst(s, i1, (istrim | s1 | 1));
                   type := IF istrim OREL (rest OF st ISNT nilst)
                           THEN st   ELSE t OF st
                           FI;
                   GOTO ok
                )
                OUT SKIP
                ESAC
            FI
         OUT  SKIP
         ESAC;
         CASE  sttorow(s) IN
         (REF ROW r) ( type:= IF istrim
                              THEN HEAP ROW:= (t OF r, trim)   ELSE t OF r
                              FI;
                       GOTO ok
                     )
         OUT SKIP
         ESAC;
         type:= flt;
         IF istrim
         THEN fault(CO"trimming gives unknown type"CO 63, nullmsg)
         ELSE fault(CO"indexing gives an unknown type"CO 57, nullmsg)
         FI
      )
      ESAC;
ok:   type
   END;

   PROC  merge types = (TYPE  a, b, INTEGER  cond) TYPE:
   BEGIN
     TYPE  t:= a;   CO  ...declarations below to overcome block limit...  CO
     PROC  fail = VOID: (fault(0, "merge types"));{ ...should not be needed... }
     REF PRIMSET  pt;  REF PRANGE  prt;   REF PALTS  pat, paa, pab;
     REF NAMED  nt;    REF FNTYPE  ftt;   REF ST  pst, psa, psb;
     REF ROW  rt;      REF TYPEVAR tvt;   REF TSTRING tsr;
     IF noflts = -1 THEN
       CASE a IN
        (REF PRIMSET  pa)
                    CASE b IN (REF PRIMSET  pb)
        ( t:=  pt:= HEAP PRIMSET:= pa;
          CASE u OF pa IN
             (PRANGE  pra)  CASE u OF pb IN (PRANGE  prb)
             ( prt:= HEAP PRANGE:= pra;
               IF CASE lwb OF pra IN (INT i)
                     CASE lwb OF prb IN (INT j)  FALSE
                     OUT  TRUE
                     ESAC
                  OUT  TRUE
                  ESAC
               THEN  lwb OF prt:= HEAP INTCOND:= (cond, lwb OF pra, lwb OF prb)
               FI;
               IF CASE upb OF pra IN (INT i)
                     CASE upb OF prb IN (INT j)  FALSE
                     OUT  TRUE
                     ESAC
                  OUT  TRUE
                  ESAC
               THEN  upb OF prt:= HEAP INTCOND:= (cond, upb OF pra, upb OF prb)
               FI;
               u OF pt:= prt
             )
                         OUT  fail
                         ESAC,
             (REF PALTS  aa) CASE u OF pb IN (REF PALTS  ab)
                                 CASE u OF pt IN (REF PALTS  at)
             ( u OF pt:= pat:= HEAP PALTS:= at;    paa:= aa;    pab:= ab;
               WHILE  (REF PALTS  (paa)) ISNT nilpalts
               DO  u OF pat:= IF u OF paa IS niltype THEN  niltype
                               ELSE HEAP TYPE:= merge types(u OF paa,
                                                           u OF pab, cond)
                               FI;
                  paa:= rest OF paa;  pab:= rest OF pab;
                  pat:= rest OF pat:= IF (REF PALTS  (paa)) IS
                     nilpalts THEN  nilpalts  ELSE HEAP PALTS:= paa FI
               OD
             )
                                 OUT  fail
                                 ESAC
                            OUT  fail
                            ESAC,
            (PSTRING psa) CASE u OF pb IN
                             (PSTRING psb) SKIP  {{ No type/ints in strings }}
                              OUT fail
                          ESAC
          OUT  fail
          ESAC
        ) ,
                    (REF NAMED nb) merge types(pa, t OF nb, cond)
                    OUT  fail
                    ESAC ,
        (REF NAMED na) CASE b IN (REF NAMED nb)
        ( t:= nt:= HEAP NAMED:= na;
          t OF nt:= merge types(t OF na, t OF nb, cond)
        )
                       OUT  merge types(t OF na, b, cond)
                       ESAC,
        (REF ST sa)
          CASE b IN
            (REF ST sb)
            ( t:=  pst:= HEAP ST;    psa:= sa;    psb:= sb;
              WHILE (REF ST  (psa)) ISNT nilst
              DO  t OF pst:= merge types(t OF psa, t OF psb, cond);
                 psa:= rest OF psa;  psb:= rest OF psb;
                 pst:= rest OF pst:= IF (REF ST  (psa)) IS nilst
                                     THEN  nilst  ELSE  HEAP ST  FI
              OD

            ),
            (REF ROW  rb)
            ( t:= sttorow(sa);  ( t | (FLT f)  fault(0, "merge types") | SKIP );
              t:= merge types(t, rb, cond)
            )
          OUT  merge types(b, a, cond)
          ESAC ,
        (REF TYPEVAR tva) CASE b IN
                          (REF TYPEVAR tvb) ( t:= tvt:= HEAP TYPEVAR := tva ),
                          (REF NAMED nb)    ( merge types(a, t OF nb, cond) )
                          OUT  fail
                          ESAC,
        (REF FNTYPE  fta)
          CASE b IN (REF FNTYPE  ftb)
          ( t:= ftt:= HEAP FNTYPE;
            from OF ftt:= merge types(from OF fta, from OF ftb, cond);
            to OF ftt:= merge types(to OF fta, to OF ftb, cond)
          ),
          (REF NAMED nb)  ( merge types(a, t OF nb, cond) )
                          OUT  fail
                          ESAC,
        (REF ROW  ra)
          CASE b IN
            (REF ROW rb)
            ( t:= rt:= HEAP ROW:= ra;
              t OF rt:= merge types(t OF ra, t OF rb, cond);
              IF CASE size OF ra IN (INT i)
                    CASE size OF rb IN (INT j) (i /= j)
                    OUT TRUE
                    ESAC
                 OUT  TRUE
                 ESAC
              THEN  size OF rt:= HEAP INTCOND:= (cond, size OF ra, size OF rb)
              FI
            ),
            (REF ST  sb)
            ( t:= sttorow(sb);  ( t | (FLT f)  fault(0, "merge types") | SKIP );
              t:= merge types(ra, t, cond)
            )
          OUT  merge types(b, a, cond)
          ESAC,
        (REF TSTRING  tsa)
          CASE b IN
            (REF TSTRING tsb)
            ( t:= tsr:= HEAP TSTRING:= tsa;
              tstring OF tsr:=merge types(tstring OF tsa, tstring OF tsb, cond);
              IF CASE size OF tsa IN (INT i)
                    CASE size OF tsb IN (INT j) (i /= j)
                    OUT TRUE
                    ESAC
                 OUT  TRUE
                 ESAC
              THEN size OF tsr:= HEAP INTCOND:= (cond, size OF tsa, size OF tsb)
              FI
             ),
            (REF ROW) SKIP,
            (REF ST) SKIP
            OUT merge types(b, a, cond)
          ESAC
        OUT  SKIP
       ESAC
       ELSE t := flt
     FI;
     t
   END;


   PROC cond_type = (TYPE then, else, INTEGER cond) TYPE:
   BEGIN
      TYPE a = GETTYPE(then), b = GETTYPE(else);
      TEST  test;
      namestack := nonames;
      IF (test:= check equals(a, b, FALSE, TRUE, FALSE, 0)) = unknown
      THEN merge types(a, b, cond)
      ELIF test = false
      THEN fp1:= then; fp2:= else;
           namefaultp(CO
      "then delivers type * and else delivers type *, these should be the same"
             CO 70, (fp1, fp2));
           flt
      ELSE else
      FI
   END;

   PROC conc_type = (TYPE left, right, REF BOOL stringbool, REF INT sort) TYPE:
   BEGIN
      TYPE t1 := primtype(left, FALSE),   t2 := primtype(right, FALSE);
      INTEGER i1, i2;
      TEST  test;
      namestack := nonames;
      (t1 |(REF ST rs) t1:= sttorow(rs) | SKIP);
      (t2 |(REF ST rs) t2:= sttorow(rs) | SKIP);
      CASE t1 IN
      (REF TSTRING ts)
         CASE t2 IN
         (REF ROW) SKIP
         OUT (t1 := HEAP ROW := (tstring OF ts, size OF ts);
              stringbool := TRUE )
         ESAC
      OUT SKIP
      ESAC;
      CASE t2 IN
      (REF TSTRING ts)
         CASE t1 IN
         (REF ROW) IF stringbool
                   THEN t2:= HEAP ROW:= (tstring OF ts, size OF ts)
                   FI
        OUT (t2 := HEAP ROW := (tstring OF ts, size OF ts);
             stringbool := TRUE )
        ESAC
      OUT SKIP
      ESAC;
      CASE t1 IN
      (REF ROW r1)
      (  ( t2 | (FLT f) GOTO out | SKIP );
         IF equals(t OF r1, t2)       {{{ does not output checks if unknown }}}
         THEN check equals(t OF r1, t2, TRUE, FALSE, FALSE, 0);
                                                {{ outputs unknown checks }}
              t1:= t OF r1; i1:= size OF r1; i2:= 1; sort:= flattenleft; GOTO ok
         FI;
         CASE t2 IN
         (REF ROW r2)
            IF equals(t OF r1, t OF r2)
            THEN  check equals(t OF r1, t OF r2, TRUE, FALSE, FALSE, 0);
                  t1:= t OF r1; i1:= size OF r1; i2:= size OF r2;
                  sort:= flattenboth;
                  GOTO ok
            FI
         OUT SKIP
         ESAC
      ),
      (FLT f) GOTO out
      OUT SKIP
      ESAC;
      CASE t2 IN
      (REF ROW r2)
         IF equals(t1, t OF r2)
         THEN check equals(t1, t OF r2, TRUE, FALSE, FALSE, 0);
              i1:= size OF r2; i2:= 1; sort:= flattenright; t1:= t OF r2;
                                                CO put back typename CO
             GOTO ok
         FI,
      (FLT f) GOTO out
      OUT SKIP
      ESAC;
      IF errorswitch
      THEN fp1:= left; fp2:= right;
           namefaultp(CO"* and * cannot be concatenated"CO 65, (fp1, fp2))
      FI;
out:  flt
      EXIT
ok:  IF stringbool
     THEN HEAP TSTRING := (simplify(HEAP INTDOP:= (diplus, i1, i2), TRUE), t1)
     ELSE HEAP ROW := (t1, simplify(HEAP INTDOP:= (diplus, i1, i2), TRUE))
     FI
   END;

      ctypetotype := (CTYPE ct)TYPE:
      (  TYPE ty, ty2; INTEGER i1;
         PROC csttost = (REF CST cst)REF ST:
         (  IF cst IS nilcst THEN NIL ELSE
               HEAP ST:= (ctypetotype(cst OF cst), csttost(rest OF cst) )
            FI
         );
         CASE ct IN
         (REF CNAMED cnd)  CASE t OF cnd IN
                           (UNSET) ctypetotype(ct OF cnd)
                           OUT t OF cnd
                           ESAC,
         (REF CPRANGE cpr) t OF cpr,
         (REF CPINDEX cpi) t OF cpi,
         (REF PRIMID p) type OF p,
         (REF CUNN cu) type OF p OF cu,
         (REF CROW cr) HEAP ROW:= (ctypetotype(ct OF cr), size OF cr),
         (REF CST cs) csttost(cs),
         (REF CALTS ca) ctypetotype(calt OF ca),
         (REF CNULLT cn) ct OF cn,
         (REF CQUERY cq) querytype OF cq,
         (REF CBRACKET cb) MAKETBRACKET (ctypetotype(cbracket OF cb)),
         (REF CPCHAR ch) t OF ch,
         (REF CPSTRING cs) HEAP TSTRING := (size OF cs, ctypetotype(ct OF cs)),
         (REF CPCHRANGE cr) t OF cr,
         (REF CTYPEVAR cv) t OF cv,
         (REF CINDEX ci)
            ( ty := ctypetotype(ct OF ci);
              trimorindex(ty, 0, index OF ci, index OF ci, index OF ci)
            ),
         (REF CTRIM ct)
            ( ty := ctypetotype(ct OF ct);
              i1 := simplify( HEAP INTDOP := (diplus,
                      HEAP INTDOP := (diminus, upb OF ct, lwb OF ct), 1), TRUE);
              trimorindex(ty, i1, lwb OF ct, lwb OF ct, upb OF ct)
            ),
         (REF CCOND cc)
            ( ty := ctypetotype(then OF cc);
              ty2 := ctypetotype(else OF cc);
              cond_type(ty, ty2, test OF cc)
            ),
         (REF CREPL cp)
            ( REF INTVARMULT repl = get_intvarmult(ids OF cp);
              i1 := simplify( HEAP INTDOP :=
                (diplus, HEAP INTDOP:= (diminus, upb OF repl, lwb OF repl), 1),
                 TRUE);
              HEAP ROW := (ctypetotype(ct OF cp), i1)
            ),
         (REF CATTR ca)  ctypetotype(ct OF ca),
         (CVOID) typevoid,
         (FLT f) f
         OUT SKIP
         ESAC
      );


      PROC reformindex = (TYPE ty, REF INT n, REF TYPE elem_type, REF TEST test) VOID:
      (  REF ST s; INT oldvalue, noelts, rowsize;
         IF n > 0
         THEN CASE ty IN
              (REF PRIMSET tp)
                 (IF n = 1
                  THEN elem_type := tp; n := 0
                  ELSE n MINUSAB 1
                  FI ),
              (REF NAMED tn)
                 (reformindex(t OF tn, n, elem_type, test) ),
              (REF ST ts)
                 (s := ts;
                  reformindex(t OF ts, n, elem_type, test);
                  WHILE (s := rest OF s) ISNT nilst
                    DO reformindex(t OF s, n, elem_type, test) OD
                 ),
              (REF ROW tr)
                 (oldvalue := n;
                  reformindex( t OF tr, n, elem_type, test);
                  noelts := (oldvalue - n);
                  rowsize := CASE simplify_int(size OF tr) IN
                             (INT i) (i)
                             OUT (test := unknown; 1)
                             ESAC;
                  rowsize := noelts * (rowsize - 1);
                  IF n > rowsize OREL rowsize = 0
                  THEN n MINUSAB rowsize
                  ELIF n = 0
                  THEN n := 0
                  ELSE n := n MOD noelts;
                       IF n = 0 THEN n := noelts FI;
                       reformindex( t OF tr, n, elem_type, test)
                  FI),
               (REF FNTYPE tf)
                  (IF n = 1
                     THEN elem_type := tf; n := 0
                     ELSE n MINUSAB 1
                   FI
                  ),
               (REF TYPEVAR tv)
                  (CASE t OF tv IN
                   (TNULL) (test := unknown; n := 0)
                   OUT reformindex(t OF tv, n, elem_type, test)
                   ESAC ),
               (REF TBRACKET tb)
                   reformindex(tbracket OF tb, n, elem_type, test),
               (REF TSTRING ts)
                  (IF n = 1
                   THEN  elem_type := ts;
                         n := 0
                   ELSE  n MINUSAB 1
                   FI )
                 {{ Include if REFORM is to flatten STRING }}
{{               (oldvalue := n;
                  reformindex( tstring OF ts, n, elem_type, test);
                  noelts := (oldvalue - n);
                  rowsize := CASE simplify(size OF ts, TRUE) IN
                             (INT i) (i)
                             OUT (test := unknown; 1)
                             ESAC;
                  rowsize := noelts * (rowsize - 1);
                  IF n > rowsize OREL rowsize = 0
                  THEN n MINUSAB rowsize
                  ELIF n = 0
                  THEN n := 0
                  ELSE n := n MOD noelts;
                       IF n = 0 THEN n := noelts FI;
                       reformindex( tstring OF ts, n, elem_type, test)
                  FI)
}}
               OUT SKIP
               ESAC
          FI
      );

      PROC reformcheck = (TYPE type1, type2) TEST:
      (  TYPE elem_type1, elem_type2;
         TEST state1, state2, same := true;
         INT n1 := 0, n2 := 0;
         FOR i WHILE n1 = 0 AND n2 = 0 AND (same = true)
         DO state1 := state2 := true;
            elem_type1 := type1; elem_type2 := type1;
            n1 := i; n2 := i;
            reformindex(type1, n1, elem_type1, state1);
            reformindex(type2, n2, elem_type2, state2);
            IF state1 = unknown OREL state2 = unknown
            THEN same := unknown
            ELIF NOT equals(elem_type1, elem_type2)
            THEN same := false
            FI
         OD;
         same
      );

   PROC impl_macro = (TYPE a, b, REF FNCALLSTACK fncallstack) BOOL:
     implicit_macro(a, b, fncallstack, simplify, fault, sttorow);


   PROC setup_compilefn = VOID:
   compilefnstack := HEAP COMPILEFNSTACK
                  := (HEAP COMPILEFN :=
                       (fndec,
                        HEAP COMPINT:=
                          (macsort, vss, maxvss, k, which,
                           scope, lastop, lastcall, errorswitch,
                           lhsjoin, joinstack, joinst, joinup,
                           joinvarstack,
                           joinmultstack, joinvarst
                           ),
                        HEAP COMPTYP:= (integer, type, jointype, sts),
                        HEAP COMPSTA:=
                          (fncallstack, lastops, lastcalls, decids,
                           mltype, nextmltype, multlets, multiassign),
                        HEAP COMPREM:= (decnocheck, portinfo, portstack)
                       ),
                      compilefnstack);

   PROC reset_compilefn = VOID:
   ( IF compilefnstack ISNT nilcompilefnstack
      THEN nonunitbody := FALSE;
           nooutput := FALSE;
           fndec := fndec OF val OF compilefnstack;
           REF COMPINT cint = cint OF val OF compilefnstack;
           REF COMPTYP ctyp = ctyp OF val OF compilefnstack;
           REF COMPSTA csta = csta OF val OF compilefnstack;
           REF COMPREM crem = crem OF val OF compilefnstack;
           compilefnstack := rest OF compilefnstack;
           macsort := macsort OF cint;
           vss := vss OF cint;
           maxvss := maxvss OF cint; k := k OF cint; which := which OF cint;
           scope := scope OF cint;
           lastop := lastop OF cint;
           lastcall := lastcall OF cint;
           errorswitch := errorswitch OF cint;
           lhsjoin := lhsjoin OF cint;
           joinstack := joinstack OF cint; joinst := joinst OF cint;
           joinup := joinup OF cint;
           joinvarstack := joinvarstack OF cint;
           joinmultstack := joinmultstack OF cint;
           joinvarst := joinvarst OF cint;
           integer := integer OF ctyp;
           type := type OF ctyp;
           jointype := jointype OF ctyp;
           sts := sts OF ctyp;
           fncallstack := fncallstack OF csta;
           lastops := lastops OF csta;  lastcalls := lastcalls OF csta;
           decids := decids OF csta;
           mltype := mltype OF csta; nextmltype := nextmltype OF csta;
           multlets := multlets OFcsta;
           multiassign := multiassign OFcsta;
           decnocheck := decnocheck OF crem;
           portinfo := portinfo OF crem; portstack := portstack OF crem
        FI
       );

   PROC default = (INT last_fnno, REF IDS dids, REF FNS dfns) VOID:
   ( k := 0;
     which := 0;
     vss := 0;
     maxvss := 0;
     errorswitch := FALSE;
     attr := attrnull;
     attrstr := nilattrstr;
     nextattr := attrstr;
     strings := nilstringlist;
     nextstring := strings;
     inarith := FALSE;
     specinput := TRUE;
     decnocheck := nildecnocheck;
     macsort := flt_par;
     fncallstack := NIL;
     lastcall := nullid;
     nooutput := FALSE;
     nonunitbody := FALSE;
     ioid := FALSE;
     lhsjoin := TRUE;
     joinstack := niljoinstack;
     joinst := niljoinst;
     joinup := HEAP JOINED := jfalse;
     joinvarstack := niljoinvarstack;
     joinmultstack := niljoinmultstack;
     joinvarst := niljoinst;
     lastops := nillastops;
     lastcalls := nillastcalls;
     charalts := nilcharalts;
     FORALL i IN charcheck DO i := FALSE OD;
     delaytype := constint;
     ids := dids;
     fns := dfns;
     decs := nildecs;
     type := o;
     jointype := o;
     integer :=0;
     palts1 := nilpalts;
     cstr := nilcst;
     decids := nilids;
     mltype := nilst;
     nextmltype := mltype;
     multlets := nilmultlets;
     multiassign := nilmultlets;
     idinfo := (0, 0, TRUE, FALSE, TRUE, FALSE, nullid, flt);
     scope := IF last_fnno /= -1 THEN last_fnno ELSE 0 FI;
     portinfo := flt;
     portstack := nilportstack
   );


      PROC charunused = (INT c)BOOL:
      IF NOT charcheck[c]
         THEN charcheck[c] := TRUE; TRUE
         ELSE FALSE
      FI;

    PROC check_charrange = (INT start, finish) BOOL:
    ( CHARSET c1 = charset[start],
              c2 = charset[finish];
      IF type OF c1 /= type OF c2
      THEN IF (type OF c1) = bold OREL (type OF c1) = letter
              OREL (type OF c1) = digit
           THEN fp3 := HEAP VECTOR [2] CHAR:= ("'", charval);
                IF type OF c1 = bold
                THEN fp4 := HEAP VECTOR [20]CHAR := "an upper case letter"
                ELIF type OF c1 = letter
                THEN fp4 := HEAP VECTOR [19] CHAR := "a lower case letter"
                ELSE fp4 := HEAP VECTOR [8] CHAR := "a number"
                FI;
                faultp(2, (fp3, fp4)CO"* wont fit * would"CO)
            FI;
            FALSE
       ELIF value OF c1 > value OF c2
       THEN fault(143, nullmsg
                  CO" character range must be defined sequentially"CO);
            FALSE
       ELSE TRUE
       FI
     );

      PROC charsubrange = (INT start, finish, REF CHARALTS charalts) BOOL:
      ( BOOL is_contiguous := TRUE;
        REF CHARALTS alts := charalts;
        BOOL looking := FALSE;
        INT value := start-1;
        WHILE is_contiguous ANDTH (value < finish) ANDTH (alts ISNT nilcharalts)
        DO CASE alts OF alts IN
           (CHAR c)
              ( IF ABS c = start THEN looking := TRUE FI;
                IF looking ANDTH ((value PLUSAB 1) /= ABS c)
                THEN is_contiguous := FALSE
                FI
              ),
           (CHARRANGE cr)
              ( INT lwb := ABS (lwchar OF cr);
                INT upb = ABS (upchar OF cr);
                IF NOT looking ANDTH (start >= lwb) ANDTH (start <= upb)
                THEN looking := TRUE;
                     lwb := start
                FI;
                IF looking
                THEN IF ((value PLUSAB 1) /= lwb)
                     THEN is_contiguous := FALSE
                     ELIF finish < upb
                     THEN value := finish
                     ELSE value := upb
                     FI
                FI
              )
           ESAC;
           alts := rest OF alts
        OD;
        is_contiguous ANDTH looking ANDTH (value = finish)
      );


    PROC defaultids = (ID id) REF IDS:
    ( INT fnno = IF cfnno = 0 THEN 0 ELSE fnno OF fndec FI;
      HEAP IDS := (HEAP IDINFO := (fnno, 0, TRUE,FALSE,TRUE, FALSE, id, notdec),
                   TRUE, attrnull, nilids)
    );

    PROC defaultfndec = (ID id, BOOL macro, INT sort, fnno, fndecsort)REF FNDEC:
    ( BOOL outer = (fndecsort = outerdec);
      HEAP FNINFO fi :=
          ((outer |0|cfnno), (outer |vnno|0), sort, TRUE, FALSE, FALSE, FALSE);
      HEAP FNDEC fd := (fi, fndecsort, fnno, macro, id, 0, nilmparams, NIL,
                        attrnull, nildecs, nildecs, o, o, 0);
      nextmp OF fd := mp OF fd;
      fd
    );

      PROC scope_start = (INT scope) BOOL:
        (scope = textstart) OREL (scope = vvarmult) OREL (scope = seqvarmult)
        OREL (scope = vpar) OREL (scope = vseq) OREL (scope = fnstart);

      PROC  id_in_scope = (ID id, REF SCOPESTACK scopestack, BOOL decl) REF IDS:
      BEGIN
         BOOL found := FALSE ;
         REF SCOPESTACK s := scopestack;
         WHILE (s ISNT nilscope) ANDTH NOT scope_start(scope OF s)
           DO s := rest OF s OD;
         REF IDS i := ids;
         WHILE NOT found ANDTH (i ISNT nilids)
                   ANDTH ((s IS nilscope) OREL (REF IDS(ids OF s) ISNT i))
         DO IF (id OF idinfo OF i = id)
                   ANDTH ( (decl ANDTH declaration OF i) OREL NOT decl )
            THEN found := TRUE
            ELSE i := rest OF i
            FI
         OD;
         IF found THEN i ELSE defaultids(id) FI
      END;


      PROC fn_in_scope = (ID id, REF FNS fns, REF SCOPESTACK scopestack,
                                                           BOOL decl) REF FNS:
      BEGIN
         BOOL found := FALSE ;
         REF SCOPESTACK s := scopestack;
         WHILE (s ISNT nilscope) ANDTH NOT scope_start(scope OF s)
           DO s := rest OF s OD;
         REF FNS f := fns;
         WHILE NOT found ANDTH (f ISNT nilfns)
                   ANDTH ((s IS nilscope) OREL (REF FNS(fns OF s) ISNT f))
         DO IF (id OF fndec OF f = id)
                   ANDTH ( (decl ANDTH declaration OF f) OREL NOT decl )
            THEN found := TRUE
            ELSE f := rest OF f
            FI
         OD;
         IF found THEN f
         ELSE HEAP FNS := (defaultfndec(id, FALSE, fn_notdec, cfnno, localdec),
                           TRUE, nilfns)
         FI
      END;


      PROC containslocaltype = (TYPE t, REF SCOPESTACK s) BOOL:
         CASE t IN
         (REF PRIMSET p)
            CASE u OF idinfo OF id_in_scope(id OF idinfo OF p, s, TRUE) IN
            (TYPEID td) CASE t OF td IN
                        (REF PRIMSET ps) typeno OF ps = typeno OF p
                        OUT FALSE
                        ESAC
            OUT FALSE
            ESAC,
         (REF NAMED n)   containslocaltype(t OF n, s),
         (REF TYPEVAR v) containslocaltype(t OF v, s),
         (REF ST st)     (st ISNT nilst) ANDTH
                            (containslocaltype(t OF st, s) OREL
                             containslocaltype(rest OF st, s)),
         (REF ROW r)     containslocaltype(t OF r, s),
         (REF FNTYPE f)  containslocaltype(from OF f, s) OREL
                         containslocaltype(to OF f, s),
         (REF TBRACKET tb) containslocaltype(tbracket OF tb, s),
         (REF TSTRING ts) containslocaltype(tstring OF ts, s)
         OUT FALSE
      ESAC;


      PROC findid = (ID id) REF IDS:
      BEGIN
         REF IDS fid = id_in_scope(id, nilscope, FALSE);
         IF scope OF idinfo OF fid =-1 THEN
             CASE u OF idinfo OF fid IN
             (TYPEID t) setexttype(t OF t),
             (PRIMID p) setexttype(type OF p),
             (INTID ind) setextint(i OF ind),
             (ATTRID ad) setextattr(a OF ad),
             (CTYPEID c) setextctype(ct OF c)
             OUT SKIP
             ESAC;
             scope OF idinfo OF fid:= 0
         FI;
         fid
      END;

      PROC findfn = (ID id, REF FNS fns) REF FNS:
      (  REF FNS f1 = fn_in_scope(id, fns, nilscope, FALSE);
         REF FNDEC fd = fndec OF f1;
         IF scope OF fninfo OF fd = -1
         THEN scope OF fninfo OF fd := 0;
              IF status OF fninfo OF fd /= fn_flt
              THEN fnno OF fd:= cfnno PLUSAB 1;
                   setextddecs(inputs OF fd); setextddecs(outputs OF fd)
              FI
         FI;
         f1
      );


      PROC newid = (ID id, IDUNION i) VOID:
      (  INT fnno = IF cfnno = 0 THEN 0 ELSE fnno OF fndec FI;
         ids:= HEAP IDS:=
         ( HEAP IDINFO :=
           ((fnno = 0|-1|fnno),(fnno = 0|vnno|0),TRUE,FALSE,TRUE,FALSE,id,i),
           TRUE, attrnull, ids)
      );


      PROC newscope = (INT scope, REF IDS ids, REF FNS fns) VOID:
      (  scopestack := HEAP SCOPESTACK := (scope, ids, fns, scopestack)
      );

      PROC usedid = (REF IDS item, REF SCOPESTACK scopestack) VOID:
      (  REF IDS is = id_in_scope(id OF idinfo OF item, scopestack, FALSE);
         CASE u OF idinfo OF is IN
         (NOTDEC)  {ie NOT found}
                  ids := HEAP IDS := (idinfo OF item, FALSE, attrnull, ids)
         OUT SKIP
         ESAC
      );

      PROC usedfn = (REF FNS item, REF SCOPESTACK scopestack) VOID:
      (  REF FNS fs = fn_in_scope(id OF fndec OF item, fns, scopestack, FALSE);
         IF status OF fninfo OF fndec OF fs = fn_notdec {ie NOT found}
         THEN fns := HEAP FNS := (fndec OF item, FALSE, fns)
         FI
      );

      PROC testequals = (TYPE a, b, BOOL output check) BOOL:
      (  TEST result = check equals(a, b, output check, FALSE, FALSE, 0);
         BOOL ans = ( output check | NOT(result=false) | (result=true) );
         namestack := nonames;
         IF NOT ans
         THEN  fp1:= a; fp2:= b;
               namefaultp(CO"* and * are different types"CO 3, (fp1, fp2));
               type:= flt
         FI;
         ans
      );

PROC join_setup = (TYPE t, BOOL source)JOINUP:
IF source ANDTH (NOT containsfntype(t))
   THEN HEAP JOINED := jtrue
   ELSE CASE t IN
        (REF NAMED n) join_setup(t OF n, source),
        (REF FNTYPE f) (HEAP JOINFN jfn;
                        joined OF jfn := HEAP JOINED := jfalse; jfn),
        (REF ROW r) ( INT size = GIVEINT(size OF r);
                     HEAP JOINROW joinrow;
                     REF VECTOR [] JOINUP bb;
                     IF size < 1
                       THEN HEAP JOINED := jcheck
                       ELSE bb := HEAP VECTOR [size]JOINUP;
                            FOR i TO size
                            DO bb[i] := HEAP JOINUP := join_setup(t OF r, source) OD;
                            jrow OF joinrow := bb;
                            joinrow
                     FI
                    ),
        (REF ST s) (PROC join_st = (REF ST st)REF JOINST:
                    IF st ISNT nilst
                      THEN HEAP JOINST
                              := (HEAP JOINUP := join_setup(t OF st, source),
                                                       join_st(rest OF st))
                      ELSE NIL
                    FI;
                    join_st(s)
                   ),
        (REF TSTRING ts) join_setup(HEAP ROW := (tstring OF ts,size OF ts),
                                                                     source),
        (REF TBRACKET tb) join_setup(tbracket OF tb, source),
        (TVOID) HEAP JOINED := jvoid,
        (TNULL) HEAP JOINED := jfault,
        (FLT f) flt
          OUT HEAP JOINED := IF source THEN jtrue ELSE jfalse FI
        ESAC
FI;

      PROC makedecs = (REF DDECS d, INT origin, REF FNDEC fd)VOID:
      (
         PROC makeids = (TYPE t, INT wherefrom, REF IDS i)VOID:
         (  TYPE idtype := primtype(t, FALSE);
            INT bsource =
               IF (wherefrom /= outputtok) THEN vnamesource ELSE vnamesink FI;
            INT bsink =
               IF (wherefrom /= outputtok) THEN vnamesink ELSE vnamesource FI;
            IF i ISNT nilids
            THEN
               makeids(t, wherefrom, rest OF i);
               setidunn(idinfo OF i,
                        HEAP DECIDS :=
                          (num_names OF fd PLUSAB 1, wherefrom, makeint, t,
                           join_setup(setiotype(idtype, bsource), TRUE),
                           join_setup(setiotype(idtype, bsink), FALSE),
                           flt, flt
                          ))
            FI
         );
         IF d ISNT nildecs THEN
            makedecs(rest OF d, origin, fd);
            makeids(t OF d, origin, ids OF d)
         FI
      );



PROC check_joined = (REF JOINUP j)BOOL:
(PROC check_all_jst = (REF JOINST js) BOOL:
 IF js ISNT niljoinst
   THEN check_joined(jst OF js) ANDTH check_all_jst(rest OF js)
   ELSE TRUE
 FI;
 PROC test1 = (REF JOINED jnd)BOOL:
 IF jnd JOINEQUAL jfalse THEN FALSE ELSE TRUE FI;
 CASE j IN
  (REF JOINST jst) check_all_jst(jst),
  (REF JOINFN jfn) test1(joined OF jfn),
  (REF JOINIO jio) check_joined(source OF jio) ANDTH check_joined(sink OF jio),
  (REF JOINROW jr) (BOOL ans := TRUE;
                    IF UPB (jrow OF jr) < 1
                       THEN SKIP
                       ELSE FOR i TO UPB (jrow OF jr)
                            DO ans:= ans ANDTH check_joined((jrow OF jr)[i]) OD
                    FI;
                    ans
                   ),
  (REF JOINREP jr) check_joined(jrep OF jr),
  (REF JOINED b) test1(b)
   OUT TRUE  {{ if fault assume joined }}
 ESAC
);


PROC check_if_joined = (REF JOINUP j)BOOL:
(PROC check_all_jst = (REF JOINST js) BOOL:
 IF js ISNT niljoinst
   THEN check_if_joined(jst OF js) OREL check_all_jst(rest OF js)
   ELSE FALSE
 FI;
 PROC test2 = (REF JOINED jnd)BOOL:
 IF jnd JOINEQUAL jtrue THEN TRUE ELSE FALSE FI;
 CASE j IN
  (REF JOINST jst) check_all_jst(jst),
  (REF JOINFN jfn) test2(joined OF jfn),
  (REF JOINIO jio) check_if_joined(source OF jio) ANDTH
                                          check_if_joined(sink OF jio),
  (REF JOINROW jr) (BOOL ans := FALSE;
                    IF UPB (jrow OF jr) < 1
                       THEN SKIP
                       ELSE FOR i TO UPB (jrow OF jr)
                            DO ans:= ans OREL check_if_joined((jrow OF jr)[i])
                            OD
                    FI;
                    ans
                   ),
  (REF JOINREP jr) check_if_joined(jrep OF jr),
  (REF JOINED b) test2(b)
   OUT FALSE                        {{ if fault assume no joins yet }}
 ESAC
);

PROC has_join_check = (REF JOINUP j)BOOL:
(PROC check_all_jst = (REF JOINST js) BOOL:
 IF js ISNT niljoinst
   THEN has_join_check(jst OF js) OREL check_all_jst(rest OF js)
   ELSE FALSE
 FI;
 PROC test2 = (REF JOINED jnd)BOOL:
 IF jnd JOINEQUAL jcheck THEN TRUE ELSE FALSE FI;
 CASE j IN
  (REF JOINST jst) check_all_jst(jst),
  (REF JOINFN jfn) test2(joined OF jfn),
  (REF JOINIO jio) has_join_check(source OF jio)
                                       ANDTH has_join_check(sink OF jio),
  (REF JOINROW jr) (BOOL ans := FALSE;
                    IF UPB (jrow OF jr) < 1
                       THEN SKIP
                       ELSE FOR i TO UPB (jrow OF jr)
                            DO ans:= ans OREL has_join_check((jrow OF jr)[i])
                            OD
                    FI;
                    ans
                   ),
  (REF JOINREP jr) has_join_check(jrep OF jr),
  (REF JOINED b) test2(b)
   OUT FALSE                        {{ if fault then not check }}
 ESAC
);


PROC check_joins = (IDINFO idinfo)VOID:
CASE u OF idinfo IN
     (REF DECIDS ds)(fp3 := id OF idinfo;
                     IF source_sink_out   {{ only used for debugging }}
                        THEN fault(230, "######");
                             fault(230, fp3);
                             fault(230, "######");
                             print_joinup(jsource OF ds,0);
                             print_joinup(jsink OF ds, 10)
                     FI;
                     IF (type | (FLT f) FALSE | TRUE)
                        THEN IF check_joined(jsource OF ds)
                               THEN IF check_joined(jsink OF ds)
                                       THEN SKIP
                                       ELSE faultp(177, fp3
                                 CO"An input to * needs to be joined to"CO)
                                    FI
                               ELSE IF check_joined(jsink OF ds)
                                       THEN faultp(178, fp3
                                          CO"An output of * needs joining"CO)
                                       ELSE faultp(179, fp3
                           CO"Both an input and output of * need joining"CO)
                                    FI
                             FI
                     FI;
                     CASE u OF idinfo IN
                         (REF DECIDS dids)
                            IF has_join_check(jsource OF dids) OREL
                                              has_join_check(jsink OF dids)
                               THEN decnocheck := HEAP DECNOCHECK
                                               := (decno OF dids, decnocheck)
                            FI
                         OUT SKIP
                     ESAC)
       OUT SKIP
ESAC;

PROC is_fntype_joined = (REF JOINUP j)BOOL:
CASE j IN
   (REF JOINFN jfn) IF (joined OF jfn) JOINEQUAL jtrue THEN TRUE ELSE FALSE FI,
   (REF JOINIO jio) is_fntype_joined(source OF jio)
                        OREL check_if_joined(sink OF jio),
   (REF JOINROW jr) (BOOL ans := FALSE;
                     FOR i TO UPB (jrow OF jr)
                     DO ans := ans OREL is_fntype_joined((jrow OF jr)[i]) OD;
                     ans),
   (REF JOINST js) ( REF JOINST jst := js;
                     BOOL ans := FALSE;
                     WHILE jst ISNT niljoinst
                     DO ans := ans OREL is_fntype_joined(jst OF jst);
                        jst := rest OF jst
                     OD;
                     ans),
   (REF JOINREP jr) is_fntype_joined(jrep OF jr)
     OUT FALSE     {{ if fault or check assumed not joined }}
ESAC;

PROC has_fntype = (REF JOINUP j)BOOL:
CASE j IN
   (REF JOINFN jfn) TRUE,
   (REF JOINIO jio) TRUE,
   (REF JOINROW jr) (BOOL ans := FALSE;
                     FOR i TO UPB (jrow OF jr)
                     DO ans := ans OREL has_fntype((jrow OF jr)[i]) OD;
                     ans),
   (REF JOINST js) ( REF JOINST jst := js;
                     BOOL ans := FALSE;
                     WHILE jst ISNT niljoinst
                     DO ans := ans OREL has_fntype(jst OF jst);
                        jst := rest OF jst
                     OD;
                     ans),
   (REF JOINREP jr) has_fntype(jrep OF jr)
     OUT FALSE     {{ if fault or check assumed no fntype }}
ESAC;

PROC check_if_output_joined = (REF DDECS outputs)BOOL:
BEGIN
   BOOL outputs_joined := FALSE;
   REF DDECS outdecs := outputs;
   WHILE (outdecs ISNT nildecs)  ANDTH NOT outputs_joined
   DO REF IDS idsout := ids OF outdecs;
      WHILE (idsout ISNT nilids) ANDTH NOT outputs_joined
      DO CASE u OF idinfo OF idsout IN
         (REF DECIDS ds)
             outputs_joined := is_fntype_joined(jsource OF ds) OREL
                               check_if_joined(jsink OF ds)
         OUT SKIP
         ESAC;
         idsout := rest OF idsout
      OD;
      outdecs := rest OF outdecs
   OD;
   outputs_joined
END;

PROC mark_join = (REF JOINUP joinup, JOINED jtest, BOOL source)VOID:
(PROC set_check =(REF JOINED jnd, BOOL isfn)JOINED:
 CASE type IN
   (FLT f) jfault
    OUT  IF jtest JOINEQUAL jfault
           THEN jfault
           ELIF jtest JOINEQUAL jcheck
             THEN jcheck
             ELSE IF (isfn OREL (NOT source)) ANDTH (jnd JOINEQUAL jtrue)
                     THEN fault(180, nullmsg
                           CO"You have already joined to an element here"CO);
                          jtrue
                     ELIF (jnd JOINEQUAL jfalse)
                         THEN jtrue
                         ELSE jnd
                  FI
         FI
 ESAC;
 CASE joinup IN
   (REF JOINFN jfn) joined OF jfn := HEAP JOINED
                                  := set_check(joined OF jfn,TRUE),
   (REF JOINIO jio) (mark_join(source OF jio,jtest,TRUE);
                     mark_join(sink OF jio,jtest,FALSE)),
   (REF JOINROW jr) FOR i TO UPB (jrow OF jr)
                    DO mark_join((jrow OF jr)[i],jtest,source) OD,
   (REF JOINST js) (PROC mark_jst = (REF JOINST jss)VOID:
                    IF jss ISNT niljoinst
                      THEN mark_join(jst OF jss,jtest,source);
                           mark_jst(rest OF jss)
                    FI;
                    mark_jst(js)
                   ),
   (REF JOINREP jr) mark_join(jrep OF jr, jtest, source),
   (REF JOINED b) b := set_check(b,FALSE)
     OUT SKIP
 ESAC
);

PROC check_off = (REF JOINUP jup, BOOL source, output)VOID:
CASE type IN
  (FLT f) mark_join(jup, jfault, TRUE)
  OUT IF output
      THEN mark_join(jup, jfalse, source)
      ELIF is_fntype_joined(jup)
      THEN fault(181, nullmsg CO"You have already joined to a fntype here"CO)
      ELIF (NOT source) ANDTH check_if_joined(jup)
      THEN fault(182, nullmsg
                     CO"You have already supplied part or all of the input"CO)
      ELSE mark_join(jup, jfalse, source)
      FI
ESAC;

PROC joinsttorow = (REF JOINST jst)JOINUP:
( INT count := 0;
  PROC jcount = (REF JOINST js)VOID:
  IF js ISNT niljoinst THEN count PLUSAB 1; jcount(rest OF js) FI;
  jcount(jst);
  REF VECTOR [] JOINUP jup := HEAP VECTOR [count]JOINUP;
  count PLUSAB 1;
  PROC jass = (REF JOINST js)VOID:
  IF js ISNT niljoinst THEN jass(rest OF js);
                            jup[count MINUSAB 1]:= HEAP JOINUP := jst OF js
  FI;
  jass(jst);
  HEAP JOINROW jr;
  jrow OF jr := jup;
  jr
);


PROC get_size = (JOINUP jup)INT:
CASE jup IN
   (REF JOINROW jr) UPB(jrow OF jr),
   (REF JOINST js) (REF JOINST jstr := js;
                    INT size := 0;
                    WHILE jstr ISNT niljoinst
                    DO size PLUSAB 1; jstr := rest OF jstr OD;
                    size
                   ),
   (REF JOINIO jio) (INT left := get_size(source OF jio),
                         right:= get_size(sink OF jio);
                     IF left = -1 THEN right
                       ELIF right = -1 THEN left
                       ELIF left < right THEN left
                       ELSE right
                     FI
                    ),
   (REF JOINREP jr) get_size(jrep OF jr)
         OUT -1
ESAC;

PROC trim_error = (REF INTEGER lwb, upb, INT size) TEST:
( fp5:= lwb;   fp6:= upb;  fp0:= size;
  BOOL isindex = ((GIVEINT lwb) = (GIVEINT upb));
  (test OF test ints(checkge, lwb, 1,
                  IF isindex
                  THEN CO"[*] ?  this index is too small"CO 35
                  ELSE CO"[*..*] ?  the lower limit is too small"CO 59
                  FI,
                  IF isindex THEN fp5 ELSE (fp5, fp6) FI, 0) )
  AND
  (test OF test ints(checkle, upb, size,
                  IF isindex
                  THEN CO"[*] ?  this index can t exceed *"CO 41
                  ELSE CO"[*..*] ?  the upper limit can t exceed *"CO 60
                  FI,
                  IF isindex THEN (fp5, fp0) ELSE (fp5, fp6, fp0) FI,
                  0) )
  AND
    ( (TESTBOOL(isindex)) OR
           (test OF test ints(checkge, upb, UNCHECKEDINT lwb,
                CO"[*..*] ?  you must trim at least one item"CO
                61, (fp5, fp6), 0)) )
);


PROC gettrim = (REF JOINUP jup, INT lwb, upb) JOINUP:
CASE jup IN
(REF JOINROW jr)
   ( HEAP JOINROW jrr;
     IF lwb >0 ANDTH upb > 0
     THEN  IF lwb <upb ANDTH upb <= UPB(jrow OF jr)
           THEN jrow OF jrr := HEAP VECTOR [upb-lwb+1]JOINUP
                                           := (jrow OF jr)[lwb:upb];
                jrr
           ELIF (lwb=upb) ANDTH upb <= UPB(jrow OF jr)
           THEN (jrow OF jr)[lwb]
           ELSE  mark_join(jup, jfault, FALSE);
                 flt
           FI
      ELSE mark_join(jup, jcheck, FALSE); flt
      FI
    ),
(REF JOINST jstr)
   ( PROC jtrim = (REF JOINST jst, INT i)REF JOINST:
        IF jst IS niljoinst
        THEN NIL
        ELIF i>1
        THEN HEAP JOINST := (jst OF jst,jtrim(rest OF jst,i-1))
        ELSE HEAP JOINST := (jst OF jst, niljoinst)
        FI;

     IF lwb >0 ANDTH upb > 0
     THEN  REF JOINST js := jstr;
           TO lwb -1 WHILE js ISNT niljoinst DO js := rest OF js OD;
           IF js IS niljoinst
           THEN mark_join(jup, jfault, FALSE);
                flt
           ELIF lwb=upb
           THEN jst OF js
           ELSE jtrim(js, upb-lwb+1)
           FI
      ELSE mark_join(jup, jcheck, FALSE);
           flt
      FI
   ),
(REF JOINIO jio)
   HEAP JOINIO := (gettrim(source OF jio,lwb,upb),
                   gettrim(sink OF jio,lwb,upb)),
(REF JOINREP jr)
   HEAP JOINREP := (gettrim(jrep OF jr,lwb,upb), jvarstack OF jr)
OUT jup
ESAC;


PROC jointrim = (REF JOINUP joinup, INTEGER lwbd, upbd) JOINUP:
( INT lwb, upb;
  lwb :=  CASE simplify(lwbd,TRUE) IN
              (REF INTVAR iv) -1
              OUT GIVEINT lwbd
          ESAC;
  upb := CASE simplify(upbd,TRUE) IN
              (REF INTVAR iv) -1
              OUT GIVEINT upbd
         ESAC;
  gettrim(joinup, lwb, upb)
);

      PROC unscope = (REF REF SCOPESTACK s, REF REF IDS i, REF REF FNS f) VOID:
      (  IF s ISNT nilscope
         THEN WHILE REF IDS (ids OF s) ISNT i
              DO  IF NOT (syntaxerror OREL nonunitbody) ANDTH declaration OF i
                  THEN  CASE u OF idinfo OF i IN
                        (FLT f) (SKIP)
                        OUT  check_joins(idinfo OF i)
                        ESAC
                  FI;
                  i := rest OF i   { removes from global list }
              OD;
              WHILE REF FNS(fns OF s) ISNT f
              DO  f := rest OF f  OD { removes from global list }
         FI;
         s := rest OF s  { removes from global list }
      );

    PROC makevardecs = (REF DDECS d, REF FNDEC fd)VOID:
      ( PROC makeids = (TYPE t, REF IDS i)VOID:
        ( IF i ISNT nilids
            THEN makeids(t, rest OF i);
                 setidunn(idinfo OF i,
                          HEAP VARID := (t, num_names OF fd PLUSAB 1))
          FI
       );
        IF d ISNT nildecs
          THEN makevardecs(rest OF d, fd);
               makeids(t OF d, ids OF d)
       FI
       );


     PROC decs_flt = (REF REF IDS decids, INT idscount)REF DDECS:
      ( REF IDS d_decs := NIL;
        TO idscount
        DO d_decs := HEAP IDS := (idinfo OF decids, declaration OF decids,
                                  attr OF decids, d_decs);
           decids := rest OF decids
        OD;
        HEAP DDECS := (flt, d_decs, NIL)
      );

      PROC decs_st = (REF IDS decids, REF ST st) REF DDECS:
         IF st IS nilst
         THEN NIL
         ELSE HEAP DDECS :=
                  ( t OF st,
                    HEAP IDS := (idinfo OF decids, declaration OF decids,
                                 attr OF decids, NIL),
                    decs_st(rest OF decids, rest OF st))
         FI;

      PROC decs_setup = (REF IDS d_ids, TYPE t) REF DDECS:
      ( REF IDS decids := d_ids;
        REF DDECS d_decs := nildecs;
        INT idscount := num OF multlets;
        INT multsize := 0;
        IF idscount = 0
        THEN SKIP
        ELIF idscount /= 1
          THEN TYPE t1 := t;
               c: CASE t1 IN
            (REF TBRACKET tb)(t1 := tbracket OF tb; GOTO c ),
            (REF TYPEVAR tv) (t1 := t OF tv; GOTO c),
            (REF TSTRING ts) (t1 := HEAP ROW := (tstring OF ts,size OF ts);
                              GOTO c
                             ),
            (REF ROW trow) ( INT multsize := GIVEINT size OF trow;
                             IF multsize = -1
                               THEN outints((icheck, 1));  {{ "=" }}
                                    loadint(size OF trow, FALSE);
                                    outints((iconst, idscount))
                             FI;
                             IF (multsize /= idscount) ANDTH multsize /= -1
                                THEN d_decs := decs_flt(decids, idscount);
                                     fp5 := multsize;
                                     faultp(158, fp5)
                               CO "left hand side should have * elements" CO

                                ELSE
                                  REF IDS dids := NIL;
                                  REF REF IDS nextids := dids;
                                  TO idscount
                                  DO REF REF IDS (nextids) :=
                                        HEAP IDS := (idinfo OF decids,
                                                     declaration OF decids,
                                                     attr OF decids, NIL);
                                     decids := rest OF decids;
                                     nextids := rest OF nextids
                                 OD;
                               d_decs := HEAP DDECS :=(t OF trow, dids, nildecs)
                             FI
                           ),
            (REF ST str) ( REF ST st := nilst ;
                           REF ST st2 := str;
                           WHILE st2 ISNT nilst
                           DO multsize PLUSAB 1;
                              st := HEAP ST := (t OF st2, st);
                              st2 := rest OF st2
                           OD;
                           IF multsize /= idscount
                                THEN d_decs := decs_flt(decids, idscount);
                                     fp5 := multsize;
                                     faultp(158, fp5)
                                CO "left hand side should have * elements" CO
                                ELSE d_decs := decs_st(decids, st)
                           FI
                          ),
                (REF NAMED nn) (t1 := t OF nn; GOTO c),
                (FLT flt) d_decs := decs_flt(decids, idscount)
              OUT (fault(161, nullmsg
                        CO"you can only have a row or structure here"CO);
                  d_decs := decs_flt(decids, idscount)
                 )
             ESAC
         ELSE  d_decs:= HEAP DDECS := (t,
                        HEAP IDS := (idinfo OF decids, declaration OF decids,
                                     attr OF decids, NIL), nildecs)
       FI;
       d_decs
      );

      PROC pushvss = (INT i)VOID:
      (  vss PLUSAB i; (maxvss<vss | maxvss:= vss)  );


PROC next_mparamno = (REF FNSTACK fnstack) STRUCT 2 INT:
( REF FNDEC dec = dec OF fnstack;
  IF macro OF dec
  THEN (fnno OF dec, mparamno OF dec PLUSAB 1)
  ELSE REF FNDEC nextdec = dec OF rest OF fnstack;
      (fnno OF nextdec, (mparamno OF dec OF rest OF fnstack) PLUSAB 1)
  FI
);

PROC add_mparam = (REF MPARAMS mps, REF FNSTACK fnstack) VOID:
( REF FNDEC dec = dec OF fnstack;
  IF macro OF dec
  THEN REF REF MPARAMS (nextmp OF dec) := mps;
       nextmp OF dec := rest OF nextmp OF dec
  ELSE REF FNDEC nextdec = dec OF rest OF fnstack;
       REF REF MPARAMS (nextmp OF nextdec) := mps;
       nextmp OF nextdec := rest OF nextmp OF nextdec
  FI
);

PROC anyexplicit = (REF MPARAMS mps)BOOL:
IF mps ISNT nilmparams
   THEN (sort OF mps = expl_par) OREL anyexplicit(rest OF mps)
   ELSE FALSE
FI;

PROC nextexpl_par = (REF MPARAMS mps)REF MPARAMS:
(  REF MPARAMS mp := mps;
   WHILE (mp ISNT nilmparams) ANDTH (sort OF mp /= expl_par)
     DO mp := rest OF mp OD;
   mp
);


PROC fncall_flt = (REF FNDEC fd) REF FNCALL:
( HEAP FNDEC flt_fd := fd;
  fninfo OF flt_fd := HEAP FNINFO := fninfo OF flt_fd;
  status OF fninfo OF flt_fd := fn_flt;
  HEAP FNCALL fc := (flt_fd, nilparamvals, NIL, attrnull);
  nextpvals OF fc := pvals OF fc;
  fc
);

PROC inst_has_fn_in = (REF JOINUP j)BOOL:
CASE j IN
   (REF JOINFN jfn) TRUE,
   (REF JOINIO jio) TRUE,
   (REF JOINROW jr) (BOOL ans := FALSE;
                     FOR i TO UPB (jrow OF jr)
                     DO ans := ans OREL inst_has_fn_in((jrow OF jr)[i]) OD;
                     ans),
   (REF JOINST js) ( REF JOINST jst := js;
                     BOOL ans := FALSE;
                     WHILE jst ISNT niljoinst
                     DO ans := ans OREL inst_has_fn_in(jst OF jst);
                        jst := rest OF jst
                     OD;
                     ans),
   (REF JOINREP jr) inst_has_fn_in(jrep OF jr)
     OUT FALSE     {{ if fault or check assumed no fntype input}}
ESAC;

PROC index_rep = (REF JOINREP jrep, INT index) JOINUP:
(  PROC substvarstack = (REF JOINVARSTACK jstack)REF JOINVARSTACK:
   IF jstack ISNT niljoinvarstack
      THEN HEAP JOINVARSTACK := (substvarmult(lwb OF jstack,index),
                                  substvarmult(upb OF jstack,index),
                                   index OF jstack,
                                    substvarstack(rest OF jstack))
      ELSE NIL
   FI;
      REF JOINVARSTACK jstack := substvarstack(jvarstack OF jrep);
      INT int1, int2, size :=0;
      JOINUP ans := jrep OF jrep;
      WHILE jstack ISNT niljoinvarstack
      DO IF ihasvmno(lwb OF jstack) OREL ihasvmno(upb OF jstack)
            THEN ans := HEAP JOINREP := (ans, jstack);
                 GOTO exit
            ELSE int1 := GIVEINT lwb OF jstack;
                 int2 := GIVEINT upb OF jstack;
                 size := get_size(ans);
                 IF size = -1
                    THEN {{ Either a source or wrong type no mark needed }}
                         jstack := niljoinvarstack;
                         ans := flt;
                         GOTO exit
                    ELSE TEST restest:= trim_error(lwb OF jstack, upb OF jstack,
                                                                          size);
                         IF restest = unknown
                            THEN mark_join(ans, jcheck, FALSE);
                                jstack := niljoinvarstack;
                                ans := flt;
                                GOTO exit
                            ELIF restest = false
                            THEN mark_join(ans, jfault, FALSE);
                                 jstack := niljoinvarstack;
                                 ans := flt;
                                 GOTO exit
                            ELSE SKIP
                         FI
                  FI;
                  ans := jointrim(ans, lwb OF jstack, upb OF jstack);
                  jstack := rest OF jstack
           FI
      OD;
exit: ans
);


PROC indexreturn = (JOINUP jup, INT index, BOOL toplevel)JOINUP:
(PROC index_jst = (REF JOINST js) REF JOINST:
 IF js ISNT niljoinst
   THEN HEAP JOINST := (indexreturn(jst OF js, index, toplevel),
                                                       index_jst(rest OF js))
   ELSE NIL
 FI;
CASE jup IN
  (REF JOINFN jf) (IF toplevel
                      THEN fault(210, nullmsg
                                 CO"You cannot replicate a function type"CO)
                   FI;
                   jup),
  (REF JOINIO ji) (IF toplevel
                      THEN fault(211, nullmsg CO"You cannot replicate an IO"CO)
                   FI;
                   jup),
  (REF JOINST jst) index_jst(jst),
  (REF JOINROW jr) (HEAP JOINROW jrr;
                    jrow OF jrr := HEAP VECTOR [UPB (jrow OF jr)] JOINUP;
                    IF UPB (jrow OF jr) > 0
                       THEN FOR i TO UPB (jrow OF jr)
                            DO (jrow OF jrr)[i] :=
                                    indexreturn((jrow OF jr)[i],index,toplevel)
                            OD
                    FI;
                    jrr
                   ),
  (REF JOINREP jr)  index_rep(jr, index)
   OUT jup
 ESAC
);




PROC varmult_joinup = (REF IDDECS iddecs, JOINUP joinup) JOINUP:
(  REF INTVARMULT repl = get_intvarmult(ids OF iddecs);
   IF replknown(repl)
   THEN INT size = (GIVEINT upb OF repl - GIVEINT lwb OF repl + 1);
        IF size > 0
        THEN HEAP JOINROW jrr;
             jrow OF jrr := HEAP VECTOR [size] JOINUP;
             FOR istep WHILE nextrepl(repl)
             DO (jrow OF jrr)[istep]:= indexreturn(joinup, xno OF iddecs, TRUE) OD;
             jrr
        ELSE jfault
        FI
   ELSE JOINUP jj := joinup;
        mark_join(jj, jcheck, lhsjoin);
        HEAP JOINED := jcheck
   FI
);

PROC replicate_joinup = (REF IDS idlist, REF IDDECS iddecs, JOINUP joinup)
                                                                       JOINUP:
(  INT startindex := -1;
   REF SCOPESTACK s := scopestack;
   WHILE (s ISNT nilscope) ANDTH (scope OF s /= fnstart)
     DO s := rest OF s OD;
   REF IDS i := idlist;
   WHILE (i ISNT nilids) ANDTH
           ((s IS nilscope) OREL (REF IDS (ids OF s) ISNT i))
   DO  CASE u OF idinfo OF i IN
       (INTID int) CASE i OF int IN
                   (REF INTVARMULT iv) (startindex := varmultno OF iv)
                   OUT SKIP
                   ESAC
       OUT SKIP
       ESAC;
       i := rest OF i
    OD;
    IF startindex > 0
    THEN  JOINUP ans := joinup;
          REF IDDECS vids := iddecs;
          WHILE (vids ISNT niliddecs) ANDTH xno OF vids >= startindex
          DO  ans := varmult_joinup(vids, ans);
              vids := rest OF vids
          OD;
          ans
    ELSE  joinup
    FI
);


PROC port_setup = (REF DDECS dd, FNCALL fncall) REF PORTDATA:
( INT fnno = fnno OF f OF fncall;
  REF DDECS d := dd;
  REF IDS ids;
  INT index := 0;
  WHILE d ISNT nildecs
  DO ids := ids OF d;
     WHILE ids ISNT nilids DO index PLUSAB 1; ids := rest OF ids OD;
     d := rest OF d
  OD;
  d := dd;
  BOOL single = ( index = 1 );
  REF PORTDATA ans := NIL;
  WHILE d ISNT nildecs
  DO TYPE typ = substtype(fncall, fnno, t OF d);
     ids := ids OF d;
     WHILE ids ISNT nilids
     DO INT nameno = CASE u OF idinfo OF ids IN
                     (REF DECIDS ds) decno OF ds
                     OUT fault(0, "port_setup"); SKIP
                     ESAC;
        ans := HEAP PORTDATA :=
         (id OF idinfo OF ids, fnno, nameno, index, typ, single, ans);
        index MINUSAB 1;
        ids := rest OF ids
     OD;
     d := rest OF d
   OD;
   ans
);


PROC get_port_data = (REF PORTDATA port, ID portname) REF PORTDATA:
IF (rest OF port) IS nilportdata
  THEN IF (id OF port) /= portname
         THEN CASE type IN
               (FLT) SKIP
               OUT fp3:= portname;
                   fault(CO"Portname * cannot be accessed from here"CO 246, fp3)
              ESAC;
              nilportdata
         ELSE port
       FI
   ELIF (id OF port) /= portname
      THEN get_port_data(rest OF port, portname)
      ELSE port
FI;

PROC get_port_info = (REF PORT port, ID portname) REF PORTDATA:
CASE port IN
  (REF PORTDATA pd) get_port_data(pd, portname)
   OUT CASE type IN
          (FLT) SKIP
           OUT fault(CO"you cannot use a portname here"CO 247, nullmsg)
       ESAC;
       nilportdata
ESAC;

PROC rowtype = (TYPE t)TYPE:
CASE t IN
(REF NAMED nt)     rowtype(t OF nt),
(REF ST st)        sttorow(st),
(REF ROW rt)       rt,
(REF TBRACKET tbt) rowtype(tbracket OF tbt),
(REF TSTRING tst)  HEAP ROW := (tstring OF tst, size OF tst),
(REF TYPEVAR tv)   rowtype(t OF tv)
OUT flt
ESAC;


PROC equal_palts = (REF PALTS  a, b) BOOL:
IF a IS nilpalts THEN b IS nilpalts
ELIF b IS nilpalts THEN FALSE
ELSE REF TYPE at = u OF a;
     REF TYPE bt = u OF b;
     ( ((at IS niltype) ANDTH (bt IS niltype)) OREL
      ((at ISNT niltype) ANDTH (bt ISNT niltype) ANDTH
        spec equals(at, bt, 0, FALSE)) )
     ANDTH equal_palts(rest OF a, rest OF b)
FI;

PROC equal_pstrings = (PSTRING ps1, ps2) BOOL:
BEGIN
  INT i1 := 0, i2 := 0;
  FORALL j IN charcheck OF ps1 DO IF j THEN i1 PLUSAB 1 FI OD;
  FORALL k IN charcheck OF ps2 DO IF k THEN i2 PLUSAB 1 FI OD;
  i1 = i2
END;

equiv_types := (TYPE t1, t2, INT diff) BOOL:
CASE t1 IN
(REF PRIMSET ps1)
  CASE t2 IN
  (REF PRIMSET ps2)
    CASE u OF ps1 IN
    (PRANGE pr1)
      CASE u OF ps2 IN
      (PRANGE pr2) integer equals(lwb OF pr1, lwb OF pr2, diff) ANDTH
                   integer equals(upb OF pr1, upb OF pr2, diff)
      OUT FALSE
      ESAC,
    (REF PALTS pa1)
      CASE u OF ps2 IN
      (REF PALTS pa2) equal_palts(pa1, pa2)
      OUT FALSE
      ESAC,
    (PSTRING pst1)
      CASE u OF ps2 IN
      (PSTRING pst2) equal_pstrings(pst1, pst2)
      OUT FALSE
      ESAC
    OUT FALSE
    ESAC,
  (REF NAMED n2)     equiv_types(t1, t OF n2, diff),
  (REF TYPEVAR tv2)  equiv_types(t1, t OF tv2, diff),
  (FLT) TRUE
  OUT FALSE
  ESAC,
(TNULL) CASE t2 IN (TNULL) TRUE OUT FALSE ESAC,
(FLT) TRUE
OUT spec equals(t1, t2, 0, FALSE)
ESAC


KEEP

    compsymb, ident, string, stringsize, nonames, namestack, nofltmess,charval,
    syntaxerror, ivread, bold, letter, digit,t1, sfnno, ctypeno, cfnno, cintno,
    cctypeno, fp1, fp2, fp3, fp4, fp7, fp8, fp9, fp0, fp5, fp6, fpcolon, fpopen,
    fpclose, fpa, fpb, exitcomp, kids, kfns, fndec, fndec_flt,
    decs, vss, maxvss, ids, fns, inarith,
    type, integer, integer1, idinfo, specinput,  which, makeint, lastop,
    sts, fncallstack, errorswitch, macsort, fndecsort,
    macro, id1, lastcall, calts, ctype, cstr,
    currentstate, scopestack, lastops, lastcalls,
    charval1, charalts, delaytype, scope, palts1, paltstack, attrid, intid,
    typeid, ctypeid, prangedec, sopstack,
    typestack, integerstack, idinfostack, sucstack, iddecs,
    casestack, ctname, fna, fnb, decids, charcheck,
    compilefnstack, nilcompilefnstack,
    outints, outid, outstring ,
    endcomp, modulename, vnno, nextkept, inkeptint, inkeptid, nextimport,
    setcontext, input, fltmess, lookup, charset, TEST,
    true, false, unknown, checkle, checkge,
    sampletype, timetype, ints1, ints2, intervalok, tfaster,
    errormessage, paramfncall, macroparam,
    proset, syfault, fault, abort, starter, read, inkept, findkid, newkid,
    newkfn, syfaultp, faultp, namefaultp, syntaxerrmess, fltmessage,
    outexttypes, outextints, outextctypes, unscopeids, outextfns, setidunn,
    loadint, loadtype, ctypetotype, loadctype, simplify, num_names_extfns,
    isintcheck,
    GIVEINT(INTEGER), ISINT(INTEGER), INTTEST, =(TEST,TEST), AND(TEST,TEST),
    OR(TEST, TEST), test integers, check equals, type test, equals, spec equals,
    check type eq, check disjoint, samespecid, samespecfns, checkspecfns,
    isprimrange, primrange, isprimchar_t, arithtype,
    containsfntype, containssort, thasvmno,  insert_idinfo,
    primtypeno, unn, check_joins, containslocaltype, unscope, id_outside_if,
    outmparams, substint, substtype, sttorow, indexio, conc_type,
    trimorindex, merge types, cond_type, reformcheck, setup_compilefn,
    reset_compilefn, default, charunused, findid, findfn, newid,
    newscope, testequals, makedecs, id_in_scope, scope_start, usedid, usedfn,
    fn_in_scope, pushvss, check_charrange,charsubrange,
    rt, t, k, checkeq, defaultfndec,  simplify_int,
    mltype, nextmltype, nilmultlets, multlets, multiassign,
    makevardecs, decs_setup, anyexplicit, nextexpl_par,
    macroexpected, add_mparam, next_mparamno,

    join_setup, check_off, jointype, joinst, joinstack, joinup,
    check_if_output_joined, joinsttorow, jointrim, lhsjoin, ioid,
    nooutput, nonunitbody, setiotype, joinvarstack,
    ihasvmno, joinvarst, decnocheck, has_join_check, mark_join,
    has_fntype, varmult_joinup, joinmultstack, repl_local_make, inst_has_fn_in,
    replicate_joinup, isvoid, gettrim, rowtype, equiv_types, errorrecov,
    specsflt, paramnamestack, ddecs_type, outfncall,
    cattrno, outattrs, atid, attr, attrstr, nextattr, addclassname,
    classnames, outextattrs,  strings, nextstring, fnstack, outddecs,
    nofault, length, joinstrings, outstringlist, outfndec, fncall_flt,
    portinfo, port_setup, portstack, get_port_info, impl_macro

FINISH

