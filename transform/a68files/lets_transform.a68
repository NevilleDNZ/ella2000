DECS  lets_transform  CONTEXT VOID  USE  putstrings,  messageproc,
      osinterface,  assmodes,  transformprocs,  modeprocs,  options:

{ " Id: none available $" }
configinfo A68CONFIG "$Id: lets_transform.a68,v 34.2 1995/03/29 13:02:57 ella Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1988

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

02:08:88  Transform to reduce an ELLA circuit to FN declarations, a sub-set
             of UNIT and recursive LETs.  This transform depends on the prior
             expansion of macros/replicators, sequences and fntypes and retains
             the independance of outer functions.
16:11:88  Lets generated by the sequence transformation for assignments.
14:08:89  Updated for Kernel Interface.  DCT
26:06:90  Major rewrite for new FNTYPEs and FNTYPE transform.  DCT
06:08:90  joincheck changed from VECTOR to list. EVW
08:10:91  Updated to version 7 of assembler modes. EVW
17:12:91  BODYDATA removed. EVW
03:03:92  Declaration attributes added. EVW
17:03:92  flattenneither removed. EVW
05:05:92   New spec fo fndec_tfn. DJS
28:07:92  null_const removed. JIT
04:11:92  local changed to localdec. JIT
25:02:93  formula_int now takes a MESSAGEPROC only.  DCT
13:05:93  replnames removed from FNDEC. EVW

   Inputs are collected together and named _linput unless gathered so by an
   earlier transform.  _linput becomes entry 1 in the nametypes table.  Outputs
   are similarly gathered (unnamed) as entry 2.  As all MAKEs and JOINs are
   removed, an OUTPUT statement is generated (or retained).

14:06:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number  31.014 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT


PROC lets_gennames     = OPTIONS:  MAKEOPTIONS 1;
PROC lets_nosimplify   = OPTIONS:  MAKEOPTIONS 2;
PROC lets_noadjacent   = OPTIONS:  MAKEOPTIONS 3;
PROC lets_noinst       = OPTIONS:  MAKEOPTIONS 4;
PROC lets_noprim       = OPTIONS:  MAKEOPTIONS 5;
PROC lets_nameinputs   = OPTIONS:  MAKEOPTIONS 6;


VECTOR [] STR  lets_options =
( "Generate artificial names for signals in each function",
  "Do not simplify UNITs",
  "Do not recognise adjacent objects in strutures and CONCs in REFORM",
  "Do not break down UNIT to name all instances",
  "Do not break down UNIT to name all primitive nodes",
  "Generate names for unnamed inputs"
);



PROC  lets_transform = ( CLOSURE  closure,  OPTIONS  options,
                         MESSAGEPROC  msg ) CLOSUREC:
BEGIN
   BOOL  generated_names  = options INCLUDES lets_gennames,
         not_simplified   = options INCLUDES lets_nosimplify,
         not_adjacent     = options INCLUDES lets_noadjacent,
         not_nameinst     = options INCLUDES lets_noinst,
         not_nameprim     = options INCLUDES lets_noprim,
         name_input       = options INCLUDES lets_nameinputs;

   { These RVC declarations avoid unnecessary duplicate calls of MAKERVC }

   RVC  dummy_fnname = MAKERVC "_L_",
        row_to_string = MAKERVC "_RTOS",
        string_to_row = MAKERVC "_STOR",
        input_name = MAKERVC "_l_input";

   INT  nstep = 25;   HEAP VECTOR [0] RVC  nullrvc;
   REF VECTOR [] RVC  call_names:= nullrvc;
   REF VECTOR [] RVC  multilet_names:= nullrvc;
   REF VECTOR [] RVC  prims_names:= nullrvc;
   REF VECTOR [] RVC  unname_names:= nullrvc;
   REF VECTOR [] RVC  fnname_names:= nullrvc;

   PROC  make_name = (REF REF VECTOR [] RVC  table,  STR  name,  INT  index) ID:
      { To avoid generating lots of duplicate names on the HEAP }
      IF index > UPB table
      THEN  HEAP VECTOR [UPB table + nstep] RVC  new;
            new[: UPB table]:= table;
            FORALL  name IN new[UPB table + 1 :]  DO  name:= nilstr  OD;
            table:= new;
            make_name(table, name, index)
      ELSE  REF RVC  id = table[index];
            IF id IS nilstr
            THEN  id:= oneline((name, index))
            FI;
            id
      FI;



   HEAP UNAME  null_uname:= (usource, 0);


   { *****  PROC  outerfn  ***** }

   PROC  transform_outerfn = (OUTER  outer,  TRANSFORMPROCS  tprocs) OUTERC:
   BEGIN
      HEAP ENVIRON  env:= environ OF outer;

      REF REF VECTOR [] REF FNDEC  fns = fns OF env;
      BOOL  newdec:= FALSE;

      PROC  add_fndec = (REF FNDEC  fndec) INT:
      BEGIN
         HEAP VECTOR [UPB fns + 1] REF FNDEC  new;
         new[: UPB fns]:= fns;
         fns:= new;
         fns[UPB fns]:= fndec;
         newdec:= TRUE;
         UPB fns
      END;

      PROC  replace_fndec = (INT  fnno, REF FNDEC  fndec) VOID:
      BEGIN
         IF NOT newdec
         THEN  newdec:= TRUE;
               fns:= HEAP VECTOR [UPB fns] REF FNDEC:= fns
         FI;
         fns[fnno]:= fndec
      END;

      PROC  output_type = (INT  fnno) TYPE:
         to OF fndec_tfn( (fns OF environ OF outer)[fnno]);

      INT  n_fnnames:= 0;        { Used to name generated FN names }



      { *****  PROC  fndec  ***** }

      PROC  fndec = (REF FNDEC  fdec,  TRANSFORMPROCS  tprocs) FNDECC:
      IF fdec ISNT nilfndec
      THEN

         PROC  flt = (STR  info) VOID:
            msg(user, oneline(( "Lets transform:  FN ", fnname OF fdec,
                                  "  ",  info )) );

         PROC  sys = (STR  info) VOID:
            msg(system, oneline(( "Lets transform:  FN ", fnname OF fdec,
                                  "  ",  info )) );

         OP  MAKEFINT = (INT  int) REF FINT:  HEAP FINT:= (int, nullstr);

         INT  empty = -1;

         PROC  get_int = (FORMULA  f) INT:
            CASE f IN
               (REF FINT  int)  int OF int ,
               (REF FNULL)      empty
            OUT  formula_int(f, msg)
            ESAC;

         { (name) TYPE and LET tables.  "translations" table relates old
           "nametypes" to new ("nametable") }

         INT  vecstep = 10;

         REF VECTOR [] NAMETYPE  nametypes = nametypes OF fdec;
         INT  n_translations = UPB nametypes;
         VECTOR [n_translations] INT  translations;
         VECTOR [n_translations] BOOL  var_init;
         FORALL tr IN translations, v IN var_init DO  tr:= -1;  v:= TRUE  OD;

         REF VECTOR [] NAMETYPE  nametable:=
                   HEAP VECTOR [UPB nametypes + vecstep] NAMETYPE;
         REF TNAME  illegalt = MAKETNAME -9999;
         FORALL nt IN nametable DO  nt:= (nullid, illegalt, attrnull)  OD;

         { LET table to avoid searching and to get correct diagnostics order }

         REF VECTOR [] REF LET  lettable:= HEAP VECTOR [UPB nametable] REF LET;
         FORALL nl IN lettable DO  nl:= REF LET (NIL)  OD;
         INT  n_names:= 0;


         PROC  allocate_name = REF UNAME:
         BEGIN
            IF n_names = UPB nametable
            THEN  HEAP VECTOR [UPB nametable + vecstep] NAMETYPE  newt;
                  HEAP VECTOR [UPB nametable + vecstep] REF LET  newl;
                  newt[: n_names]:= nametable;
                  newl[: n_names]:= lettable;
                  FORALL nt IN newt[n_names + 1 :]
                    DO nt:= (nullid, illegalt, attrnull) OD;
                  FORALL nl IN newl[n_names + 1 :] DO nl:= REF LET (NIL)  OD;
                  nametable:= newt;
                  lettable:= newl
            FI;

            HEAP UNAME:= (usource, n_names PLUSAB 1)
         END;


         PROC  add_nametype = (NAMETYPE nt,TYPE type, INT  old_index) REF UNAME:
         BEGIN
            REF UNAME  uname = allocate_name;
            INT  nameno = nameno OF uname;
            nametable[nameno]:= (name OF nt, type, attr OF nt);
            IF old_index > 0 THEN  translations[old_index]:= nameno  FI;
            uname
         END;



         { SERIES for the new FNBODY - this is builtup from scratch }

         REF SERIES  series:= nilseries;
         REF REF SERIES  seriesptr:= series;
         BOOL  have_series:= FALSE; { Used in new_fndec to detect valid series }

         PROC  add_step = (STEP  step) VOID:
         BEGIN
            seriesptr:= rest OF ( REF REF SERIES (seriesptr):= HEAP SERIES:=
                                  (step, nilseries) );
            have_series:= TRUE
         END;

         { Creation of name (LET) procedures }

         PROC  make_let = (INT  nameno,  UNIT  unit) VOID:
            add_step( lettable[nameno]:= HEAP LET:=
                         (HEAP NAMES:= (nameno, nilnames), unit) );

         PROC  make_uname = (ID name,  TYPE  type,  UNIT  unit) REF UNAME:
         BEGIN
            NAMETYPE nt = (name, tnull, attrnull);
            REF UNAME  uname = add_nametype(nt, type, 0);
            make_let(nameno OF uname, unit);
            uname
         END;


         PROC  fill_uname = ( NAMETYPE nametype, UNIT unit, REF UNAME uname )
                                                                         VOID:
         BEGIN
            INT  nameno = nameno OF uname;
            nametable[nameno]:= nametype;
            make_let(nameno, unit)
         END;



         { UNIT and STEP procedures }

         INT  n_calls:= 0,  n_multilets:= 0,  n_prims:= 0;

         PROC  call_name = RVC:
            make_name(call_names, "_l_fn", n_calls PLUSAB 1);

         PROC  multilet_name = RVC:
            make_name(multilet_names, "_l_m", n_multilets PLUSAB 1);

         PROC  prims_name = RVC:
            make_name(prims_names, "_l_p", n_prims PLUSAB 1);


         BOOL  has_instance;

         PROC  look_for_instance = (UNIT  u, TRANSFORMPROCS  tprocs) UNITC:
            CASE u IN
               (REF UMINST)  ( has_instance:= TRUE; (u, FALSE) ) ,
               (REF UDINST)  ( has_instance:= TRUE; (u, FALSE) )
            OUT  (unit OF nulltprocs)(u, tprocs)
            ESAC;


         TRANSFORMPROCS  has_named =
           make_newtprocs( nulltprocs, ( look_for_instance, null_attr,
                                         null_formula, null_type )
                         );

         PROC  unit_has_named = (UNIT  u) BOOL: { TRUE if a new would be generated }
         BEGIN
            { Uses side effect to look for instances in a unit }
            has_instance:= FALSE;
            look_for_instance(u, has_named);
            has_instance
         END;


         PROC  uminst = ( REF UMINST  um,  BOOL  named,
                          TRANSFORMPROCS  newtprocs ) UNITC:
         IF not_nameinst
         THEN  (unit OF tprocs)(um, newtprocs)
         ELSE
            { Names the instance if it is not named already (named = FALSE).
              Allocate next to ensure LETs are ordered for diagnostics }
            REF UNAME  uname =
               IF named THEN  null_uname  ELSE  allocate_name FI;
            RVC  cname = call_name;
            UNITC  call = (unit OF tprocs)(um, newtprocs);
            IF named
            THEN  call
            ELSE  { Can call unit_type as refers to unchanged INST }
                  TYPE  type = unit_type(u OF call, fdec, env);
                  fill_uname((cname, type, attrnull), u OF call, uname);
                  (uname, TRUE)
            FI
         FI;


         PROC  udinst = ( REF UDINST  ud,  BOOL  named_outside,
                          TRANSFORMPROCS  newtprocs ) UNITC:
         IF not_nameinst
         THEN  (unit OF tprocs)(ud, newtprocs)
         ELSE
            BOOL  named = named_outside ANDTH NOT unit_has_named(left OF ud);

            UNITC  luc = (unit OF newtprocs)(left OF ud, newtprocs);

            { Allocate next to ensure LETs are ordered for diagnostics }
            REF UNAME  uname =
               IF named THEN  null_uname  ELSE  allocate_name  FI;
            RVC  cname = call_name;

            UNITC  ruc = (unit OF newtprocs)(right OF ud, newtprocs);
            UNIT  param = HEAP USTR:= (u OF luc, HEAP USTR:= (u OF ruc, nilustr));
            HEAP UMINST  call:= (inst OF ud, param);
            IF named
            THEN  (call, TRUE)
            ELSE  TYPE  type = unit_type(call, fdec, env);
                  fill_uname((cname, type, attrnull), call, uname);
                  (uname, TRUE)
            FI
         FI;


         PROC  uprim = ( UNIT  unit,  BOOL  named,
                         TRANSFORMPROCS  newtprocs ) UNITC:
         IF not_nameprim
         THEN  (unit OF tprocs)(unit, newtprocs)
         ELSE
            { Names the primitive if it is not named already (named = FALSE).
              Allocate next to ensure LETs are ordered for diagnostics }
            REF UNAME  uname = IF named THEN  null_uname  ELSE  allocate_name  FI;
            RVC  pname = prims_name;
            { Note use of (old) tprocs with newtprocs as parameter }
            UNITC  uc = (unit OF tprocs)(unit, newtprocs);
            IF named
            THEN  uc
            ELSE  TYPE  type = unit_type(unit, fdec, env);
                               { Can call unit_type on untransformed UNIT }
                  fill_uname((pname, type, attrnull), u OF uc, uname);
                  (uname, TRUE)
            FI
         FI;


         PROC  unit = (UNIT  u,  TRANSFORMPROCS  tprocs) UNITC:
         CASE u IN
            { REF CNAME, REF CBASIC, REF CINT, REF CQUERY - unchanged }

            (REF UNAME  un)
               IF translations[nameno OF un] = nameno OF un
               THEN  (u, FALSE)
               ELSE  ( HEAP UNAME:= ( usource,
                                      translations[nameno OF un]), TRUE )
               FI ,

            { REF UFN - not expected }

            (REF UASSOC)  uprim(u, FALSE, tprocs) ,
            (REF UEXTRACT)  uprim(u, FALSE, tprocs) ,

            { REF UINDEX, REF UTRIM - use standard "unit" }

            (REF UDYINDEX)  uprim(u, FALSE, tprocs) ,
            (REF UREPLACE)  uprim(u, FALSE, tprocs) ,

            { REF UROW, REF USTR, REF UCONC - use standard "unit" }

            (REF UMINST  um)
               uminst(um, FALSE, tprocs) ,

            (REF UDINST  ud)
               udinst(ud, FALSE, tprocs) ,

            (REF UCASE)  uprim(u, FALSE, tprocs) ,

            { REF UCOND, REF UREPL, REF USEQUENCE - not expected }

            (REF USERIES  us)
               ( REF SERIES  serptr:= body OF us;
                 WHILE serptr ISNT nilseries
                 DO  { step will remember what is necessary -
                          use UNAME to sort out scope }
                     (step OF tprocs)(step OF serptr, tprocs);
                     serptr:= rest OF serptr
                 OD;
                 (u OF (unit OF tprocs)(output OF us, tprocs), TRUE)
               ) ,

            { REF UATTR - use standard "unit", REF UCHECK - not expected }

            (REF UBRACKET  ub)  { Remove bracket }
               ( UNITC  uc = (unit OF tprocs)(unit OF ub, tprocs);
                 (u OF uc, TRUE)
               )

            { REF USTRING, REF UNULL, REF CVOID - use standard "unit" }

         OUT  { Apply this transformation to any UNIT component parts of
                the remaining categories of UNIT -
                Note use of nulltprocs to avoid problems with recursion }
              (unit OF nulltprocs)(u, tprocs)
         ESAC;




         PROC  simplify_units = (UNIT  u) UNITC:
         BEGIN
            VECTOR [n_names] BOOL  let_simplified;
            FORALL b IN let_simplified DO  b:= FALSE  OD;

            PROC  simplify_unit = (UNIT  u,  TRANSFORMPROCS  tprocs) UNITC:
            BEGIN
               { Looks for indexing of structures &c }

               PROC  simplify_uname = (REF UNAME  un) REF UNAME:
               BEGIN
                  INT  nameno = nameno OF un;
                  IF  nameno > 2   { UNAME (1 / 2) is the FN input / output }
                         ANDTH  NOT let_simplified[nameno]
                  THEN  let_simplified[nameno]:= TRUE;
                        UNITC  uc =
                           simplify_unit(unit OF lettable[nameno], tprocs);
                        IF c OF uc THEN  unit OF lettable[nameno]:= u OF uc  FI
                  FI;
                  un
               END;


               PROC  simplify_to_str = (UNIT  u) UNION (UNITC, REF USTR):
               BEGIN
                  UNITC  uc = simplify_unit(u, tprocs);
                  CASE u OF uc IN
                     (REF UNAME  uname)
                        ( REF UNAME  un = simplify_uname(uname);
                          IF nameno OF un > 2     { Not a primary terminal }
                          THEN  CASE unit OF lettable[nameno OF un] IN
                                   (REF USTR  ustr)  ustr
                                OUT  uc
                                ESAC
                          ELSE  uc
                          FI
                        ) ,
                     (REF USTR  ustr)
                        ustr
                  OUT  uc
                  ESAC
               END;


               PROC  index_unit = (REF UINDEX  uindex) UNITC:
                  CASE simplify_to_str(unit OF uindex) IN
                     (REF USTR  ustr)
                        ( { Only index USTR - not USTRING. (UROW -> USTR) }
                          REF USTR  uptr:= ustr;
                          TO int(index OF uindex) - 1 DO  uptr:= rest OF uptr  OD;
                          (elem OF uptr, TRUE)
                        ) ,
                     (UNITC  uc)
                        IF c OF uc
                        THEN  (HEAP UINDEX:= (u OF uc, index OF uindex), TRUE)
                        ELSE  (u, FALSE)
                        FI
                  ESAC;


               PROC  trim_unit = (REF UTRIM  utrim) UNITC:
               CASE simplify_to_str(unit OF utrim) IN
                  (REF USTR  ustr)
                     ( { Only trim USTR - not USTRING. (UROW -> USTR) }
                       REF USTR  uptr:= ustr;
                       INT  off = int(lwb OF range OF utrim) - 1,
                            upb = int(upb OF range OF utrim);
                       TO off DO  uptr:= rest OF uptr  OD;
                       REF USTR  ans;
                       REF REF USTR  nptr:= ans;
                       TO upb - off
                       DO  nptr:= rest OF ( REF REF USTR (nptr):= HEAP USTR:=
                                              (elem OF uptr, nilustr) );
                           uptr:= rest OF uptr
                       OD;
                       (ans, TRUE)
                     ) ,
                  (UNITC  uc)
                     IF c OF uc
                     THEN  (HEAP UTRIM:= (u OF uc, range OF utrim), TRUE)
                     ELSE  (u, FALSE)
                     FI
               ESAC;


               PROC  conc_unit = (REF UCONC  uconc) UNITC:
                  IF NOT string OF uconc
                  THEN  UNITC  l = simplify_unit(left OF uconc, tprocs),
                               r = simplify_unit(right OF uconc, tprocs);
                        UNIT  left = u OF l,  right = u OF r;

                        PROC  add_ustr = (UNIT  left, right,  BOOL  lstr, rstr) UNITC:
                        BEGIN
                           REF USTR  ans;
                           REF REF USTR  uptr:= ans;
                           IF lstr
                           THEN  REF USTR  lptr:= CASE left IN (REF USTR  lu)  lu  ESAC;
                                 WHILE lptr ISNT nilustr
                                 DO  uptr:= rest OF ( REF REF USTR (uptr):= HEAP USTR:=
                                                      (elem OF lptr, nilustr) );
                                     lptr:= rest OF lptr
                                 OD
                           ELSE  REF REF USTR (uptr):= HEAP USTR:= (left, nilustr)
                           FI;
                           IF rstr
                           THEN  REF USTR  rptr:= CASE right IN (REF USTR  ru)  ru  ESAC;
                                 WHILE rptr ISNT nilustr
                                 DO  uptr:= rest OF ( REF REF USTR (uptr):= HEAP USTR:=
                                                      (elem OF rptr, nilustr) );
                                     rptr:= rest OF rptr
                                 OD
                           ELSE  REF REF USTR (uptr):= HEAP USTR:= (right, nilustr)
                           FI;
                           (ans, TRUE)
                        END;


                        PROC  new_conc = UNITC:
                           IF c OF l  OREL  c OF r
                           THEN  (HEAP UCONC:= (FALSE, sort OF uconc, left, right), TRUE)
                           ELSE  (uconc, FALSE)
                           FI;


                        IF sort OF uconc = flattenleft
                        THEN  CASE left IN
                                 (REF USTR  ustr)  add_ustr(ustr, right, TRUE, FALSE)
                              OUT  new_conc
                              ESAC
                        ELIF sort OF uconc = flattenright
                        THEN  CASE right IN
                                 (REF USTR  ustr)  add_ustr(left, ustr, FALSE, TRUE)
                              OUT  new_conc
                              ESAC
                        ELSE  CASE left IN
                                 (REF USTR  lustr)
                                    CASE right IN
                                       (REF USTR  rustr)
                                          add_ustr(lustr, rustr, TRUE, TRUE)
                                    OUT  new_conc
                                    ESAC
                              OUT  new_conc
                              ESAC
                        FI
                  ELSE  (uconc, FALSE)
                  FI;



               CASE u IN
                  (REF UNAME  un)
                     (simplify_uname(un), FALSE) ,
                  (REF UINDEX  ui)
                     index_unit(ui) ,
                  (REF UTRIM  ut)
                     trim_unit(ut) ,
                  (REF UROW  ur)
                     ( { Replace UROW by USTR }
                       REF USTR  ans:= nilustr;
                       TO int(size OF ur) DO  ans:= HEAP USTR:= (elem OF ur, ans)  OD;
                       (ans, TRUE)
                     ) ,
                  (REF UCONC  uc)
                     conc_unit(uc) ,
                  (REF USERIES  user)
                     ( { USERIES will share the same LET table -
                         whose contents is processed separately }
                       UNITC  uc = (unit OF tprocs)(output OF user, tprocs);
                       IF c OF uc
                       THEN  ( HEAP USERIES:= ( body OF user, u OF uc ),
                               TRUE )
                       ELSE (u, FALSE)
                       FI
                     ) ,
                  (REF UATTR  ua)
                     (u OF simplify_unit(unit OF ua, tprocs), TRUE) ,
                  (REF UBRACKET  ub)
                     (u OF simplify_unit(unit OF ub, tprocs), TRUE)
               OUT  { Note use of nulltprocs to avoid problems with recursion }
                    (unit OF nulltprocs)(u, tprocs)
               ESAC
            END;


            TRANSFORMPROCS  newtprocs =
                make_newtprocs(nulltprocs, (simplify_unit, null_type, null_formula));

            IF generated_names
            THEN  FOR i FROM 3 TO n_names
                  DO  name OF nametypes[nameno OF letnames OF lettable[i]] :=
                         oneline(("_lu", i))
                  OD
            FI;

            IF not_simplified
            THEN  (u, FALSE)
            ELSE  FORALL let IN lettable[3 : n_names]
                  DO  simplify_unit(unit OF let, newtprocs)  OD;
                  simplify_unit(u, newtprocs)
            FI
         END;


         PROC  declaration = (DECLARATION  d,  TRANSFORMPROCS  tprocs) STEPC:
         BEGIN
            CASE d IN
               (FNNAME  fn)
                  ( REF FNDEC dec = (fns OF env)[fnno OF fn];
                    IF (dec ISNT nilfndec) ANDTH (sort OF dec = localdec)
                    THEN  replace_fndec(fnno OF fn, f OF fndec(dec, tprocs));
                          add_step(d)
                    FI
                  ),
               (TNAME t)
                  ( REF TYPEDEC td = (types OF env)[typeno OF t];
                    IF (td ISNT niltypedec) ANDTH (sort OF td = localdec)
                    THEN  add_step(d)
                    FI
                  )
            OUT  SKIP
            ESAC;
            (d, FALSE)
         END;



         PROC  let = (REF LET  l,  TRANSFORMPROCS  tprocs) STEPC:
         BEGIN
            { This procedure must allocate space in the nametable prior
              to processing the UNIT to ensure the diagnostic order is
              preserved.  The translation table must be updated and checked
              for an assignment LET after UNIT has been processed to ensure
              that the scope of the assignment is correct.  This procedure
              avoids creating names where possible. }

            REF NAMES  names = letnames OF l;

            PROC  do_unit = (UNIT  unit) UNIT:
               { Processes UNIT avoiding generating unnecessary names }
               u OF CASE unit IN
                       (REF UMINST  um)  uminst(um, TRUE, tprocs) ,
                       (REF UDINST  ud)  udinst(ud, TRUE, tprocs) ,
                       (REF UASSOC)      uprim(unit, TRUE, tprocs) ,
                       (REF UEXTRACT)    uprim(unit, TRUE, tprocs) ,
                       (REF UDYINDEX)    uprim(unit, TRUE, tprocs) ,
                       (REF UREPLACE)    uprim(unit, TRUE, tprocs) ,
                       (REF UCASE)       uprim(unit, TRUE, tprocs) ,
                       (REF UFN  ufn)    (do_unit(source OF ufn), TRUE)
                           { UFN left for diagnostics - taking the source may
                            well throw away other sources in the sink
                            component - an arbitary decision. }
                   OUT (unit OF tprocs)(unit OF l, tprocs)
                   ESAC;


            PROC  do_name = ( REF NAMES  name,  REF UNAME  uname,
                              UNIT  unit ) VOID:
            BEGIN
               INT  old = nameno OF name,  new = nameno OF uname;
               fill_uname(nametypes[old], unit, uname);
               IF translations[old] /= -1 THEN   sys("Reused nameno")  FI;
               translations[old]:= new
            END;


            IF rest OF names IS nilnames
            THEN  REF UNAME  uname = allocate_name;
                  do_name(names, uname, do_unit(unit OF l))

            ELSE  { Multiple LET - break down - name if needed }

                  BOOL  named = CASE unit OF l IN (REF UNAME)  TRUE
                                OUT  FALSE
                                ESAC;

                  REF UNAME  multilet:=
                     IF named THEN  null_uname  ELSE  allocate_name  FI;

                  { Create space in nametable for each name and build type }

                  MODE  UNAMES = STRUCT (REF UNAME  uname,  REF UNAMES  rest);
                  REF UNAMES  nilunames = NIL;
                  REF UNAMES  unames:= nilunames;
                  REF REF UNAMES  uptr:= unames;
                  REF NAMES  nptr:= names;
                  REF TSTR  tstr:= niltstr;
                  REF REF TSTR  tptr:= tstr;
                  WHILE nptr ISNT nilnames
                  DO  uptr:= rest OF ( REF REF UNAMES (uptr):= HEAP UNAMES:=
                                         ( allocate_name, nilunames ) );
                      tptr:= rest OF ( REF REF TSTR (tptr):= HEAP TSTR :=
                                         ( type OF nametypes[nameno OF nptr],
                                           niltstr) );
                      nptr:= rest OF nptr
                  OD;

                  UNIT  newunit = do_unit(unit OF l);

                  RVC  id = multilet_name;
                  IF named
                  THEN  multilet:= CASE newunit IN (REF UNAME  un)  un  ESAC
                  ELSE  fill_uname((id, tstr, attrnull), newunit, multilet)
                  FI;

                  INT  index:= 0;
                  uptr:= unames;  nptr:= names;
                  WHILE nptr ISNT nilnames
                  DO  { Each LET name will be an index into the unit }
                      HEAP UINDEX  index:= (multilet, MAKEFINT (index PLUSAB 1));
                      do_name(nptr, uname OF uptr, index);
                      uptr:= rest OF uptr;  nptr:= rest OF nptr
                  OD
            FI;

            { The SERIES in which this LET occurs will be thrown away as a new
              one is being built up by make_uname - so indicate no change }

            (l, FALSE)
         END;


         PROC  make = (REF MAKE  m,  TRANSFORMPROCS  tprocs) STEPC:
         BEGIN
            { Type of a single FN in the make }
            TYPE  type = output_type(fnno OF inst OF m);

            PROC  do_dimension = (REF FORMULAS  size) UNIT:
               IF size IS nilformulas
               THEN  { Generate a LET refering to a UMINST corresponding
                       to a single instance of the subject of the MAKE.
                       leave the parameter part of the UMINT null to be
                       filled in later by the appropriate JOIN. }
                     make_uname( call_name, type,
                                 HEAP UMINST:= (inst OF m, unull) )
               ELSE  REF USTR  ustr;
                     REF REF USTR  uptr:= ustr;
                     TO get_int(formula OF size)
                     DO  uptr:= rest OF ( REF REF USTR (uptr):= HEAP USTR:=
                                          (do_dimension(rest OF size), nilustr) )
                     OD;
                     ustr
               FI;

            PROC  rowtype = (REF FORMULAS  size) TYPE:
               IF size IS nilformulas
               THEN  type
               ELSE  HEAP TROW:= (formula OF size, rowtype(rest OF size))
               FI;


            REF NAMES  nptr:= makenames OF m;
            WHILE nptr ISNT nilnames
            DO  { First reserve a place in the names table for the
                  MAKE name to get diagnostics correct }
                NAMETYPE nt = nametypes[nameno OF nptr];
                REF UNAME  uname =
                   add_nametype(nt, rowtype(sizes OF m), nameno OF nptr);
                IF sizes OF m IS nilformulas
                THEN  { Have a single MAKE so use MAKE name for LET }
                      n_calls PLUSAB 1;
                      make_let( nameno OF uname,
                                HEAP UMINST:= (inst OF m, unull) )
                ELSE  make_let( nameno OF uname, do_dimension(sizes OF m) )
                FI;
                nptr:= rest OF nptr
            OD;

            (m, FALSE)
         END;


         PROC  join = (REF JOIN  j,  TRANSFORMPROCS  tprocs) STEPC:
         BEGIN
            UNIT  left  = u OF (unit OF tprocs)(from OF j, tprocs),
                  right = to OF j;  { to be JOINed to (sink) }

            { First extract FN instance to be JOINed to from "right" }

            PROC  get_inst = (UNIT  u,  INT  index) UNIT:
            BEGIN
               UNIT  new =
                  CASE u IN
                     (REF UNAME  un)
                        { Inst name or LET name for USTR }
                        HEAP UNAME:= (sort OF un, translations[nameno OF un]) ,
                     (REF UINDEX  ui)
                        get_inst(unit OF ui, get_int(index OF ui))
                  OUT  sys("Unexpected ""to"" UNIT in JOIN");
                       unull
                  ESAC;
               IF index = 0
               THEN  new
               ELSE  REF USTR  uptr:=
                        CASE new IN
                           (REF UNAME  un)
                              CASE unit OF lettable[nameno OF un] IN
                                 (REF USTR  us)  us
                              OUT  flt("USTR expected in LET");
                                   nilustr
                              ESAC
                        ESAC;
                     TO index - 1 DO  uptr:= rest OF uptr  OD;
                     elem OF uptr
               FI
            END;

            REF UNAME  uname = CASE get_inst(right, 0) IN
                                  (REF UNAME  un)  un
                               ESAC;

            REF LET  let = lettable[nameno OF uname];

            CASE unit OF let IN
               (REF UMINST  um)
                   right OF um:= left
            ESAC;

            (j, FALSE)
         END;


         PROC  step = (STEP  s,  TRANSFORMPROCS  tprocs) STEPC:
            { This will never deliver a change (new value).  A new SERIES
              is constructed instead by PROC add_step. }
            CASE s IN
               (DECLARATION  d)  declaration(d, tprocs) ,
               (REF LET  l)      let(l, tprocs) ,
               (REF MAKE  m)     make(m, tprocs) ,
               (REF JOIN  j)     join(j, tprocs)
            OUT  (s, FALSE)
            ESAC;



         { IOSPEC and BODY procedures }

         MODE  FNSPEC = STRUCT (REF NAMES  input, output,  BOOL  changed);

         PROC  check_names = VOID:
         BEGIN
            FORALL l IN lettable[3:n_names]
            DO  IF l IS REF LET (NIL)
                THEN  flt("NIL LET")
                ELIF INT  nameno = nameno OF letnames OF l;
                     nameno <= 0  OREL  nameno > n_names
                THEN  flt(oneline(( "Illegal nameno in LET = ", nameno )))
                FI
            OD;
            FOR no TO n_names
            DO  IF CASE type OF nametable[no] IN
                      (REF TNAME  tn)  typeno OF tn = typeno OF illegalt
                   OUT FALSE
                   ESAC
                THEN  flt(oneline(("Name ", no, " not defined")))
                FI
            OD
         END;


         PROC  process_iospec = (REF FNDEC  fdec) FNSPEC:
         BEGIN
            BOOL  changed:= FALSE;
            { First allocate space for one input and one output in the
              nametypes table }

            REF UNAME  input = allocate_name,  output = allocate_name;

            { Process the inputs to the FN - convert to a single unit }

            REF NAMES  inptr:= inputs OF fdec;
            IF rest OF inptr ISNT nilnames
            THEN  { Have more than one input - convert to a single input }
                  REF TSTR  tstr;
                  REF REF TSTR  tptr:= tstr;
                  FOR index WHILE inptr ISNT nilnames
                  DO  NAMETYPE  nt = nametypes[nameno OF inptr];
                      IF (name OF nt ISNT nilstr)  ANDTH UPB name OF nt > 0
                      THEN  REF UNAME  newinput =
                                  add_nametype(nt, type OF nt, nameno OF inptr);
                            make_let( nameno OF newinput,
                                      HEAP UINDEX:= (input, MAKEFINT index) )
                      FI;
                      tptr:= rest OF ( REF REF TSTR (tptr):= HEAP TSTR:=
                                             (type OF nt, niltstr) );
                      inptr:= rest OF inptr
                  OD;
                  inptr:= HEAP NAMES:= ( nameno OF input { 1 }, nilnames );
                  nametable[nameno OF input]:= (input_name, tstr, attrnull);
                  changed:= TRUE
            ELSE  nametable[nameno OF input]:= nametypes[nameno OF inptr];
                  translations[nameno OF input]:= nameno OF inptr;
                  { nameno OF inptr = nameno OF input = 1 therefore
                    do not have to update inptr or translations table }
                  IF name_input  AND  ( name OF nametable[1] IS nilstr)
                                        OREL (UPB name OF nametable[1] = 0 )
                  THEN  { Generate an input name for diagnostic purposes }
                        name OF nametable[1] := input_name;
                        changed:= TRUE
                  FI
            FI;

            { Now process the output }

            REF NAMES  outptr:= outputs OF fdec;
            IF rest OF outptr ISNT nilnames
            THEN  { Have more than one output }
                  REF TSTR  tstr;
                  REF REF TSTR  tptr:= tstr;
                  FOR index WHILE outptr ISNT nilnames
                  DO  NAMETYPE nt = nametypes[nameno OF outptr];
                      tptr:= rest OF ( REF REF TSTR (tptr):= HEAP TSTR:=
                                            (type OF nt, niltstr) );
                      outptr:= rest OF outptr
                  OD;
                  type OF nametable[nameno OF output]:= tstr;
                  changed:= TRUE
            ELSE  nametable[nameno OF output]:= nametypes[nameno OF outptr];
                  translations[nameno OF output]:= nameno OF outptr
            FI;
            IF nameno OF outptr /= nameno OF output  OREL
                  (rest OF outptr ISNT nilnames)
            THEN  changed:= TRUE;
                  outptr:= HEAP NAMES:= (nameno OF output, nilnames)
            FI;

            (inptr, outptr, changed)
         END;


         PROC  add_fnbody = ( RVC  name,  FNBODY  body,  FNSPEC  iospec,
                              REF VECTOR [] NAMETYPE  nametypes ) INSTANCE:
         BEGIN
            { This procedure is used to create an internal FN declaration when
              a FNBODY not containing a UNITTAG is encountered that has
              partially or multiply named inputs.  This permits diagnostic
              information to be presented for the named inputs in the form of
              LET STEPs whilst permitting a single entry to be used in the
              nametypes table for the primary input and output.
              PROC process_iospec must be called first to allocate space for
              the primary terminals.

              Also used when creating REFORM functions to represent STRING to
              ROW and ROW to STRING conversions.
            }

            INT  fnno =
                add_fndec( HEAP FNDEC:=
                          ( localdec, FALSE { not MAC }, name, macspecs OF fdec,
                            attrnull, input OF iospec, output OF iospec,
                            nametypes, body, nilusage
                          ) );
            add_step(MAKEFNNAME fnno);

            ( fnno, nilmacparams, attrnull { attnames } )
         END;


         PROC  new_fndec = (FNSPEC  newspec,  UNIT  newunit) FNDECC:
            ( HEAP FNDEC:=
              ( localdec, FALSE { not MAC }, fnname OF fdec, macspecs OF fdec,
                attrnull, input OF newspec, output OF newspec,
                nametable[: n_names],
                MAKEUNITTAG ( IF have_series
                              THEN  HEAP USERIES:= (series, newunit)
                              ELSE  newunit
                              FI
                            ),
                nilusage ),
              TRUE
            );


         PROC  unit_body = (REF UNITTAG  ut,  TRANSFORMPROCS  tprocs) FNDECC:
         BEGIN
            TRANSFORMPROCS  newtprocs =
                make_newtprocs(tprocs, ( step, unit, null_attr,
                                         null_type, null_formula ));

            FNSPEC  new_spec = process_iospec(fdec);

            UNIT  unit = u OF unit(tag OF ut, newtprocs);
            check_names;
            new_fndec(new_spec, u OF simplify_units(unit))
         END;


         PROC  reformp = (REF REFORM  re,  TRANSFORMPROCS  tprocs) FNDECC:
         BEGIN
            { NOTE:  REFORM between rows and strings is not currently permitted

              First break input and output types down to STRUCTs, ROWs and STRINGs
              of NEW types.  ("simplify_type")

              Break down the input (UNAME (1)) into a list of primitive (NEW type)
              components according to the input type.  This will look like a series
              of nested indicies (UNINDEX) of the UNAME (1). This list also contains
              the (primitive) type of each object and its "FROMTYPE" to determine
              whether it ia part of a STRUCT, ROW or STRING.  ("break_down_unit")

              Build up a new object using CONC and USTR from the primitives using the
              output type.  Where ever possible check for and convert:
                 (UNINDEX (u, i) CONC (UINDEX (u, i+1)) -> UTRIM (u, (i..i+1))
                 UTRIM (u, (1..n)) -> u when n = upb AND intype = outtype
              Inject a REFORM when intype /= outtype to convert STRING to ROW or ROW to
              STRING.  ("build_unit")
            }

            PROC  simplify_type = (TYPE  type,  TRANSFORMPROCS  tprocs) TYPEC:
               { Procedure to simplify a TYPE to a composition of primitive (NEW) TYPEs }
               CASE  type IN
                  (REF TNAME  tn)
                     ( REF TYPEDEC  typedec = (types OF env)[typeno OF tn];
                       CASE body OF typedec IN
                          (REF TYPETAG  tag)
                             (t OF simplify_type(tag OF tag, tprocs), TRUE)
                       OUT  (type, FALSE)
                       ESAC
                     ) ,
                  (REF TBRACKET  tb)
                     (type OF tb, TRUE)
               OUT  { Note use of nulltprocs to avoid problems with recursion }
                    (type OF nulltprocs)(type, tprocs)
               ESAC;


            OP  =  = (TYPE  a,  b)  BOOL:
               CASE a IN
                  (REF TNAME  tna)
                     CASE b IN
                        (REF TNAME  tnb)  typeno OF tna = typeno OF tnb
                     OUT  FALSE
                     ESAC ,
                  (REF TROW  tra)
                     CASE b IN
                        (REF TROW  trb)
                           int(size OF tra) = int(size OF trb)  ANDTH
                             (elem OF tra = elem OF trb)
                     OUT  FALSE
                     ESAC ,
                  (REF TSTR  tsa)
                     CASE b IN
                        (REF TSTR  tsb)
                           ( REF TSTR  aptr:= tsa,  bptr:= tsb;
                             WHILE (aptr ISNT niltstr)  ANDTH  (bptr ISNT niltstr)
                                      ANDTH  (elem OF aptr = elem OF bptr)
                             DO  aptr:= rest OF aptr;
                                 bptr:= rest OF bptr
                             OD;
                             (aptr IS niltstr)  ANDTH  (bptr IS niltstr)
                           )
                     OUT  FALSE
                     ESAC ,
                  (REF TSTRING  tca)
                     CASE b IN
                        (REF TSTRING  tcb)
                           int(size OF tca) = int(size OF tcb)  ANDTH
                              (char OF tca = char OF tcb)
                     OUT  FALSE
                     ESAC ,
                  (REF TVOID)
                     CASE b IN (REF TVOID)  TRUE  OUT  FALSE  ESAC
               ESAC;


            MODE  FROMTYPE,
                  FROMROW = STRUCT (INT  rsize, FROMTYPE  container),
                  FROMSTRUCT = STRUCT (INT  size,  BOOL  same,  FROMTYPE  container),
                  FROMSTRING = STRUCT (INT  ssize,  FROMTYPE  container),
                  FROMTYPE = UNION (REF FROMROW, REF FROMSTRUCT, REF FROMSTRING, VOID),
                  COMPONENT = STRUCT ( UNIT  unit,  TYPE  type,  FROMTYPE  container,
                                       REF COMPONENT  rest ),
                  FUNIT = STRUCT (UNIT  u,  TYPE  t,  FROMTYPE  f);
            { FROMTYPE = EMPTY implies whole input in "break_down_unit"
              and heterogeneous object (not part of single object) in "build_unit" }

            REF COMPONENT  nilcomponent = NIL;

            OP  =  =  (FROMTYPE  a, b) BOOL:
               { HONESTGUV !!!!!!! }
               CASE a IN
                  (REF FROMROW  ra)
                     CASE b IN
                        (REF FROMROW  rb)  ra IS rb
                     OUT  FALSE
                     ESAC ,
                  (REF FROMSTRUCT  sa)
                     CASE b IN
                        (REF FROMSTRUCT  sb)  sa IS sb
                     OUT  FALSE
                     ESAC ,
                  (REF FROMSTRING  ca)
                     CASE b IN
                        (REF FROMSTRING  cb)  ca IS cb
                     OUT FALSE
                     ESAC
               OUT FALSE
               ESAC;


            OP  ADJACENT = (FUNIT  l, r) BOOL:
               IF not_adjacent
               THEN  FALSE
               ELSE  CASE u OF l IN
                        (REF UINDEX  lui)
                           (f OF l = f OF r)  ANDTH
                              ( INT  lind = int(index OF lui);
                                CASE u OF r IN
                                   (REF UINDEX  rui)
                                      ( INT  rind = int(index OF rui);
                                        rind = lind + 1  ANDTH  (t OF l = t OF r)
                                      )
                                OUT  FALSE
                                ESAC
                              ) ,
                        (REF UTRIM  lut)
                           ( f OF l = CASE f OF r IN
                                         (REF FROMROW  fr)     container OF fr ,
                                         (REF FROMSTRUCT  fs)  container OF fs ,
                                         (REF FROMSTRING  fc)  container OF fc
                                      OUT  EMPTY
                                      ESAC
                           )  ANDTH  ( INT  upb = int(upb OF range OF lut);
                                       CASE u OF r IN
                                          (REF UINDEX  rut)
                                             CASE t OF l IN
                                                (REF TROW  tr)     elem OF tr = t OF r ,
                                                (REF TSTRING  ts)  char OF ts = t OF r
                                             OUT  FALSE
                                             ESAC  ANDTH  int(index OF rut) = upb + 1
                                       OUT  FALSE
                                       ESAC
                                     )

                     OUT  FALSE
                     ESAC
               FI;


            PROC  break_down_unit = (TYPE  type,  UNIT  unit) REF COMPONENT:
            BEGIN
               REF COMPONENT  ans;
               REF REF COMPONENT  cptr:= ans;

               PROC  sub_unit = (TYPE  type,  UNIT  unit,  FROMTYPE  container) VOID:
               CASE type IN
                  (REF TNAME)
                     cptr:= rest OF ( REF REF COMPONENT (cptr):= HEAP COMPONENT:=
                                         (unit, type, container, nilcomponent) ) ,
                  (REF TROW  tr)
                     ( INT  size = int(size OF tr);
                       FROMTYPE  ft = HEAP FROMROW:= (size, container);
                       FOR i TO size
                       DO  sub_unit(elem OF tr, HEAP UINDEX:= (unit, MAKEFINT i), ft)  OD
                     ) ,
                  (REF TSTR  tstr)
                     ( REF TSTR  tptr:= tstr;
                       INT  size:= 0;
                       BOOL  same_type:= TRUE;
                       WHILE tptr ISNT niltstr
                       DO  size PLUSAB 1;
                           IF NOT (elem OF tstr = elem OF tptr)
                           THEN  same_type:= FALSE
                           FI;
                           tptr:= rest OF tptr
                       OD;
                       FROMTYPE  ft = HEAP FROMSTRUCT:= (size, same_type, container);
                       INT  n:= 0;
                       tptr:= tstr;
                       WHILE tptr ISNT niltstr
                       DO  sub_unit( elem OF tptr,
                                     HEAP UINDEX:= (unit, MAKEFINT (n PLUSAB 1)),
                                     ft
                                   );
                           tptr:= rest OF tptr
                       OD
                     ) ,
                  (REF TSTRING  ts)
                     ( INT  size = int(size OF ts);
                       FROMTYPE  ft = HEAP FROMSTRING:= (size, container);
                       FOR i TO size
                       DO  sub_unit(char OF ts, HEAP UINDEX:= (unit, MAKEFINT i), ft)  OD
                     )
               ESAC;

               sub_unit(type, unit, EMPTY);

               ans
            END;


            PROC  string_row = (FUNIT  fu) FUNIT:
            BEGIN
               TYPE  base = CASE t OF fu IN
                               (REF TSTRING  ts)  char OF ts,
                               (REF TROW  tr)     elem OF tr
                            ESAC;
               FORMULA  size = CASE t OF fu IN
                                  (REF TSTRING  ts)  size OF ts,
                                  (REF TROW  tr)     size OF tr
                               ESAC;

               BOOL  to_string = CASE t OF fu IN (REF TSTRING)  FALSE  OUT  TRUE  ESAC;

               TYPE  in_type = IF to_string
                               THEN  HEAP TSTRING:= (size, base)
                               ELSE  HEAP TROW:= (size, base)
                               FI;

               TYPE  out_type = t OF fu;

{ ??? Should replace by a BIOP call for STRTOROW and ROWTOSTR  }

               HEAP FNSPEC  fnspec { :=
                 (HEAP VECTOR [1] INPUT:= INPUT (normalinput, nullstr), out_type);
               HEAP VECTOR [1] TYPE  nametypes:= in_type } ;

               RVC  fnname = IF to_string THEN  string_to_row  ELSE  row_to_string  FI;
               INSTANCE  inst = add_fnbody(fnname, reform, fnspec, nametypes);
               UNIT  unit = HEAP UMINST:= (inst, u OF fu);
               NAMETYPE nt = (call_name, tnull, attrnull);
               REF  UNAME  uname = add_nametype(nt, out_type, 0);
               make_let(nameno OF uname, unit);
               (uname, out_type, EMPTY)
            END;


            PROC  conc_unit = (VECTOR [] FUNIT  elems,  TYPE  type) FUNIT:
            BEGIN
               BOOL  string = CASE type IN (REF TSTRING)  TRUE  OUT  FALSE  ESAC;

               PROC  trim = (FUNIT  fu,  FORMULA  lwb,  upb) FUNIT:
               BEGIN
                  { Check to see whether the trim is complete.
                    fu:  u = unit of UINDEX or UTRIM,
                         t = type of element
                         f = fromtype of element
                  }

                  TYPE  t = IF string
                            THEN  HEAP TSTRING:= (upb, t OF fu)
                            ELSE  HEAP TROW:= (upb, t OF fu)
                            FI;

                  PROC  utrim = FUNIT:  ( HEAP UTRIM:= (u OF fu, (lwb, upb)), t,
                                          CASE f OF fu IN
                                             (REF FROMSTRING  fc)  container OF fc ,
                                             (REF FROMROW  fr)     container OF fr ,
                                             (REF FROMSTRUCT  fs)  container OF fs
                                          OUT  EMPTY
                                          ESAC
                                        );

                  FUNIT  funit = (u OF fu, t, EMPTY);   { for string_row }

                  INT  up = int(upb);
                  IF int(lwb) = 1
                  THEN  CASE f OF fu IN
                           (REF FROMSTRING  fc)
                              IF ssize OF fc = up
                              THEN  IF string
                                    THEN  (u OF fu, t, container OF fc)
                                    ELSE  string_row(funit)
                                    FI
                              ELSE  utrim
                              FI ,
                           (REF FROMROW  fr)
                              IF rsize OF fr = up
                              THEN  IF string
                                    THEN  string_row(funit)
                                    ELSE  (u OF fu, t, container OF fr)
                                    FI
                              ELSE  utrim
                              FI ,
                           (REF FROMSTRUCT  fs)
                              IF same OF fs  ANDTH  size OF fs = up
                              THEN  IF string
                                    THEN  string_row(funit)
                                    ELSE  (u OF fu, t, container OF fs)
                                    FI
                              ELSE  utrim
                              FI
                        OUT  utrim
                        ESAC
                  ELSE  utrim
                  FI
               END;


               PROC  add_trim = (FUNIT  l, r) FUNIT:
               BEGIN
                  CASE u OF l IN
                     (REF UINDEX  lui)
                        CASE u OF r IN
                           (REF UINDEX  rui)
                              { int(index OF rui) = int(index OF lui) + 1 }
                              trim( (unit OF lui, t OF l, f OF l),
                                    index OF lui, index OF rui )
                        ESAC ,
                     (REF UTRIM  lt)
                        CASE u OF r IN
                           (REF UINDEX  rti)
                              { UTRIM = [lwb .. int(index OF rti) + 1] }
                              trim( (unit OF lt, t OF r, f OF r), lwb OF range OF lt,
                                    index OF rti )
                        ESAC
                  ESAC
               END;


               FUNIT  ans:= (unull, tnull, EMPTY),  most_recent:= (unull, tnull, EMPTY);
               BOOL  flatten_left:= FALSE,  flatten_right:= FALSE;

               PROC  do_most_recent = VOID:
                  CASE  u OF ans IN
                     (REF UNULL)
                        ( ans:= most_recent;
                          flatten_left:= flatten_right;
                          flatten_right:= FALSE
                        )
                  OUT  ( UNIT val := u OF ans;
                         INT sort = IF flatten_left
                                    THEN  IF flatten_right
                                          THEN  flattenboth
                                          ELSE  flattenleft
                                          FI
                                    ELIF flatten_right
                                    THEN  flattenright
                                    ELSE  val := HEAP UROW:= (MAKEFINT(1), val);
                                          flattenleft
                                    FI;
                          ans:= ( HEAP UCONC:=
                                     ( string, sort, val, u OF most_recent ),
                                 tnull { fill in later }, EMPTY );
                         flatten_left:= TRUE
                       )
                  ESAC;


               FORALL elem IN elems
               DO  IF most_recent ADJACENT elem
                   THEN  most_recent:= add_trim(most_recent, elem);
                         flatten_right:= TRUE
                   ELSE  do_most_recent;
                         most_recent:= elem;
                         flatten_right:= FALSE
                   FI
               OD;
               do_most_recent;

               (u OF ans, type, f OF ans)
            END;


            PROC  build_unit = (TYPE  type,  REF COMPONENT  list) UNIT:
            BEGIN
               REF COMPONENT  cptr:= list;

               PROC  make_unit = (TYPE  type) FUNIT:
               CASE type IN
                  (REF TNAME)
                     ( FUNIT  named = (unit OF cptr, type OF cptr, container OF cptr);
                       cptr:= rest OF cptr;
                       named
                     ) ,
                  (REF TROW  tr)
                     ( VECTOR [int(size OF tr)] FUNIT  elems;
                       FORALL elem IN elems DO  elem:= make_unit(elem OF tr)  OD;
                       conc_unit(elems, type)
                     ) ,
                  (REF TSTR  tstr)
                     ( INT  n:= 0;
                       REF TSTR  tptr:= tstr;
                       BOOL  same:= TRUE;
                       WHILE tptr ISNT niltstr
                       DO  n PLUSAB 1;
                           IF NOT (elem OF tstr = elem OF tptr) THEN  same:= FALSE  FI;
                           tptr:= rest OF tptr
                       OD;
                       tptr:= tstr;
                       IF same
                       THEN  VECTOR [n] FUNIT  elems;
                             FORALL elem IN elems
                             DO  elem:= make_unit(elem OF tptr);
                                 tptr:= rest OF tptr
                             OD;
                             conc_unit(elems, type)
                       ELSE  REF USTR  ans:= nilustr;
                             REF REF USTR  uptr:= ans;
                             WHILE tptr ISNT niltstr
                             DO  uptr:= rest OF ( REF REF USTR (uptr):= HEAP USTR:=
                                                     ( u OF make_unit(elem OF tptr),
                                                       nilustr ) );
                                 tptr:= rest OF tptr
                             OD;
                             (ans, tstr, EMPTY)
                       FI
                     ) ,
                  (REF TSTRING  ts)
                     ( VECTOR [int(size OF ts)] FUNIT  elems;
                       FORALL elem IN elems DO  elem:= make_unit(char OF ts)  OD;
                       conc_unit(elems, type)
                     )

               ESAC;

               u OF make_unit(type)
            END;


            FNSPEC  new_spec = process_iospec(fdec);

            TRANSFORMPROCS  newtprocs =
                make_newtprocs(tprocs, (simplify_type, null_formula));

            TYPE  in_type = t OF simplify_type(type OF nametable[1], newtprocs),
                  out_type = t OF simplify_type(type OF nametable[2], newtprocs);

            REF COMPONENT  flattened_input =
                break_down_unit(in_type, HEAP UNAME:= (usource, 1));

            UNIT  body = build_unit(out_type, flattened_input);
            check_names;
            new_fndec(new_spec, body)
         END;


         PROC  arith = (REF ARITH  arith) FNDECC:
         BEGIN
            FNSPEC  new_spec = process_iospec(fdec);
            IF changed OF new_spec
            THEN  { Must preserve original FN to allow access
                    to the correct inputs within the ARITH }
                  INSTANCE  inst =
                     add_fnbody( make_name( fnname_names, dummy_fnname,
                                            n_fnnames PLUSAB 1 ), arith,
                                (inputs OF fdec, outputs OF fdec, FALSE),
                                 nametypes );
                  UNIT  call = HEAP UMINST:=
                     (inst, HEAP UNAME:= (usource, 1) { input });
                  new_fndec( new_spec, make_uname( call_name,
                                                   type OF nametable[2]
                                                            { output type },
                                                   call ) )
            ELSE  (fdec, FALSE)
            FI
         END;


         PROC  non_unit_body = (FNBODY  body) FNDECC:
         BEGIN
            FNSPEC  new_spec = process_iospec(fdec);
            IF changed OF new_spec
            THEN  INSTANCE  inst =
                     add_fnbody( make_name( fnname_names, dummy_fnname,
                                            n_fnnames PLUSAB 1 ), body,
                                 new_spec, nametable[:2] { in + out } );
                  UNIT  call = HEAP UMINST:=
                     (inst, HEAP UNAME:= (usource, 1) { input });
                  new_fndec( new_spec, make_uname( call_name,
                                                   type OF nametable[2]
                                                              { output type },
                                                   call ) )
            ELSE  (fdec, FALSE)
            FI
         END;



         { Process body }

         CASE fnbody OF fdec IN
            (REF UNITTAG  ut)
               unit_body(ut, tprocs) ,
            (REF REFORM  re)
               reformp(re, tprocs) ,
            (REF ARITH  ar)
               arith(ar)
         OUT  non_unit_body(fnbody OF fdec)
         ESAC
      ELSE  (fdec, FALSE)
      FI;  { end of PROC fndec }


      TRANSFORMPROCS  newtprocs = make_newtprocs(tprocs, fndec);

      IF sort OF outer = outerfn
      THEN  REF FNDEC oldfndec = get_outerfn(outer);
            FNDECC  dec = fndec(oldfndec, newtprocs);

            IF c OF dec
            THEN  replace_fndec(1, f OF dec);
                  ( (closureno OF outer, outerfn, env), TRUE )
            ELSE  ( outer, FALSE)
            FI
      ELSE  (outer, FALSE)
      FI
   END;


   TRANSFORMPROCS  newtprocs = make_newtprocs(nulltprocs, transform_outerfn);

   (closure OF nulltprocs)(closure, newtprocs, msg)
END


KEEP  lets_options,  lets_gennames,  lets_nosimplify,  lets_noadjacent,
      lets_noinst, lets_noprim,  lets_nameinputs,  lets_transform
FINISH
